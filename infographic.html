<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Updated version number in the title to reflect the fix -->
    <title>AI Infographic Creator v4.7.1</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .font-serif { font-family: serif; }
        .font-sans { font-family: sans-serif; }
        .font-mono { font-family: monospace; }
        .font-cursive { font-family: cursive; }
        [contentEditable=true]:empty:before { content: attr(placeholder); color: #9ca3af; pointer-events: none; }
        .control-section:disabled { opacity: 0.5; pointer-events: none; }
    </style>
    
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
</head>
<body class="bg-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        // Gemini API Reminder: Always increment version upon significant changes. Current Version: 4.7.1

        // --- ICONS ---
        const FileDownIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="7 10 12 15 17 10" /><line x1="12" x2="12" y1="15" y2="3" /></svg>);
        const SparklesIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg>);
        const WandIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.2 1.2 0 0 0 1.72 0L21.64 5.36a1.2 1.2 0 0 0 0-1.72Z" /><path d="m14 7 3 3" /></svg>);
        const LightbulbIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M15 14c.2-1 .7-1.7 1.5-2.5C17.7 10.2 18 9.2 18 8a6 6 0 0 0-12 0c0 1.2.3 2.2 1.5 3.5.7.8 1.3 1.5 1.5 2.5" /><path d="M9 18h6" /><path d="M10 22h4" /></svg>);
        const RefreshCwIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" /><path d="M21 3v5h-5" /><path d="M3 21a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 16" /><path d="M3 16v5h5" /></svg>);
        const EyeIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z" /><circle cx="12" cy="12" r="3" /></svg>);
        const ImageIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></svg>);
        const Spinner = ({ size = 'h-8 w-8' }) => <div className={`animate-spin rounded-full ${size} border-b-2 border-white`}></div>;

        // --- UTILITY: Converts CSS properties from kebab-case to camelCase ---
        const toCamelCase = (str) => str.replace(/-([a-z])/g, g => g[1].toUpperCase());
        const convertKeysToCamelCase = (obj) => {
            if (typeof obj !== 'object' || obj === null) return obj;
            if (Array.isArray(obj)) return obj.map(v => convertKeysToCamelCase(v));
            return Object.keys(obj).reduce((acc, key) => {
                const camelKey = toCamelCase(key);
                acc[camelKey] = convertKeysToCamelCase(obj[key]);
                return acc;
            }, {});
        };
        
        // --- Main Application ---
        function App() {
            const { useState, useRef, useEffect } = React;

            const [apiKey, setApiKey] = useState("");
            const [tempApiKey, setTempApiKey] = useState("");
            const [isContentGenerated, setIsContentGenerated] = useState(false);
            const [isInitialLayoutsLoaded, setIsInitialLayoutsLoaded] = useState(false);

            const [tasks, setTasks] = useState([]);
            const [contentPrompt, setContentPrompt] = useState("Key principles of Agile Development");
            const [mainTitle, setMainTitle] = useState("AI Infographic Creator");

            const [layoutOptions, setLayoutOptions] = useState([]);
            const [selectedLayout, setSelectedLayout] = useState({ name: 'Default Grid', layout: { containerStyle: { display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))', gap: '2rem' }, cardStyle: {}, connectorType: 'none' } });
            
            const [themePrompt, setThemePrompt] = useState("Sleek dark mode for a tech company");
            const [designTheme, setDesignTheme] = useState({ backgroundColor: '#111827', cardColor: '#1f2937', textColor: '#f3f4f6', accentColor: '#3b82f6', fontFamily: 'sans-serif', borderColor: '#374151', shadowStyle: 'shadow-lg shadow-blue-500/10' });
            
            const [exportFormat, setExportFormat] = useState('PNG');
            const [showPreviewModal, setShowPreviewModal] = useState(false);
            const [previewData, setPreviewData] = useState(null);
            
            const [showIdeasModal, setShowIdeasModal] = useState(false);
            const [ideasTopic, setIdeasTopic] = useState("Marketing");
            const [ideaList, setIdeaList] = useState([]);

            const [backgroundImage, setBackgroundImage] = useState(null);
            const [themeVariations, setThemeVariations] = useState([]);
            
            const [isLoading, setIsLoading] = useState({ content: false, icons: false, theme: false, layout: false, ideas: false, export: false, variations: false });
            const [error, setError] = useState(null);
            
            const infographicRef = useRef(null);
            const fileInputRef = useRef(null);

            useEffect(() => {
                const storedKey = localStorage.getItem("gemini_api_key");
                if (storedKey) { setApiKey(storedKey); }
            }, []);
            
            useEffect(() => {
                if (apiKey && layoutOptions.length === 0) {
                    handleGenerateLayouts();
                }
            }, [apiKey]);


            const handleApiKeySubmit = () => { if (tempApiKey.trim()) { setApiKey(tempApiKey.trim()); localStorage.setItem("gemini_api_key", tempApiKey.trim()); }};
            
            const callGeminiAPI = async (prompt, schema = null) => {
                if (!apiKey) throw new Error("API Key is not set.");
                const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }], generationConfig: { responseMimeType: "application/json" } };
                if(schema) payload.generationConfig.responseSchema = schema;
                
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`API Error: ${response.status} ${response.statusText}`);
                const result = await response.json();
                if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("API returned no content.");
                
                const rawText = result.candidates[0].content.parts[0].text;
                
                try {
                    const startIndex = rawText.indexOf('{');
                    const endIndex = rawText.lastIndexOf('}');

                    if (startIndex !== -1 && endIndex !== -1) {
                        const jsonString = rawText.substring(startIndex, endIndex + 1);
                        return JSON.parse(jsonString);
                    } else {
                        return JSON.parse(rawText);
                    }
                } catch (e) {
                    console.error("Failed to parse JSON from API response:", rawText);
                    throw new Error(`JSON Parsing Error: The AI returned a response that could not be read. This can sometimes happen with complex topics. Please try rephrasing your content prompt or try again.`);
                }
            };
            
            const handleGetIdeas = async () => { setIsLoading(p => ({...p, ideas: true})); try { const { ideas } = await callGeminiAPI(`Generate 50 infographic titles for "${ideasTopic}". Ensure any double quotes in the titles are escaped (e.g., \\").`, { type: "OBJECT", properties: { ideas: { type: "ARRAY", items: { type: "STRING" }}}}); setIdeaList(ideas); } catch (e) { setError(e.message); } finally { setIsLoading(p => ({...p, ideas: false})); }};
            const selectIdea = (idea) => { setContentPrompt(idea); setShowIdeasModal(false); };
            
            const handleGenerateContent = async () => { 
                setIsLoading(p => ({...p, content: true})); 
                setError(null); 
                setTasks([]); 
                try { 
                    const prompt = `YOU MUST ONLY RESPOND WITH A SINGLE VALID JSON OBJECT. Do not include any other text, markdown, or explanations. The JSON object is for an infographic about "${contentPrompt}". It must contain: a "mainTitle" key (string), and a "points" key (an array of 6 objects, where each object has "title" and "description" keys).`;
                    const schema = { 
                        type: "OBJECT", 
                        properties: { 
                            mainTitle: {type: "STRING"}, 
                            points: { 
                                type: "ARRAY", 
                                items: {
                                    type: "OBJECT", 
                                    properties: {
                                        title: {type:"STRING"}, 
                                        description: {type:"STRING"}
                                    },
                                    required: ["title", "description"]
                                }
                            }
                        },
                        required: ["mainTitle", "points"]
                    };

                    const { mainTitle: newTitle, points } = await callGeminiAPI(prompt, schema); 
                    setMainTitle(newTitle); 
                    const initialTasks = points.map((p, i) => ({ id: i, ...p, iconUrl: null, isIconLoading: true })); 
                    setTasks(initialTasks); 
                    setIsContentGenerated(true); 
                    Promise.all(initialTasks.map(async (task) => { 
                        try { 
                            const payload = { instances: [{ prompt: `A minimalist, flat icon for '${task.title}'` }], parameters: { "sampleCount": 1 } }; 
                            const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) }); 
                            if(res.ok) { 
                                const result = await res.json(); 
                                if (result.predictions?.[0]?.bytesBase64Encoded) { 
                                    const url = `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`; 
                                    setTasks(prev => prev.map(t => t.id === task.id ? { ...t, iconUrl: url, isIconLoading: false } : t)); 
                                }
                            } else {
                               throw new Error(`Icon generation API failed with status: ${res.status}`);
                            }
                        } catch(e) { 
                            console.error("Icon generation failed for task:", task.title, e);
                            setTasks(prev => prev.map(t => t.id === task.id ? { ...t, isIconLoading: false } : t)); 
                        }
                    })); 
                } catch(e) { 
                    setError(e.message) 
                } finally { 
                    setIsLoading(p => ({...p, content: false})); 
                }
            };

            const handleApplyTheme = async () => { setIsLoading(p => ({ ...p, theme: true })); try { const newTheme = await callGeminiAPI(`Generate a JSON design theme for: "${themePrompt}". The theme must include borderColor.`, { type: "OBJECT", properties: { backgroundColor: {type:"STRING"}, cardColor: {type:"STRING"}, textColor: {type:"STRING"}, accentColor: {type:"STRING"}, fontFamily: {type:"STRING"}, borderColor: {type:"STRING"}, shadowStyle: {type:"STRING"} }}); setDesignTheme(newTheme); } catch (e) { setError(e.message); } finally { setIsLoading(p => ({ ...p, theme: false })); }};
            
            const handleGenerateLayouts = async () => { 
                setIsLoading(p => ({ ...p, layout: true })); 
                setError(null);
                try { 
                    const prompt = `Generate a valid JSON object with a single key "layouts". The value of "layouts" should be an array of 25 creative infographic layout ideas. For each item in the array, provide a 'name' (string) and a 'layout' (object). The 'layout' object must contain: 1. 'containerStyle': A string containing a valid, escaped JSON object for CSS-in-JS. 2. 'cardStyle': A string containing a valid, escaped JSON object for CSS-in-JS. 3. 'connectorType': A string, either 'none', 'vertical-line', 'horizontal-line', 'radial-line', or 'organic-swoop'. Ensure all JSON keys and string values use double quotes, and the final output is only the single, valid JSON object.`;
                    
                    const layoutSchema = {
                        type: "OBJECT",
                        properties: {
                            layouts: {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        name: { type: "STRING" },
                                        layout: {
                                            type: "OBJECT",
                                            properties: {
                                                containerStyle: { type: "STRING" },
                                                cardStyle: { type: "STRING" },
                                                connectorType: { type: "STRING" }
                                            },
                                            required: ["containerStyle", "cardStyle", "connectorType"]
                                        }
                                    },
                                    required: ["name", "layout"]
                                }
                            }
                        },
                        required: ["layouts"]
                    };

                    const { layouts } = await callGeminiAPI(prompt, layoutSchema); 
                    
                    const parsedLayouts = layouts.map(l => {
                        try {
                            const container = JSON.parse(l.layout.containerStyle || '{}');
                            const card = JSON.parse(l.layout.cardStyle || '{}');
                            
                            const newLayout = {
                                ...l.layout,
                                containerStyle: convertKeysToCamelCase(container),
                                cardStyle: convertKeysToCamelCase(card),
                            };
                            return { ...l, layout: newLayout };
                        } catch (e) {
                            console.error("Failed to parse layout style strings for:", l.name, e);
                            return { ...l, layout: { containerStyle: {}, cardStyle: {}, connectorType: 'none' } };
                        }
                    });

                    // --- FIX: Ensure layout names are unique to prevent React key errors ---
                    const nameCounts = {};
                    const uniqueLayouts = parsedLayouts.map(layout => {
                        nameCounts[layout.name] = (nameCounts[layout.name] || 0) + 1;
                        const newLayout = {...layout};
                        if (nameCounts[layout.name] > 1) {
                            newLayout.name = `${layout.name} ${nameCounts[layout.name]}`;
                        }
                        return newLayout;
                    });


                    setLayoutOptions(uniqueLayouts); 

                    if(uniqueLayouts.length > 0) {
                        if(!isInitialLayoutsLoaded) {
                            setSelectedLayout(uniqueLayouts[0]); 
                            setIsInitialLayoutsLoaded(true);
                        }
                    }
                } catch (e) { 
                    setError(e.message); 
                    if (!isInitialLayoutsLoaded) {
                        const defaultLayout = [{ name: 'Default Grid', layout: { containerStyle: { display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))', gap: '2rem' }, cardStyle: {}, connectorType: 'none' } }];
                        setLayoutOptions(defaultLayout);
                        setSelectedLayout(defaultLayout[0]);
                        setIsInitialLayoutsLoaded(true); 
                    }
                } finally { 
                    setIsLoading(p => ({ ...p, layout: false })); 
                }
            };

            const handleGenerateThemeVariations = async () => {
                setIsLoading(p => ({ ...p, variations: true }));
                setError(null);
                setThemeVariations([]);
                try {
                    const prompt = `Based on the theme "${themePrompt}", generate an array of 4 alternative JSON design theme objects. Each object should be a unique variation (e.g., more vibrant, more professional, minimalist, artistic). Each theme must include: backgroundColor, cardColor, textColor, accentColor, fontFamily, borderColor, and shadowStyle.`;
                    const schema = {
                        type: "OBJECT",
                        properties: {
                            themes: {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        backgroundColor: {type:"STRING"}, cardColor: {type:"STRING"}, textColor: {type:"STRING"}, accentColor: {type:"STRING"}, fontFamily: {type:"STRING"}, borderColor: {type:"STRING"}, shadowStyle: {type:"STRING"}
                                    },
                                    required: ["backgroundColor", "cardColor", "textColor", "accentColor", "fontFamily", "borderColor", "shadowStyle"]
                                }
                            }
                        },
                        required: ["themes"]
                    };
                    const { themes } = await callGeminiAPI(prompt, schema);
                    setThemeVariations(themes);
                } catch(e) {
                    setError(e.message);
                } finally {
                    setIsLoading(p => ({ ...p, variations: false }));
                }
            };

            const handleImageUpload = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        setBackgroundImage(reader.result);
                    };
                    reader.readAsDataURL(file);
                }
            };

            const handlePreview = async () => { setIsLoading(p => ({...p, export: true})); try { const canvas = await html2canvas(infographicRef.current, { backgroundColor: designTheme.backgroundColor, useCORS: true, scale: 2 }); const imgData = canvas.toDataURL('image/png'); if (exportFormat === 'LinkedIn') { const { postText } = await callGeminiAPI(`Generate a short, engaging LinkedIn post for an infographic titled "${mainTitle}".`); setPreviewData({ type: 'LinkedIn', image: imgData, text: postText }); } else { setPreviewData({ type: exportFormat, image: imgData }); } setShowPreviewModal(true); } catch (e) { setError(e.message); } finally { setIsLoading(p => ({...p, export: false})); }};
            
            if (!apiKey) return <ApiKeyModal value={tempApiKey} onChange={setTempApiKey} onSubmit={handleApiKeySubmit} />;

            const mainContainerStyle = {
                backgroundColor: designTheme.cardColor,
                color: designTheme.textColor,
                backgroundImage: backgroundImage ? `url(${backgroundImage})` : 'none',
                backgroundSize: 'cover',
                backgroundPosition: 'center',
            };

            return (
                <div className={`min-h-screen ${designTheme.fontFamily}`} style={{ backgroundColor: designTheme.backgroundColor, color: designTheme.textColor }}>
                    <div className="flex flex-col lg:flex-row items-start p-4 sm:p-6 lg:p-8">
                    <div className="w-full lg:w-96 lg:mr-8 bg-white/10 backdrop-blur-md border border-white/20 p-6 rounded-2xl shadow-lg mb-8 lg:mb-0 sticky top-8">
                        <div className="flex justify-between items-center border-b border-white/20 pb-3 mb-6">
                            <h2 className="text-2xl font-bold">Creator Studio</h2>
                            <span className="text-xs font-mono opacity-50">v4.7.1</span>
                        </div>

                        {!isInitialLayoutsLoaded && (
                            <div className="flex items-center justify-center p-4 mb-4 text-sm text-blue-300 bg-blue-900/50 rounded-lg">
                                <Spinner size="h-5 w-5" />
                                <span className="ml-3">Initializing creative layouts...</span>
                            </div>
                        )}

                        <div className="space-y-6">
                            <fieldset disabled={!isInitialLayoutsLoaded} className="control-section">
                               <label className="block text-sm font-bold mb-2">Step 1: Create Your Content</label>
                               <textarea value={contentPrompt} onChange={(e) => setContentPrompt(e.target.value)} className="w-full p-2 bg-white/10 border border-white/20 rounded-lg" rows="3" placeholder="Enter a topic..."></textarea>
                               <button onClick={handleGenerateContent} disabled={isLoading.content} className="w-full mt-2 flex items-center justify-center bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 disabled:bg-green-400 disabled:opacity-50">
                                    <SparklesIcon className="mr-2 w-5 h-5" />
                                    {isLoading.content ? 'Creating...' : 'Create Infographic'}
                                </button>
                                <button onClick={() => setShowIdeasModal(true)} className="w-full mt-2 text-sm text-center opacity-80 hover:opacity-100 disabled:opacity-50">or Get Topic Ideas</button>
                            </fieldset>

                            <fieldset disabled={!isContentGenerated} className="control-section space-y-4 pt-4 border-t border-white/20">
                                <legend className="text-sm font-bold mb-2 w-full">Step 2: Customize Your Design</legend>
                                <label className="text-xs font-medium">Layout Style</label>
                                <div className="flex items-center space-x-2">
                                     <select value={selectedLayout.name} onChange={e => setSelectedLayout(layoutOptions.find(opt => opt.name === e.target.value))} className="w-full p-2 bg-gray-700 border border-gray-600 text-white rounded-lg" disabled={isLoading.layout}>
                                        {layoutOptions.length === 0 && <option>{isLoading.layout ? 'Loading layouts...' : selectedLayout.name}</option>}
                                        {layoutOptions.map((opt) => <option key={opt.name} value={opt.name}>{opt.name}</option>)}
                                     </select>
                                     <button onClick={handleGenerateLayouts} disabled={isLoading.layout} className="p-2 bg-blue-600 rounded-lg hover:bg-blue-700 disabled:bg-blue-400">{isLoading.layout ? <Spinner size="h-5 w-5"/> : <RefreshCwIcon className="w-5 h-5"/>}</button>
                                </div>
                                <label className="text-xs font-medium">Describe Theme Style</label>
                                <div className="flex items-center space-x-2">
                                     <input type="text" value={themePrompt} onChange={e => setThemePrompt(e.target.value)} className="w-full p-2 bg-white/10 border border-white/20 rounded-lg" />
                                     <button onClick={handleApplyTheme} disabled={isLoading.theme} className="p-2 bg-blue-600 rounded-lg hover:bg-blue-700 disabled:bg-blue-400">{isLoading.theme ? <Spinner size="h-5 w-5"/> : <WandIcon className="w-5 h-5"/>}</button>
                                </div>
                            </fieldset>
                             
                            <fieldset disabled={!isContentGenerated} className="control-section space-y-4 pt-4 border-t border-white/20">
                                <legend className="text-sm font-bold mb-2 w-full">Step 3: Visual Effects</legend>
                                <button onClick={() => fileInputRef.current.click()} className="w-full mt-2 flex items-center justify-center bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700">
                                    <ImageIcon className="mr-2 w-5 h-5" />
                                    Upload Background Image
                                </button>
                                <input type="file" ref={fileInputRef} onChange={handleImageUpload} accept="image/*" className="hidden" />
                                
                                <button onClick={handleGenerateThemeVariations} disabled={isLoading.variations} className="w-full mt-2 flex items-center justify-center bg-teal-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-teal-700 disabled:bg-teal-400">
                                    <SparklesIcon className="mr-2 w-5 h-5" />
                                    {isLoading.variations ? 'Generating...' : 'Get Theme Variations'}
                                </button>
                                {themeVariations.length > 0 && (
                                    <div className="grid grid-cols-2 gap-2 mt-2">
                                        {themeVariations.map((theme, index) => (
                                            <div key={index} onClick={() => setDesignTheme(theme)} className="p-2 rounded-lg cursor-pointer h-16 flex flex-col justify-center items-center text-center" style={{backgroundColor: theme.backgroundColor, color: theme.textColor, border: `2px solid ${theme.accentColor}`}}>
                                               <span className="text-xs font-bold">Variation {index + 1}</span>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </fieldset>

                             <fieldset disabled={!isContentGenerated} className="control-section space-y-4 pt-4 border-t border-white/20">
                                <legend className="text-sm font-bold mb-2 w-full">Step 4: Preview & Export</legend>
                                <select value={exportFormat} onChange={e => setExportFormat(e.target.value)} className="w-full p-2 bg-gray-700 border border-gray-600 text-white rounded-lg">
                                    <option value="PNG">Static Infographic (PNG)</option>
                                    <option value="PDF">PDF Document</option>
                                    <option value="GIF">Animated GIF</option>
                                    <option value="LinkedIn">LinkedIn Post</option>
                                </select>
                                <button onClick={handlePreview} disabled={isLoading.export} className="w-full mt-2 flex items-center justify-center bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 disabled:bg-blue-400">
                                    <EyeIcon className="mr-2 w-5 h-5" />
                                    {isLoading.export ? 'Generating Preview...' : 'Preview Export'}
                                 </button>
                            </fieldset>
                        </div>
                         {error && <p className="text-red-400 text-sm mt-4 bg-red-500/20 p-2 rounded-lg">{error}</p>}
                    </div>

                    <div className="w-full lg:flex-1">
                        <div ref={infographicRef} className="p-6 sm:p-8 md:p-12 rounded-2xl shadow-lg min-h-[600px] transition-all duration-500" style={mainContainerStyle}>
                            <h1 className="text-3xl sm:text-4xl md:text-5xl font-bold text-center mb-10 md:mb-16" style={{textShadow: '2px 2px 8px rgba(0,0,0,0.5)'}}>{mainTitle}</h1>
                            {isLoading.content && <div className="flex justify-center items-center"><div className="animate-spin rounded-full h-12 w-12 border-b-2 border-gray-400"></div></div>}
                            <DynamicLayout definition={selectedLayout.layout} tasks={tasks} designTheme={designTheme} />
                        </div>
                    </div>
                    {showPreviewModal && <PreviewModal data={previewData} onClose={() => setShowPreviewModal(false)} />}
                    {showIdeasModal && <IdeaGeneratorModal onClose={() => setShowIdeasModal(false)} onSelect={selectIdea} onGenerate={handleGetIdeas} ideas={ideaList} topic={ideasTopic} setTopic={setIdeasTopic} isLoading={isLoading.ideas} />}
                    </div>
                </div>
            );
        }
        
        // --- Child Components ---
        const DynamicLayout = ({ definition, tasks, designTheme }) => ( <div className="relative" style={definition?.containerStyle}>{tasks.map(task => <Card key={task.id} task={task} designTheme={designTheme} cardStyle={definition?.cardStyle} />)}</div> );
        
        const Card = ({ task, designTheme, cardStyle }) => {
            const safeCardStyle = { ...cardStyle };
            delete safeCardStyle.border;

            const combinedCardStyle = {
                ...safeCardStyle, 
                backgroundColor: designTheme.cardColor,
                opacity: 1,
                borderWidth: '1px',
                borderStyle: 'solid',
                borderColor: designTheme.borderColor,
            };
            
            const cardClassName = `infographic-card backdrop-blur-sm p-6 rounded-xl flex flex-col items-center text-center transition-all ${designTheme.shadowStyle}`;

            return (
                <div 
                    className={cardClassName} 
                    style={combinedCardStyle}
                >
                    <div className="w-24 h-24 mb-5 shadow-lg rounded-full flex items-center justify-center overflow-hidden" style={{ backgroundColor: designTheme.accentColor }}>
                        {task.isIconLoading ? <Spinner /> : task.iconUrl ? <img src={task.iconUrl} alt={task.title} className="w-full h-full object-cover" /> : <div className="text-gray-400 text-xs p-1">?</div>}
                    </div>
                    <h3 className="text-xl font-bold break-words">{task.title}</h3>
                    <p className="text-base break-words">{task.description}</p>
                </div>
            );
        };
        
        const IdeaGeneratorModal = ({ onClose, onSelect, onGenerate, ideas, topic, setTopic, isLoading }) => ( <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4"><div className="bg-gray-800 text-white p-6 rounded-lg shadow-2xl w-full max-w-2xl max-h-[80vh] flex flex-col"><h2 className="text-2xl font-bold mb-4">Infographic Idea Generator</h2><div className="flex space-x-2 mb-4"><input type="text" value={topic} onChange={e => setTopic(e.target.value)} placeholder="Enter a broad topic..." className="w-full p-2 bg-gray-700 border border-gray-600 rounded-lg"/><button onClick={onGenerate} disabled={isLoading} className="p-2 bg-blue-600 rounded-lg hover:bg-blue-700 disabled:bg-blue-400">{isLoading ? <Spinner size="h-5 w-5"/> : 'Get Ideas'}</button></div><ul className="flex-grow overflow-y-auto space-y-2 pr-2">{ideas.map((idea, i) => <li key={i} onClick={() => onSelect(idea)} className="p-3 bg-gray-700 rounded-md hover:bg-blue-600 cursor-pointer transition-colors">{idea}</li>)}</ul><button onClick={onClose} className="mt-4 text-sm text-gray-400">Close</button></div></div> );
        const PreviewModal = ({ data, onClose }) => { const handleDownload = () => { const link = document.createElement('a'); link.download = `ai-infographic.${data.type.toLowerCase()}`; link.href = data.image; link.click(); }; return(<div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4"><div className="bg-gray-800 text-white p-6 rounded-lg shadow-2xl w-full max-w-4xl flex flex-col md:flex-row space-y-4 md:space-y-0 md:space-x-6"><div className="md:w-1/2"><h3 className="font-bold mb-2">Preview</h3><img src={data.image} className="rounded-lg w-full border-2 border-gray-600" /></div><div className="md:w-1/2 flex flex-col"><h3 className="font-bold mb-2">Export Actions</h3>{data.type === 'LinkedIn' && <textarea readOnly className="w-full h-40 p-2 bg-gray-700 border border-gray-600 rounded-lg text-sm mb-2" value={data.text}></textarea>}<button onClick={handleDownload} className="w-full bg-blue-600 rounded-lg py-2 mb-2">Download {data.type}</button><button onClick={onClose} className="mt-auto text-sm text-gray-400 w-full pt-2">Close</button></div></div></div>);};
        const ApiKeyModal = ({ value, onChange, onSubmit }) => ( <div className="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center z-50 p-4"><div className="bg-white p-8 rounded-lg shadow-2xl w-full max-w-md"><h2 className="text-2xl font-bold mb-4">API Key Required</h2><p className="text-gray-600 mb-6">Please provide your Google AI Studio API key to use the generative features.</p><input type="password" value={value} onChange={e => onChange(e.target.value)} placeholder="Enter your API key" className="w-full p-2 border border-gray-300 rounded-lg mb-4"/><button onClick={onSubmit} className="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700">Save and Continue</button></div></div> );
        
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);

    </script>
</body>
</html>
