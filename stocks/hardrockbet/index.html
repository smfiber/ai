<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>College Football AI Narratives</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üèà</text></svg>">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .card-enter {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        .card-enter-active {
            opacity: 1;
            transform: translateY(0);
        }
        .prose {
            font-size: 1.125rem;
            line-height: 1.75;
        }
        .prose h1, .prose h2, .prose h3, .prose h4 {
            color: #fff;
        }
        .prose p, .prose li, .prose blockquote {
            color: #d1d5db;
            margin-top: 1.25em;
            margin-bottom: 1.25em;
        }
        .prose strong {
            color: #fff;
        }
        .prose blockquote {
            border-left-color: #4a5568;
            padding-left: 1em;
        }
        .prose a {
            color: #60a5fa;
        }
        .prose h3 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-top: 2em;
            margin-bottom: 1em;
            border-bottom: 1px solid #4a5568;
            padding-bottom: 0.5rem;
        }
        /* Custom Scrollbar Styles */
        #narrativeModalContent::-webkit-scrollbar {
            width: 8px;
        }
        #narrativeModalContent::-webkit-scrollbar-track {
            background: #2d3748; /* gray-800 */
        }
        #narrativeModalContent::-webkit-scrollbar-thumb {
            background-color: #4a5568; /* gray-600 */
            border-radius: 10px;
            border: 2px solid #2d3748; /* gray-800 */
        }
        /* Accordion Styles */
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out, margin 0.3s ease-out;
            padding-left: 1rem;
            padding-right: 1rem;
        }
        .accordion-arrow {
            transition: transform 0.3s ease;
        }
        /* Input Focus Glow */
        .input-glow:focus {
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
        }
        .confidence-low { border-left: 4px solid #3b82f6; } /* blue-500 */
        .confidence-medium { border-left: 4px solid #22c55e; } /* green-500 */
        .confidence-high { border-left: 4px solid #f97316; } /* orange-500 */
        .confidence-very-high { border-left: 4px solid #ef4444; } /* red-500 */
        .pick-btn.selected {
            background-color: #2563eb; /* blue-600 */
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.7);
            border-color: #3b82f6;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div id="user-profile" class="absolute top-4 right-4 flex items-center"></div>

    <div id="apiKeyModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-gray-800 p-8 rounded-lg shadow-2xl w-full max-w-md mx-4 overflow-y-auto max-h-screen">
            <h2 class="text-2xl font-bold mb-4 text-center">Enter API Keys & Config</h2>
            <p class="text-gray-400 mb-6 text-center">Please provide your API keys and Firebase config to start.</p>
            <form id="apiKeyForm">
                <div class="mb-4">
                    <label for="oddsApiKeyInput" class="block text-gray-400 text-sm font-bold mb-2">The Odds API Key:</label>
                    <input type="password" id="oddsApiKeyInput" class="input-glow w-full bg-gray-700 border border-gray-600 rounded-md px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Your Odds API Key">
                </div>
                <div class="mb-4">
                    <label for="cfbDataApiKeyInput" class="block text-gray-400 text-sm font-bold mb-2">College Football Data API Key:</label>
                    <input type="password" id="cfbDataApiKeyInput" class="input-glow w-full bg-gray-700 border border-gray-600 rounded-md px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-red-500" placeholder="Your CFB Data API Key">
                </div>
                <div class="mb-4">
                    <label for="geminiApiKeyInput" class="block text-gray-400 text-sm font-bold mb-2">Google Gemini API Key:</label>
                    <input type="password" id="geminiApiKeyInput" class="input-glow w-full bg-gray-700 border border-gray-600 rounded-md px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-green-500" placeholder="Your Gemini API Key">
                </div>
                 <div class="mb-4">
                    <label for="googleApiKeyInput" class="block text-gray-400 text-sm font-bold mb-2">Google Search API Key:</label>
                    <input type="password" id="googleApiKeyInput" class="input-glow w-full bg-gray-700 border border-gray-600 rounded-md px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-500" placeholder="Your Google API Key">
                </div>
                <div class="mb-4">
                    <label for="googleCxInput" class="block text-gray-400 text-sm font-bold mb-2">Google Engine ID (CX):</label>
                    <input type="password" id="googleCxInput" class="input-glow w-full bg-gray-700 border border-gray-600 rounded-md px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-500" placeholder="Your Google Engine ID">
                </div>
                <div class="mb-6">
                    <label for="firebaseConfigInput" class="block text-gray-400 text-sm font-bold mb-2">Firebase Config (JSON):</label>
                    <textarea id="firebaseConfigInput" rows="6" class="input-glow w-full bg-gray-700 border border-gray-600 rounded-md px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-yellow-500" placeholder='{ "apiKey": "...", "authDomain": "...", ... }'></textarea>
                </div>
                <button type="submit" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition duration-300">Start Application</button>
            </form>
        </div>
    </div>

    <div id="narrativeModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 p-8 rounded-lg shadow-2xl w-full max-w-4xl mx-4 relative flex flex-col">
            <button id="closeNarrativeModal" class="absolute top-4 right-6 text-gray-400 hover:text-white text-3xl font-bold z-10">&times;</button>
            <div id="narrativeModalContent" class="flex-grow max-h-[80vh] overflow-y-auto pr-8 pb-8">
                </div>
            <div id="modal-footer" class="flex-shrink-0 pt-4 border-t border-gray-600">
                 <button id="copyNarrativeBtn" class="absolute bottom-6 right-8 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-300">Copy Text</button>
            </div>
        </div>
    </div>


    <div id="app" class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-10">
            <h1 class="text-4xl md:text-5xl font-bold">College Football Weekly</h1>
            <p class="text-gray-400 mt-2">AI-Generated Game Narratives Based on Live Spreads</p>
        </header>

        <div id="mainLoader" class="flex justify-center items-center my-16 hidden">
            <div class="loader"></div>
            <p id="mainLoaderText" class="ml-4 text-lg">Fetching upcoming games...</p>
        </div>
        
        <div id="errorDisplay" class="hidden bg-red-900 border border-red-700 text-red-200 px-4 py-3 rounded-lg relative my-4" role="alert">
            <strong class="font-bold">Error:</strong>
            <span id="errorMessage" class="block sm:inline"></span>
        </div>

        <div id="featured-game" class="mb-12"></div>

        <div id="games-list" class="space-y-8">
            </div>

    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, addDoc, collection, query, where, getDocs } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";

        // Version 7.5 - Set injuries API call to previous year to avoid offseason errors.
        document.addEventListener('DOMContentLoaded', () => {
            const apiKeyModal = document.getElementById('apiKeyModal');
            const apiKeyForm = document.getElementById('apiKeyForm');
            const oddsApiKeyInput = document.getElementById('oddsApiKeyInput');
            const cfbDataApiKeyInput = document.getElementById('cfbDataApiKeyInput');
            const geminiApiKeyInput = document.getElementById('geminiApiKeyInput');
            const googleApiKeyInput = document.getElementById('googleApiKeyInput');
            const googleCxInput = document.getElementById('googleCxInput');
            const firebaseConfigInput = document.getElementById('firebaseConfigInput');
            
            const narrativeModal = document.getElementById('narrativeModal');
            const narrativeModalContent = document.getElementById('narrativeModalContent');
            const closeNarrativeModal = document.getElementById('closeNarrativeModal');
            const copyNarrativeBtn = document.getElementById('copyNarrativeBtn');
            const modalFooter = document.getElementById('modal-footer');

            const mainLoader = document.getElementById('mainLoader');
            const mainLoaderText = document.getElementById('mainLoaderText');
            const errorDisplay = document.getElementById('errorDisplay');
            const errorMessage = document.getElementById('errorMessage');
            const gamesList = document.getElementById('games-list');
            const featuredGameContainer = document.getElementById('featured-game');
            const userProfileContainer = document.getElementById('user-profile');
            
            let oddsApiKey = '', cfbDataApiKey = '', geminiApiKey = '', googleApiKey = '', googleCx = '';
            let currentNarrativeText = '';
            let gamePicks = new Map();
            let savedAnalysesCache = new Map();
            let auth, db, user;
            let initialLoadComplete = false;

            // --- Caching Objects ---
            let teamDataCache = {};
            let spCache = {};
            let talentCache = {};
            let recordsCache = {};
            let returningProductionCache = {};
            let advancedStatsCache = {};
            let injuriesCache = {};
            let keyPlayersCache = {};

            const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

            // --- Initialization ---
            function init() {
                apiKeyModal.classList.remove('hidden');
            }

            apiKeyForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const oddsKey = oddsApiKeyInput.value.trim();
                const cfbDataKey = cfbDataApiKeyInput.value.trim();
                const geminiKey = geminiApiKeyInput.value.trim();
                const googleKey = googleApiKeyInput.value.trim();
                const cxKey = googleCxInput.value.trim();
                const firebaseConfigString = firebaseConfigInput.value.trim();
                
                if (oddsKey && cfbDataKey && geminiKey && googleKey && cxKey && firebaseConfigString) {
                    try {
                        const firebaseConfig = JSON.parse(firebaseConfigString);
                        initializeApp(firebaseConfig);
                        auth = getAuth();
                        db = getFirestore();
                        
                        oddsApiKey = oddsKey;
                        cfbDataApiKey = cfbDataKey;
                        geminiApiKey = geminiKey;
                        googleApiKey = googleKey;
                        googleCx = cxKey;
                        apiKeyModal.classList.add('hidden');

                        await initializeAndCacheData();

                        onAuthStateChanged(auth, async (currentUser) => {
                            user = currentUser;
                            updateUserProfile();
                            if (user) {
                                await Promise.all([loadGamePicks(), loadSavedAnalyses()]);
                            } else {
                                gamePicks.clear();
                                savedAnalysesCache.clear();
                            }

                            // Always refetch games on auth change to sync UI
                            if(initialLoadComplete) {
                                fetchOdds();
                            } else {
                                fetchOdds();
                                initialLoadComplete = true;
                            }
                        });

                    } catch (error) {
                        alert("Invalid Firebase configuration or caching failed. Please check console.");
                        console.error("Initialization error:", error);
                    }
                } else {
                    alert('Please provide all API keys and the Firebase config.');
                }
            });

            closeNarrativeModal.addEventListener('click', () => {
                narrativeModal.classList.add('hidden');
            });

            copyNarrativeBtn.addEventListener('click', () => {
                navigator.clipboard.writeText(currentNarrativeText).then(() => {
                    copyNarrativeBtn.textContent = 'Copied!';
                    setTimeout(() => {
                        copyNarrativeBtn.textContent = 'Copy Text';
                    }, 2000);
                });
            });


            // --- Caching and API Fetching ---

            async function initializeAndCacheData() {
                showLoader(true, "Caching seasonal data...");
                try {
                    const currentYear = new Date().getFullYear();
                    const previousYear = currentYear - 1;

                    // Fetch talent data with fallback
                    let talentData = await cfbApiFetch(`https://api.collegefootballdata.com/talent?year=${currentYear}`);
                    if (!talentData || talentData.length === 0) {
                        console.log(`Talent data for ${currentYear} not found, falling back to ${previousYear}.`);
                        talentData = await cfbApiFetch(`https://api.collegefootballdata.com/talent?year=${previousYear}`);
                    }
                    
                    if (talentData && talentData.length > 0) {
                        console.log("--- Raw Talent API Data (Top 5) ---");
                        console.log(talentData.slice(0, 5));
                        console.log("------------------------------------");
                    } else {
                        console.warn("--- No Talent API Data was found for current or previous year. ---");
                    }

                    const endpoints = {
                        spCurrent: `https://api.collegefootballdata.com/ratings/sp?year=${currentYear}`,
                        spPrevious: `https://api.collegefootballdata.com/ratings/sp?year=${previousYear}`,
                        recordsCurrent: `https://api.collegefootballdata.com/records?year=${currentYear}`,
                        recordsPrevious: `https://api.collegefootballdata.com/records?year=${previousYear}`,
                        returningProduction: `https://api.collegefootballdata.com/player/returning?year=${previousYear}`,
                        statsCurrent: `https://api.collegefootballdata.com/stats/season/advanced?year=${currentYear}`,
                        statsPrevious: `https://api.collegefootballdata.com/stats/season/advanced?year=${previousYear}`
                    };

                    const [
                        spCurrentData, spPreviousData,
                        recordsCurrentData, recordsPreviousData,
                        returningData, statsCurrentData, statsPreviousData
                    ] = await Promise.all(Object.values(endpoints).map(url => cfbApiFetch(url)));

                    const processData = (data, key) => data.reduce((acc, item) => {
                        acc[item[key]] = item;
                        return acc;
                    }, {});
                    
                    if (talentData) {
                        talentCache = processData(talentData, 'school');
                    }

                    spCache[currentYear] = processData(spCurrentData, 'team');
                    spCache[previousYear] = processData(spPreviousData, 'team');
                    recordsCache[currentYear] = processData(recordsCurrentData, 'team');
                    recordsCache[previousYear] = processData(recordsPreviousData, 'team');
                    returningProductionCache = processData(returningData, 'team');
                    advancedStatsCache[currentYear] = processData(statsCurrentData, 'team');
                    advancedStatsCache[previousYear] = processData(statsPreviousData, 'team');

                } catch (error) {
                    console.error("Failed to cache seasonal data:", error);
                    showError("Could not initialize app data. Please check API keys and refresh.");
                    throw error; // Propagate error to stop initialization
                } finally {
                    showLoader(false);
                }
            }

            async function fetchOdds() {
                showLoader(true, "Fetching upcoming games...");
                clearError();
                gamesList.innerHTML = '';
                featuredGameContainer.innerHTML = '';

                const sport = 'americanfootball_ncaaf';
                const regions = 'us';
                const markets = 'spreads';
                const oddsFormat = 'american';
                const apiUrl = `https://api.the-odds-api.com/v4/sports/${sport}/odds/?regions=${regions}&markets=${markets}&oddsFormat=${oddsFormat}&apiKey=${oddsApiKey}`;

                try {
                    const response = await fetch(apiUrl);
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    if (data.length === 0) {
                        throw new Error("No upcoming college football games found.");
                    }
                    const teamData = await fetchAllTeamLogos();
                    displayGames(data, teamData);
                } catch (error) {
                    console.error('Error fetching odds:', error);
                    showError(`Failed to fetch odds: ${error.message}`);
                } finally {
                    showLoader(false);
                }
            }
            
            async function fetchAllTeamLogos() {
                const url = `https://api.collegefootballdata.com/teams/fbs?year=${new Date().getFullYear()}`;
                const data = await cfbApiFetch(url);
                if (!data) return {};
                return data.reduce((acc, team) => {
                    let logoUrl = team.logos?.[0] || null;
                    if (logoUrl && logoUrl.startsWith('http://')) {
                        logoUrl = logoUrl.replace('http://', 'https://');
                    }
                    acc[team.school] = logoUrl;
                    return acc;
                }, {});
            }
            
            const teamNameAliases = {
                // --- Major Conferences ---
                // SEC
                "Alabama Crimson Tide": "Alabama", "Arkansas Razorbacks": "Arkansas", "Auburn Tigers": "Auburn", "Florida Gators": "Florida", "Georgia Bulldogs": "Georgia", "Kentucky Wildcats": "Kentucky", "LSU Tigers": "LSU", "Mississippi State Bulldogs": "Mississippi State", "Missouri Tigers": "Missouri", "Oklahoma Sooners": "Oklahoma", "Ole Miss Rebels": "Mississippi", "South Carolina Gamecocks": "South Carolina", "Tennessee Volunteers": "Tennessee", "Texas A&M Aggies": "Texas A&M", "Texas Longhorns": "Texas", "Vanderbilt Commodores": "Vanderbilt",
                // Big Ten
                "Illinois Fighting Illini": "Illinois", "Indiana Hoosiers": "Indiana", "Iowa Hawkeyes": "Iowa", "Maryland Terrapins": "Maryland", "Michigan State Spartans": "Michigan State", "Michigan Wolverines": "Michigan", "Minnesota Golden Gophers": "Minnesota", "Nebraska Cornhuskers": "Nebraska", "Northwestern Wildcats": "Northwestern", "Ohio State Buckeyes": "Ohio State", "Oregon Ducks": "Oregon", "Penn State Nittany Lions": "Penn State", "Purdue Boilermakers": "Purdue", "Rutgers Scarlet Knights": "Rutgers", "UCLA Bruins": "UCLA", "USC Trojans": "USC", "Washington Huskies": "Washington", "Wisconsin Badgers": "Wisconsin",
                // Big 12
                "Arizona State Sun Devils": "Arizona State", "Arizona Wildcats": "Arizona", "Baylor Bears": "Baylor", "BYU Cougars": "BYU", "Cincinnati Bearcats": "Cincinnati", "Colorado Buffaloes": "Colorado", "Houston Cougars": "Houston", "Iowa State Cyclones": "Iowa State", "Kansas Jayhawks": "Kansas", "Kansas State Wildcats": "Kansas State", "Oklahoma State Cowboys": "Oklahoma State", "TCU Horned Frogs": "TCU", "Texas Tech Red Raiders": "Texas Tech", "UCF Knights": "UCF", "Utah Utes": "Utah", "West Virginia Mountaineers": "West Virginia",
                // ACC
                "Boston College Eagles": "Boston College", "California Golden Bears": "California", "Clemson Tigers": "Clemson", "Duke Blue Devils": "Duke", "Florida State Seminoles": "Florida State", "Georgia Tech Yellow Jackets": "Georgia Tech", "Louisville Cardinals": "Louisville", "Miami Hurricanes": "Miami", "NC State Wolfpack": "NC State", "North Carolina Tar Heels": "North Carolina", "Pittsburgh Panthers": "Pittsburgh", "SMU Mustangs": "SMU", "Stanford Cardinal": "Stanford", "Syracuse Orange": "Syracuse", "Virginia Cavaliers": "Virginia", "Virginia Tech Hokies": "Virginia Tech", "Wake Forest Demon Deacons": "Wake Forest",
                // --- Group of Five & Independents ---
                // American Athletic
                "Army Black Knights": "Army", "Charlotte 49ers": "Charlotte", "East Carolina Pirates": "East Carolina", "Florida Atlantic Owls": "Florida Atlantic", "Memphis Tigers": "Memphis", "Navy Midshipmen": "Navy", "North Texas Mean Green": "North Texas", "Rice Owls": "Rice", "South Florida Bulls": "South Florida", "Temple Owls": "Temple", "Tulane Green Wave": "Tulane", "Tulsa Golden Hurricane": "Tulsa", "UAB Blazers": "UAB", "UTSA Roadrunners": "UT San Antonio",
                // Conference USA
                "FIU Panthers": "Florida International", "Jacksonville State Gamecocks": "Jacksonville State", "Kennesaw State Owls": "Kennesaw State", "Liberty Flames": "Liberty", "Louisiana Tech Bulldogs": "Louisiana Tech", "Middle Tennessee Blue Raiders": "Middle Tennessee", "New Mexico State Aggies": "New Mexico State", "Sam Houston Bearkats": "Sam Houston State", "UTEP Miners": "UTEP", "Western Kentucky Hilltoppers": "Western Kentucky", "Delaware Fightin' Blue Hens": "Delaware",
                // MAC
                "Akron Zips": "Akron", "Ball State Cardinals": "Ball State", "Bowling Green Falcons": "Bowling Green", "Buffalo Bulls": "Buffalo", "Central Michigan Chippewas": "Central Michigan", "Eastern Michigan Eagles": "Eastern Michigan", "Kent State Golden Flashes": "Kent State", "Miami (OH) RedHawks": "Miami (OH)", "Northern Illinois Huskies": "Northern Illinois", "Ohio Bobcats": "Ohio", "Toledo Rockets": "Toledo", "Western Michigan Broncos": "Western Michigan",
                // Mountain West
                "Air Force Falcons": "Air Force", "Boise State Broncos": "Boise State", "Colorado State Rams": "Colorado State", "Fresno State Bulldogs": "Fresno State", "Hawaii Rainbow Warriors": "Hawai'i", "Nevada Wolf Pack": "Nevada", "New Mexico Lobos": "New Mexico", "San Diego State Aztecs": "San Diego State", "San Jose State Spartans": "San Jos√© State", "UNLV Rebels": "UNLV", "Utah State Aggies": "Utah State", "Wyoming Cowboys": "Wyoming", "Oregon State Beavers": "Oregon State", "Washington State Cougars": "Washington State",
                // Sun Belt
                "Appalachian State Mountaineers": "Appalachian State", "Arkansas State Red Wolves": "Arkansas State", "Coastal Carolina Chanticleers": "Coastal Carolina", "Georgia Southern Eagles": "Georgia Southern", "Georgia State Panthers": "Georgia State", "James Madison Dukes": "James Madison", "Louisiana Ragin' Cajuns": "Louisiana", "UL Monroe Warhawks": "UL Monroe", "Marshall Thundering Herd": "Marshall", "Old Dominion Monarchs": "Old Dominion", "South Alabama Jaguars": "South Alabama", "Southern Miss Golden Eagles": "Southern Miss", "Texas State Bobcats": "Texas State", "Troy Trojans": "Troy",
                // Independents
                "Notre Dame Fighting Irish": "Notre Dame", "UConn Huskies": "Connecticut", "UMass Minutemen": "UMass",
            };

            const fcsTeams = {
                // --- FCS Teams ---
                "Chattanooga Mocs": "Chattanooga", "Eastern Kentucky Colonels": "Eastern Kentucky", "Furman Paladins": "Furman", "Holy Cross Crusaders": "Holy Cross", "Idaho State Bengals": "Idaho State", "Illinois State Redbirds": "Illinois State", "Incarnate Word Cardinals": "Incarnate Word", "Mercer Bears": "Mercer", "Montana Grizzlies": "Montana", "Montana State Bobcats": "Montana State", "North Dakota Fighting Hawks": "North Dakota", "North Dakota State Bison": "North Dakota State", "Northern Iowa Panthers": "Northern Iowa", "Sacramento State Hornets": "Sacramento State", "Samford Bulldogs": "Samford", "South Dakota Coyotes": "South Dakota", "South Dakota State Jackrabbits": "South Dakota State", "Southern Illinois Salukis": "Southern Illinois", "UC Davis Aggies": "UC Davis", "Villanova Wildcats": "Villanova", "Weber State Wildcats": "Weber State", "William & Mary Tribe": "William & Mary",
            };

            async function cfbApiFetch(url) {
                const headers = { 'Authorization': `Bearer ${cfbDataApiKey}` };
                try {
                    const response = await fetch(url, { headers });
                    if (!response.ok) {
                        throw new Error(`API request failed for ${url} with status: ${response.status}`);
                    }
                    const text = await response.text();
                    try {
                        return JSON.parse(text);
                    } catch (e) {
                        console.error(`API response for ${url} was not valid JSON.`);
                        throw new Error('The College Football Data API returned an invalid response. Please check your API key and the API status.');
                    }
                } catch (error) {
                    console.error(`Fetch error for ${url}:`, error.message);
                    throw error;
                }
            }

            async function fetchTeamData(teamName) {
                const aliasedTeamName = teamNameAliases[teamName] || teamName;
                const previousYear = new Date().getFullYear() - 1;
                
                const teamRecordData = recordsCache[previousYear]?.[aliasedTeamName];
                const record = teamRecordData ? `${teamRecordData.total.wins}-${teamRecordData.total.losses}` : 'N/A';
                
                const returningProduction = returningProductionCache[aliasedTeamName];
                const talentScore = talentCache[aliasedTeamName]?.talent || 'N/A';

                return {
                    name: aliasedTeamName,
                    record,
                    returningProduction,
                    talentScore
                };
            }
            
            async function fetchAdvancedSeasonStats(teamName, year) {
                return advancedStatsCache[year]?.[teamName] || null;
            }
            
            async function fetchHeadToHead(team1, team2) {
                const url = `https://api.collegefootballdata.com/teams/matchup?team1=${encodeURIComponent(team1)}&team2=${encodeURIComponent(team2)}`;
                return await cfbApiFetch(url);
            }

            async function fetchSPRatings(team, year) {
                return spCache[year]?.[team] || null;
            }

            async function fetchInjuries(team) {
                if (injuriesCache[team]) return injuriesCache[team];
                
                const previousYear = new Date().getFullYear() - 1;
                const url = `https://api.collegefootballdata.com/injuries?year=${previousYear}&team=${encodeURIComponent(team)}`;
                const data = await cfbApiFetch(url);
                injuriesCache[team] = data;
                return data;
            }

            async function fetchKeyReturningPlayers(teamName, year) {
                const cacheKey = `${teamName}-${year}`;
                if (keyPlayersCache[cacheKey]) return keyPlayersCache[cacheKey];

                const url = `https://api.collegefootballdata.com/awards?year=${year}&team=${encodeURIComponent(teamName)}`;
                const data = await cfbApiFetch(url);
                if (!data || data.length === 0) {
                    keyPlayersCache[cacheKey] = 'None';
                    return 'None';
                }
                
                const keyAwards = [ "Walter Camp", "FWAA", "AP", "Sporting News", "AFCA", "Heisman", "Maxwell", "Davey O'Brien", "Doak Walker", "Biletnikoff", "John Mackey", "Rimington", "Outland", "Nagurski", "Bednarik", "Jim Thorpe", "Lou Groza", "Ray Guy" ];
                const keyPlayers = data
                    .filter(award => keyAwards.some(keyAward => award.name.includes(keyAward)))
                    .map(award => `${award.recipient} (${award.name})`);

                const uniquePlayers = [...new Set(keyPlayers)];
                const result = uniquePlayers.length > 0 ? uniquePlayers.join(', ') : 'None';
                keyPlayersCache[cacheKey] = result;
                return result;
            }

            async function fetchGameNews(query) {
                let allArticles = [];
                const numPages = 2; // Reduced from 5 to 2 for efficiency
            
                try {
                    for (let i = 0; i < numPages; i++) {
                        const start = i * 10 + 1;
                        const apiUrl = `https://www.googleapis.com/customsearch/v1?key=${googleApiKey}&cx=${googleCx}&q=${encodeURIComponent(query)}&start=${start}`;
                        
                        const response = await fetch(apiUrl);
                        if (!response.ok) {
                            console.error(`Google Search API error on page ${i+1}! Status: ${response.status}`);
                            break; 
                        }
                        
                        const data = await response.json();
                        if (data.items && data.items.length > 0) {
                            const articles = data.items.map(item => ({
                                title: item.title,
                                link: item.link,
                                snippet: item.snippet
                            }));
                            allArticles = allArticles.concat(articles);
                        } else {
                            break;
                        }
                        await sleep(250); // Pause between news fetches
                    }
                    return allArticles;
                } catch (error) {
                    console.error('Error fetching game news:', error);
                    return [];
                }
            }
            
            async function summarizeNews(articles, homeTeam, awayTeam) {
                if (!articles || articles.length === 0) {
                    return "No recent news found for this matchup.";
                }

                const snippets = articles.map(a => `Title: ${a.title}\nSnippet: ${a.snippet}`).join('\n---\n');

                const prompt = `
You are a sports news analyst. Your task is to read the following collection of news article snippets about an upcoming game between ${homeTeam} and ${awayTeam} and synthesize them into a concise, structured summary.

**Instructions:**
1.  Identify the 2-3 most important themes or narratives emerging from the news (e.g., a key player's performance, a specific positional battle, coaching changes).
2.  List any specific player status updates, such as injuries, suspensions, or players returning. If none are mentioned, state that.
3.  Determine the overall sentiment (Positive, Negative, or Neutral) for each team based on the provided text.

**Format your response exactly as follows using Markdown:**

### News & Narrative Summary
-   **Key Narratives:**
    -   [Narrative 1]
    -   [Narrative 2]
-   **Player Status Updates:**
    -   **${homeTeam}:** [List any updates or "None mentioned"]
    -   **${awayTeam}:** [List any updates or "None mentioned"]
-   **Team Sentiment:**
    -   **${homeTeam}:** [Positive/Negative/Neutral]
    -   **${awayTeam}:** [Positive/Negative/Neutral]

**Article Snippets to Analyze:**
${snippets}
`;

                return await generateNarrative(prompt);
            }
            
            async function fetchCurrentWeek() {
                const currentYear = new Date().getFullYear();
                const url = `https://api.collegefootballdata.com/calendar?year=${currentYear}`;
                const calendar = await cfbApiFetch(url);
                if (!calendar) return 1; // Default to week 1 if API fails

                const now = new Date();
                for (const weekData of calendar) {
                    const startDate = new Date(weekData.firstGameStart);
                    const endDate = new Date(weekData.lastGameStart);
                    // Extend end date by a day to make sure we're in the right week
                    endDate.setDate(endDate.getDate() + 1);

                    if (now >= startDate && now <= endDate) {
                        return weekData.week;
                    }
                }
                // If no current week is found (e.g., offseason), default to week 1
                return 1;
            }
            
            async function generateNarrative(prompt, retries = 3, delay = 1000) {
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-0514:generateContent?key=${geminiApiKey}`;

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                    });
                    
                    if (!response.ok) {
                        if (response.status === 403) {
                             const errorBody = await response.json();
                             console.error('Gemini API Error Response (403):', errorBody);
                             throw new Error(`AI generation failed with a 403 Forbidden error. Check Gemini API key permissions.`);
                        }
                        if (response.status >= 500 && retries > 0) {
                            await new Promise(res => setTimeout(res, delay));
                            return generateNarrative(prompt, retries - 1, delay * 2);
                        }
                        const errorBody = await response.json();
                        throw new Error(`AI generation failed. Status: ${response.status}`);
                    }

                    const result = await response.json();
                    
                    if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0]) {
                        return result.candidates[0].content.parts[0].text;
                    } else {
                        if(retries > 0) {
                            await new Promise(res => setTimeout(res, delay));
                            return generateNarrative(prompt, retries - 1, delay * 2);
                        }
                        throw new Error("Could not parse the AI's response.");
                    }
                } catch (error) {
                    if (error instanceof TypeError && retries > 0) {
                         await new Promise(res => setTimeout(res, delay));
                         return generateNarrative(prompt, retries - 1, delay * 2);
                    }
                    throw error;
                }
            }


            // --- UI Rendering ---

            function displayGames(games, teamData) {
                gamesList.innerHTML = '';
                gamesList.className = 'space-y-8';

                const fbsTeamSet = new Set(Object.keys(teamNameAliases));
                const allGamesProcessed = games.map(game => {
                    const homeTeam = game.home_team;
                    const awayTeam = game.away_team;
                    if (!fbsTeamSet.has(homeTeam) || !fbsTeamSet.has(awayTeam)) return null;

                    const bookmaker = game.bookmakers.find(b => b.key === 'draftkings' || b.key === 'fanduel') || game.bookmakers[0];
                    const spreadMarket = bookmaker.markets.find(m => m.key === 'spreads');
                    if (!spreadMarket) return null;

                    const homeOutcome = spreadMarket.outcomes.find(o => o.name === homeTeam);
                    const awayOutcome = spreadMarket.outcomes.find(o => o.name === awayTeam);
                    if (!homeOutcome || !awayOutcome) return null;
                    
                    const absoluteSpread = Math.abs(homeOutcome.point);
                    const spreadDisplay = `${homeOutcome.name} ${homeOutcome.point > 0 ? '+' : ''}${homeOutcome.point}`;
                    
                    const homeTeamAlias = teamNameAliases[game.home_team];
                    const awayTeamAlias = teamNameAliases[game.away_team];
                    const homeTalent = talentCache[homeTeamAlias]?.talent || 0;
                    const awayTalent = talentCache[awayTeamAlias]?.talent || 0;

                    return { ...game, absoluteSpread, spreadDisplay, homeTalent, awayTalent };
                }).filter(Boolean);


                const majorConferenceTeams = new Set([
                    // SEC
                    "Alabama", "Arkansas", "Auburn", "Florida", "Georgia", "Kentucky", "LSU", "Mississippi State", "Missouri", "Oklahoma", "Mississippi", "South Carolina", "Tennessee", "Texas A&M", "Texas", "Vanderbilt",
                    // Big Ten
                    "Illinois", "Indiana", "Iowa", "Maryland", "Michigan State", "Michigan", "Minnesota", "Nebraska", "Northwestern", "Ohio State", "Oregon", "Penn State", "Purdue", "Rutgers", "UCLA", "USC", "Washington", "Wisconsin",
                    // Big 12
                    "Arizona State", "Arizona", "Baylor", "BYU", "Cincinnati", "Colorado", "Houston", "Iowa State", "Kansas", "Kansas State", "Oklahoma State", "TCU", "Texas Tech", "UCF", "Utah", "West Virginia",
                    // ACC
                    "Boston College", "California", "Clemson", "Duke", "Florida State", "Georgia Tech", "Louisville", "Miami", "NC State", "North Carolina", "Pittsburgh", "SMU", "Stanford", "Syracuse", "Virginia", "Virginia Tech", "Wake Forest"
                ]);

                const majorConferenceGames = allGamesProcessed.filter(game => {
                    const homeTeamAlias = teamNameAliases[game.home_team];
                    const awayTeamAlias = teamNameAliases[game.away_team];
                    return majorConferenceTeams.has(homeTeamAlias) && majorConferenceTeams.has(awayTeamAlias);
                });

                if (majorConferenceGames.length > 0) {
                    const featuredGame = [...majorConferenceGames].sort((a, b) => {
                        if (a.absoluteSpread !== b.absoluteSpread) {
                            return a.absoluteSpread - b.absoluteSpread;
                        }
                        const aCombinedTalent = a.homeTalent + a.awayTalent;
                        const bCombinedTalent = b.homeTalent + b.awayTalent;
                        return bCombinedTalent - aCombinedTalent;
                    })[0];
                    displayFeaturedGame(featuredGame, teamData);
                }


                const gamesByDate = allGamesProcessed.reduce((acc, game) => {
                    const gameDate = new Date(game.commence_time);
                    const dateKey = gameDate.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });

                    if (!acc[dateKey]) {
                        acc[dateKey] = [];
                    }
                    acc[dateKey].push(game);
                    return acc;
                }, {});

                const sortedDates = Object.keys(gamesByDate).sort((a, b) => new Date(a) - new Date(b));

                if (sortedDates.length === 0) {
                    showError("No upcoming FBS vs. FBS games found with available odds.");
                    return;
                }

                sortedDates.forEach((dateKey, index) => {
                    const gamesForDate = gamesByDate[dateKey];
                    gamesForDate.sort((a, b) => b.absoluteSpread - a.absoluteSpread);

                    const gamesHtml = gamesForDate.map(game => {
                        const homeLogo = teamData[teamNameAliases[game.home_team]] || '';
                        const awayLogo = teamData[teamNameAliases[game.away_team]] || '';
                        
                        const consensusPick = gamePicks.get(`${game.id}_consensus`);
                        const oddsPick = gamePicks.get(`${game.id}_odds`);
                        const noSpreadPick = gamePicks.get(`${game.id}_no-spread`);
                        const finalPick = gamePicks.get(`${game.id}_final`);

                        const hasConsensusAnalysis = savedAnalysesCache.has(`${game.id}_consensus`);
                        const hasOddsAnalysis = savedAnalysesCache.has(`${game.id}_odds`);
                        const hasNoSpreadAnalysis = savedAnalysesCache.has(`${game.id}_no-spread`);
                        const hasFinalAnalysis = savedAnalysesCache.has(`${game.id}_final`);

                        const pickDisplayHtml = (pick, type) => {
                            if (!pick) return '';
                            let label = 'Your Pick:';
                            switch(type) {
                                case 'consensus': label = 'Winner Pick:'; break;
                                case 'odds': label = 'Spread Pick:'; break;
                                case 'no-spread': label = 'Game Pick:'; break;
                                case 'final': label = 'Final Pick:'; break;
                            }
                            return `<div class="text-xs mt-1 ${type === 'final' ? 'text-green-400 font-bold' : 'text-yellow-400'}" data-pick-type="${type}">${label} ${pick.team} (Confidence: ${pick.confidence})</div>`;
                        };
                        
                        const allPicksMade = consensusPick && oddsPick && noSpreadPick;

                        return `
                        <li class="game-item flex flex-col md:flex-row justify-between items-center p-4 rounded-lg hover:bg-gray-700 transition duration-200" data-game-id="${game.id}">
                            <div class="flex flex-col items-start mb-4 md:mb-0 flex-grow">
                                <div class="flex items-center">
                                    <img src="${awayLogo}" alt="${game.away_team}" class="w-8 h-8 mr-3 object-contain">
                                    <span class="font-bold text-lg">${game.away_team}</span>
                                    <span class="mx-2 text-gray-400">@</span>
                                    <img src="${homeLogo}" alt="${game.home_team}" class="w-8 h-8 mr-3 object-contain">
                                    <span class="font-bold text-lg">${game.home_team}</span>
                                </div>
                                <div class="pick-display mt-2 pl-1">
                                    ${pickDisplayHtml(consensusPick, 'consensus')}
                                    ${pickDisplayHtml(oddsPick, 'odds')}
                                    ${pickDisplayHtml(noSpreadPick, 'no-spread')}
                                    ${pickDisplayHtml(finalPick, 'final')}
                                </div>
                            </div>
                            <div class="w-full md:w-auto flex flex-col md:flex-row items-center md:space-x-4">
                               <p class="text-blue-400 font-semibold w-full md:w-auto text-left md:text-right mb-2 md:mb-0">${game.spreadDisplay}</p>
                               <div class="flex w-full md:w-auto space-x-2">
                                    <button data-game-id="${game.id}" data-home-team="${game.home_team}" data-away-team="${game.away_team}" data-spread="${game.spreadDisplay}" data-commence-time="${game.commence_time}" class="analysis-btn flex-1 bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-3 rounded-md transition duration-300 text-sm whitespace-nowrap" data-analysis-type="consensus">${hasConsensusAnalysis ? 'Predict Winner ‚úì' : 'Predict Winner'}</button>
                                    <button data-game-id="${game.id}" data-home-team="${game.home_team}" data-away-team="${game.away_team}" data-spread="${game.spreadDisplay}" data-commence-time="${game.commence_time}" class="analysis-btn flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-3 rounded-md transition duration-300 text-sm whitespace-nowrap" data-analysis-type="odds">${hasOddsAnalysis ? 'Analyze Spread ‚úì' : 'Analyze Spread'}</button>
                                    <button data-game-id="${game.id}" data-home-team="${game.home_team}" data-away-team="${game.away_team}" data-spread="${game.spreadDisplay}" data-commence-time="${game.commence_time}" class="analysis-btn flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-md transition duration-300 text-sm whitespace-nowrap" data-analysis-type="no-spread">${hasNoSpreadAnalysis ? 'Analyze Game ‚úì' : 'Analyze Game'}</button>
                                    <button data-game-id="${game.id}" data-home-team="${game.home_team}" data-away-team="${game.away_team}" class="final-analysis-btn flex-1 bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-3 rounded-md transition duration-300 text-sm whitespace-nowrap ${allPicksMade ? '' : 'hidden'}" data-analysis-type="final">${hasFinalAnalysis ? 'Final Analysis ‚úì' : 'Final Analysis'}</button>
                                </div>
                            </div>
                        </li>
                    `}).join('');

                    const dateCard = document.createElement('div');
                    dateCard.className = 'bg-gray-800 rounded-lg shadow-lg overflow-hidden card-enter';
                    dateCard.innerHTML = `
                        <div class="bg-gray-700 p-4 border-b border-gray-600">
                            <h2 class="text-2xl font-bold text-white">${dateKey}</h2>
                        </div>
                        <ul class="divide-y divide-gray-600">
                            ${gamesHtml}
                        </ul>
                    `;
                    gamesList.appendChild(dateCard);
                    setTimeout(() => dateCard.classList.add('card-enter-active'), index * 100);
                });
            }

            function displayFeaturedGame(game, teamData) {
                const homeLogo = teamData[teamNameAliases[game.home_team]] || '';
                const awayLogo = teamData[teamNameAliases[game.away_team]] || '';
                const gameTime = new Date(game.commence_time).toLocaleTimeString('en-US', { timeStyle: 'short' });

                featuredGameContainer.innerHTML = `
                    <div class="bg-gray-800 rounded-lg shadow-lg p-6 border-2 border-yellow-400">
                        <h2 class="text-2xl font-bold text-center mb-4 text-yellow-300">Featured Game of the Week</h2>
                        <div class="flex justify-around items-center text-center">
                            <div class="flex flex-col items-center">
                                <img src="${awayLogo}" alt="${game.away_team}" class="w-20 h-20 mb-2 object-contain">
                                <p class="text-xl font-semibold">${game.away_team}</p>
                            </div>
                            <div class="text-center">
                                <p class="text-4xl font-bold text-gray-400">VS</p>
                                <p class="text-lg text-blue-400 mt-2">${game.spreadDisplay}</p>
                                <p class="text-sm text-gray-400">${gameTime}</p>
                            </div>
                            <div class="flex flex-col items-center">
                                <img src="${homeLogo}" alt="${game.home_team}" class="w-20 h-20 mb-2 object-contain">
                                <p class="text-xl font-semibold">${game.home_team}</p>
                            </div>
                        </div>
                    </div>
                `;
            }

            function showModalLoadingState(details) {
                const analysisTypeDisplay = details.analysisType ? `<div class="text-center mb-4">
                    <span class="bg-gray-700 text-gray-300 text-sm font-semibold px-3 py-1 rounded-full uppercase tracking-wider">${details.analysisType.replace('-', ' ')}</span>
                </div>` : '';
                
                modalFooter.innerHTML = ''; // Clear footer
                narrativeModalContent.innerHTML = `
                    <h2 class="text-3xl font-bold mb-2 text-center">${details.awayTeam} vs. ${details.homeTeam}</h2>
                    ${analysisTypeDisplay}
                    <div class="flex flex-col items-center justify-center my-16">
                        <div class="loader"></div>
                        <p id="modalStatusText" class="mt-4 text-lg text-gray-300">Initializing...</p>
                    </div>
                `;
            }

            function updateModalStatus(message) {
                const statusTextElement = document.getElementById('modalStatusText');
                if (statusTextElement) {
                    statusTextElement.textContent = message;
                }
            }
            
            function displayNarrative(narrative, gameDetails, rawData, isSpreadAnalysis, analysisTitle, prompt) {
                currentNarrativeText = narrative;
                const formattedNarrative = marked.parse(narrative);

                const gameDateTime = new Date(gameDetails.commenceTime).toLocaleString('en-US', { dateStyle: 'full', timeStyle: 'short' });
                const spreadDisplay = isSpreadAnalysis 
                    ? `<p class="text-blue-400 text-center font-semibold mb-6">${gameDetails.spread}</p>`
                    : '<div class="mb-6"></div>';
                const analysisTypeDisplay = analysisTitle ? `<div class="text-center mb-4">
                    <span class="bg-gray-700 text-gray-300 text-sm font-semibold px-3 py-1 rounded-full uppercase tracking-wider">${analysisTitle}</span>
                </div>` : '';
                
                let individualAnalysesHtml = '';
                if (rawData.individualAnalyses) {
                    const analysisItems = rawData.individualAnalyses.map((analysis, index) => `
                        <div class="mb-4 border-b border-gray-700 pb-4 last:border-b-0 last:pb-0">
                            <h5 class="font-bold text-md mb-2 text-gray-400">Analyst Report ${index + 1}</h5>
                            <div class="prose prose-sm prose-invert max-w-none text-gray-400">${marked.parse(analysis)}</div>
                        </div>
                    `).join('');

                    individualAnalysesHtml = `
                    <div class="mt-4 border-t border-gray-600 pt-4">
                        <button class="accordion-toggle w-full text-left text-lg font-semibold text-gray-300 hover:text-white focus:outline-none">
                           <span class="accordion-arrow transform transition-transform duration-300 inline-block mr-2">‚ñ∂</span> View Individual Analyst Reports
                        </button>
                        <div class="accordion-content bg-gray-900 rounded-md">
                            ${analysisItems}
                        </div>
                    </div>`;
                }


                let newsAccordionHtml = '';
                if (rawData.newsArticles && rawData.newsArticles.length > 0) {
                    const newsItems = rawData.newsArticles.map(article => `
                        <li class="mb-3 pb-3 border-b border-gray-700 last:border-b-0 last:mb-0 last:pb-0">
                            <a href="${article.link}" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:underline font-semibold">${article.title}</a>
                            <p class="text-sm text-gray-400 mt-1">${article.snippet}</p>
                        </li>
                    `).join('');

                    newsAccordionHtml = `
                        <div class="mt-4 border-t border-gray-600 pt-4">
                            <button class="accordion-toggle w-full text-left text-lg font-semibold text-gray-300 hover:text-white focus:outline-none">
                               <span class="accordion-arrow transform transition-transform duration-300 inline-block mr-2">‚ñ∂</span> View News Articles
                            </button>
                            <div class="accordion-content bg-gray-900 rounded-md">
                                <ul class="list-none">
                                    ${newsItems}
                                </ul>
                            </div>
                        </div>`;
                }

                let promptAccordionHtml = '';
                if (prompt && !prompt.includes('not available')) {
                    promptAccordionHtml = `
                    <div class="mt-8 border-t border-gray-600 pt-4">
                        <button class="accordion-toggle w-full text-left text-lg font-semibold text-gray-300 hover:text-white focus:outline-none">
                           <span class="accordion-arrow transform transition-transform duration-300 inline-block mr-2">‚ñ∂</span> View Prompt Sent to AI
                        </button>
                        <div class="accordion-content bg-gray-900 rounded-md">
                            <pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">${prompt}</pre>
                        </div>
                    </div>`;
                }

                let rawDataAccordionHtml = '';
                if (rawData && rawData.homeData) {
                    rawDataAccordionHtml = `
                    <div class="mt-4 border-t border-gray-600 pt-4">
                        <button class="accordion-toggle w-full text-left text-lg font-semibold text-gray-300 hover:text-white focus:outline-none">
                           <span class="accordion-arrow transform transition-transform duration-300 inline-block mr-2">‚ñ∂</span> View Raw API Data
                        </button>
                        <div class="accordion-content bg-gray-900 rounded-md">
                            <h4 class="font-bold text-md mb-2 text-gray-400">Team Overview Data (Home: ${rawData.homeData.name})</h4>
                            <pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">${JSON.stringify(rawData.homeData, null, 2)}</pre>
                            <h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Team Overview Data (Away: ${rawData.awayData.name})</h4>
                            <pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">${JSON.stringify(rawData.awayData, null, 2)}</pre>
                            <h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Key Returning Players (Previous Year Honors)</h4>
                            <pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">Home: ${rawData.homeKeyPlayers}\nAway: ${rawData.awayKeyPlayers}</pre>
                            <h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Current Year Record (Home)</h4>
                            <pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">${JSON.stringify(rawData.homeRecordCurrent, null, 2)}</pre>
                             <h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Current Year Record (Away)</h4>
                            <pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">${JSON.stringify(rawData.awayRecordCurrent, null, 2)}</pre>
                            <h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Head to Head</h4>
                            <pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">${JSON.stringify(rawData.headToHead, null, 2)}</pre>
                            <h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Current Year SP+ Ratings</h4>
                            <pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">Home: ${JSON.stringify(rawData.homeSP, null, 2)}\nAway: ${JSON.stringify(rawData.awaySP, null, 2)}</pre>
                            <h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Previous Year SP+ Ratings</h4>
                            <pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">Home: ${JSON.stringify(rawData.homeSPPrev, null, 2)}\nAway: ${JSON.stringify(rawData.awaySPPrev, null, 2)}</pre>
                            <h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Advanced Season Stats (Previous Year)</h4>
                            <pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">Home: ${JSON.stringify(rawData.homeStatsPrev, null, 2)}\nAway: ${JSON.stringify(rawData.awayStatsPrev, null, 2)}</pre>
                            <h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Advanced Season Stats (Current Year)</h4>
                            <pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">Home: ${JSON.stringify(rawData.homeStatsCurrent, null, 2)}\nAway: ${JSON.stringify(rawData.awayStatsCurrent, null, 2)}</pre>
                            <h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Injuries</h4>
                            <pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">Home: ${JSON.stringify(rawData.homeInjuries, null, 2)}\nAway: ${JSON.stringify(rawData.awayInjuries, null, 2)}</pre>
                        </div>
                    </div>`;
                }

                narrativeModalContent.innerHTML = `
                    <h2 class="text-3xl font-bold mb-2 text-center">${gameDetails.awayTeam} vs. ${gameDetails.homeTeam}</h2>
                    <p class="text-center text-gray-400 text-sm mb-2">${gameDateTime}</p>
                    ${spreadDisplay}
                    ${analysisTypeDisplay}
                    <div class="prose prose-invert max-w-none text-gray-300">
                        ${formattedNarrative}
                    </div>
                    ${individualAnalysesHtml}
                    ${promptAccordionHtml}
                    ${rawDataAccordionHtml}
                    ${newsAccordionHtml}
                `;

                // Add Save Pick UI to the footer
                modalFooter.innerHTML = `
                    <div id="save-pick-section" class="flex items-center space-x-4">
                        <span class="font-bold text-lg">Your Pick:</span>
                        <button class="pick-btn bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-md border-2 border-transparent transition" data-team-name="${gameDetails.awayTeam}">${gameDetails.awayTeam}</button>
                        <button class="pick-btn bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-md border-2 border-transparent transition" data-team-name="${gameDetails.homeTeam}">${gameDetails.homeTeam}</button>
                        <select id="pick-confidence" class="bg-gray-600 text-white p-2 rounded-md focus:outline-none focus:ring-2 focus:ring-yellow-500">
                            <option value="Low">Low Confidence</option>
                            <option value="Medium">Medium Confidence</option>
                            <option value="High">High Confidence</option>
                            <option value="Very High">Very High Confidence</option>
                        </select>
                        <button id="save-pick-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition">Save Pick</button>
                    </div>
                `;

                // Add event listeners for the new pick UI
                const pickButtons = modalFooter.querySelectorAll('.pick-btn');
                pickButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        pickButtons.forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                    });
                });

                document.getElementById('save-pick-btn').addEventListener('click', () => {
                    handleSavePick(gameDetails.gameId, gameDetails.analysisType);
                });


                narrativeModal.classList.remove('hidden');

                // Generic Accordion logic for all toggles
                document.querySelectorAll('.accordion-toggle').forEach(button => {
                    button.addEventListener('click', () => {
                        const content = button.nextElementSibling;
                        const arrow = button.querySelector('.accordion-arrow');
                        const isExpanded = content.style.maxHeight && content.style.maxHeight !== '0px';

                        if (isExpanded) {
                            content.style.maxHeight = '0px';
                            content.style.paddingTop = null;
                            content.style.paddingBottom = null;
                            content.style.marginTop = null;
                            arrow.style.transform = 'rotate(0deg)';
                        } else {
                            content.style.paddingTop = '1rem';
                            content.style.paddingBottom = '1rem';
                            content.style.marginTop = '0.5rem';
                            content.style.maxHeight = content.scrollHeight + 'px';
                            arrow.style.transform = 'rotate(90deg)';
                        }
                    });
                });
            }

            function showLoader(isLoading, message = "Loading...") {
                mainLoaderText.textContent = message;
                mainLoader.classList.toggle('hidden', !isLoading);
            }

            function showError(message) {
                errorMessage.textContent = message;
                errorDisplay.classList.remove('hidden');
            }

            function clearError() {
                errorDisplay.classList.add('hidden');
            }
            
            function buildPrompt(gameDetails, homeData, awayData, 
                                 homeStatsPrev, awayStatsPrev, homeStatsCurrent, awayStatsCurrent,
                                 headToHead, homeSP, awaySP, homeSPPrev, awaySPPrev, 
                                 homeInjuries, awayInjuries, analysisType, homeRecordCurrent, awayRecordCurrent,
                                 homeKeyPlayers, awayKeyPlayers, currentWeek) {
                                 
                const { gameDateTime, spread, newsSummary } = gameDetails;
                const currentYear = new Date().getFullYear();
                const previousYear = currentYear - 1;

                let seasonalWeightingInstructions = '';
                if (currentWeek < 5) {
                    seasonalWeightingInstructions = `**SEASONAL ANALYSIS DIRECTIVE: EARLY SEASON (Current Week: ${currentWeek})**
-   **Primary Weighting:** Heavily weigh previous-year data (${previousYear}), pre-season SP+ ratings, and returning production percentages. These are the most reliable indicators of team quality at this stage.
-   **Cautious Weighting:** Use current-season data (${currentYear}) with extreme caution due to small sample sizes. Look for significant deviations from pre-season expectations but do not overreact to stats from one or two games, especially against mismatched competition.
-   **Focus:** Identify if teams are meeting, exceeding, or falling short of their pre-season projections based on the limited data available.`;
                } else {
                    seasonalWeightingInstructions = `**SEASONAL ANALYSIS DIRECTIVE: MID-SEASON (Current Week: ${currentWeek})**
-   **Primary Weighting:** Shift focus to current-season data (${currentYear}). Performance metrics over several games are now more indicative of team quality than pre-season projections.
-   **Secondary Weighting:** Use previous-year data (${previousYear}) and pre-season SP+ ratings as context to understand a team's baseline talent and coaching, but prioritize what they have demonstrated on the field this year.
-   **Focus:** Analyze established trends, statistical strengths and weaknesses from the current season, and how teams have performed against comparable opponents.`;
                }

                const confidenceRubric = `
Provide a confidence score based on the following rubric:
- **Low**: Key data points are highly conflicting, making the outcome a statistical coin flip.
- **Medium**: Data shows a discernible advantage for one team, but the opponent has significant strengths that could counter it.
- **High**: Data shows a clear and consistent advantage for one team across most important categories.
- **Very High**: Data indicates a significant mismatch in nearly every critical metric.`;

                const formatInjuries = (injuries) => {
                    if (!injuries || injuries.length === 0) return 'None reported.';
                    return injuries.map(i => `${i.firstName} ${i.lastName} (${i.position}) - ${i.status}`).join(', ');
                };

                const formatHeadToHead = (h2h) => {
                    if (!h2h || h2h.length === 0) return 'No recent meetings.';
                    return h2h.map(g => `${g.season}: ${g.homeTeam} ${g.homeScore}-${g.awayScore} ${g.awayTeam}`).join('\n    - ');
                };
                
                const createStatsBlock = (stats, teamName) => {
                    if (!stats) return '';
                    return `
-   **${teamName}:**
    -   **Offense Breakdown:**
        - Overall: PPA: ${stats.offense?.ppa?.toFixed(2) || 'N/A'} | Success: ${(stats.offense?.successRate * 100).toFixed(1) || 'N/A'}% | Explosiveness: ${stats.offense?.explosiveness?.toFixed(2) || 'N/A'}
        - Rushing: PPA: ${stats.offense?.rushingPlays?.ppa?.toFixed(2) || 'N/A'} | Success: ${(stats.offense?.rushingPlays?.successRate * 100).toFixed(1) || 'N/A'}% | Explosiveness: ${stats.offense?.rushingPlays?.explosiveness?.toFixed(2) || 'N/A'}
        - Passing: PPA: ${stats.offense?.passingPlays?.ppa?.toFixed(2) || 'N/A'} | Success: ${(stats.offense?.passingPlays?.successRate * 100).toFixed(1) || 'N/A'}% | Explosiveness: ${stats.offense?.passingPlays?.explosiveness?.toFixed(2) || 'N/A'}
    -   **Defense Breakdown:**
        - Overall: PPA: ${stats.defense?.ppa?.toFixed(2) || 'N/A'} | Success: ${(stats.defense?.successRate * 100).toFixed(1) || 'N/A'}% | Havoc (Total): ${(stats.defense?.havoc?.total * 100).toFixed(1) || 'N/A'}%
        - Vs. Rush: PPA: ${stats.defense?.rushingPlays?.ppa?.toFixed(2) || 'N/A'} | Success: ${(stats.defense?.rushingPlays?.successRate * 100).toFixed(1) || 'N/A'}% | Stuff Rate: ${(stats.defense?.stuffRate * 100).toFixed(1) || 'N/A'}%
        - Vs. Pass: PPA: ${stats.defense?.passingPlays?.ppa?.toFixed(2) || 'N/A'} | Success: ${(stats.defense?.passingPlays?.successRate * 100).toFixed(1) || 'N/A'}% | DB Havoc: ${(stats.defense?.havoc?.db * 100).toFixed(1) || 'N/A'}%
        - Havoc Breakdown: Front Seven: ${(stats.defense?.havoc?.frontSeven * 100).toFixed(1) || 'N/A'}% | DBs: ${(stats.defense?.havoc?.db * 100).toFixed(1) || 'N/A'}%
    -   **Line of Scrimmage & Explosiveness:**
        - Off. Line Yards: ${stats.offense?.lineYards?.toFixed(2) || 'N/A'} | Second Level Yards: ${stats.offense?.secondLevelYards?.toFixed(2) || 'N/A'} | Open Field Yards: ${stats.offense?.openFieldYards?.toFixed(2) || 'N/A'}
        - Def. Line Yards Allowed: ${stats.defense?.lineYards?.toFixed(2) || 'N/A'} | Second Level Yards Allowed: ${stats.defense?.secondLevelYards?.toFixed(2) || 'N/A'} | Open Field Yards Allowed: ${stats.defense?.openFieldYards?.toFixed(2) || 'N/A'}
    -   **Situational & Efficiency:**
        - Passing Downs Success: ${(stats.offense?.passingDowns?.successRate * 100).toFixed(1) || 'N/A'}% | Standard Downs Success: ${(stats.offense?.standardDowns?.successRate * 100).toFixed(1) || 'N/A'}%
        - Power Success: ${(stats.offense?.powerSuccess * 100).toFixed(1) || 'N/A'}% | Points Per Opportunity: ${stats.offense?.pointsPerOpportunity?.toFixed(2) || 'N/A'}
        - Avg. Field Position: ${stats.offense?.fieldPosition?.averageStart?.toFixed(1) || 'N/A'}`;
                };

                const homeStatsPrevBlock = createStatsBlock(homeStatsPrev, homeData.name);
                const awayStatsPrevBlock = createStatsBlock(awayStatsPrev, awayData.name);
                const homeStatsCurrentBlock = createStatsBlock(homeStatsCurrent, homeData.name);
                const awayStatsCurrentBlock = createStatsBlock(awayStatsCurrent, awayData.name);

                let previousSeasonStatsSection = '';
                if (homeStatsPrevBlock || awayStatsPrevBlock) {
                    previousSeasonStatsSection = `
**ADVANCED STATS (PREVIOUS SEASON - ${previousYear}):**
${homeStatsPrevBlock}${awayStatsPrevBlock}`;
                }

                let currentSeasonStatsSection = '';
                if (homeStatsCurrentBlock || awayStatsCurrentBlock) {
                    currentSeasonStatsSection = `
**ADVANCED STATS (CURRENT SEASON - ${currentYear}):**
${homeStatsCurrentBlock}${awayStatsCurrentBlock}`;
                }

                let currentSeasonRecordSection = '';
                const homeRec = homeRecordCurrent;
                const awayRec = awayRecordCurrent;
                if (homeRec || awayRec) {
                    currentSeasonRecordSection = `
**CURRENT SEASON DATA (${currentYear}):**
-   **${homeData.name} Record:** ${homeRec ? `${homeRec.total.wins}-${homeRec.total.losses}` : 'N/A'}
-   **${awayData.name} Record:** ${awayRec ? `${awayRec.total.wins}-${awayRec.total.losses}` : 'N/A'}`;
                }

                let currentSPSection = '';
                if (homeSP?.rating && awaySP?.rating) {
                    currentSPSection = `
-   **SP+ Ratings (${currentYear} PRE-SEASON):**
    -   **${homeData.name}:** ${homeSP.rating?.toFixed(1)} (Overall), ${homeSP.offense?.rating?.toFixed(1)} (Off), ${homeSP.defense?.rating?.toFixed(1)} (Def), ${homeSP.specialTeams?.rating?.toFixed(1)} (ST)
    -   **${awayData.name}:** ${awaySP.rating?.toFixed(1)} (Overall), ${awaySP.offense?.rating?.toFixed(1)} (Off), ${awaySP.defense?.rating?.toFixed(1)} (Def), ${awaySP.specialTeams?.rating?.toFixed(1)} (ST)`;
                }
                
                let previousSPSection = '';
                if (homeSPPrev?.rating && awaySPPrev?.rating) {
                    previousSPSection = `
-   **SP+ Ratings (${previousYear} FINAL):**
    -   **${homeData.name}:** ${homeSPPrev.rating?.toFixed(1)} (Overall), ${homeSPPrev.offense?.rating?.toFixed(1)} (Off), ${homeSPPrev.defense?.rating?.toFixed(1)} (Def), ${homeSPPrev.specialTeams?.rating?.toFixed(1)} (ST)
    -   **${awayData.name}:** ${awaySPPrev.rating?.toFixed(1)} (Overall), ${awaySPPrev.offense?.rating?.toFixed(1)} (Off), ${awaySPPrev.defense?.rating?.toFixed(1)} (Def), ${awaySPPrev.specialTeams?.rating?.toFixed(1)} (ST)`;
                }
                
                const spreadContextLine = analysisType !== 'no-spread' ? `-   **Current Spread:** ${spread}.` : '';
                
                let instructions;
                switch(analysisType) {
                    case 'consensus':
                        instructions = `
### Game Synopsis
Using all the data provided, write a brief, data-driven synopsis of the matchup. Synthesize data on key strengths and weaknesses based on SP+ ratings, advanced stats, and talent.
---
### AI-Powered Prediction
Predict the most likely winner of the game. Weigh all factors: SP+ ratings, advanced stats, talent scores, returning production, head-to-head results, and injuries. Declare a clear winner and justify your prediction with specific data points. 
${confidenceRubric}
`;
                        break;
                    case 'odds':
                        instructions = `
### Pre-Game Narrative
Write a compelling, data-driven pre-game narrative. Weave in pre-season expectations (talent, returning production), SP+ ratings, historical matchups, and any available in-season performance data. Integrate news snippets and injury reports for context.
---
### Analyst's Pick
Perform a deeper analysis to determine which team is more likely to cover the spread. Analyze factors like SP+ vs. Spread, key statistical mismatches (PPA, success rates), and the impact of injuries/news. Clearly state your pick and provide a step-by-step justification referencing the provided data.
${confidenceRubric}
`;
                        break;
                    case 'no-spread':
                        instructions = `
### Pre-Game Narrative
Write a compelling, data-driven pre-game narrative. Weave in pre-season expectations (talent, returning production), SP+ ratings, historical matchups, and any available in-season performance data. Integrate news snippets and injury reports for context.
---
### Analyst's Pick
Perform a deeper analysis to determine the likely winner. Analyze factors like SP+ ratings, key statistical mismatches (PPA, success rates), returning production, talent, and injuries. Clearly state your pick and provide a step-by-step justification referencing the provided data.
${confidenceRubric}
`;
                        break;
                }

                return `
You are an expert college football analyst. Your task is to generate a two-part analysis for the upcoming game using detailed data.
**Format your entire response using Markdown.** This includes using headings, bold/italic text, and lists to structure your analysis for readability.
**Crucially, you must only use the data provided below in your analysis. Do not invent or infer any statistics not present in the data.**
**Use the "Key Returning Players" data to identify elite, game-changing talent that might not be fully captured by team-level stats.**
${seasonalWeightingInstructions}
**DATA DEFINITIONS:**
- **PPA (Predicted Points Added):** Measures points added/prevented vs. average. Higher is better for offense, lower for defense.
- **Success Rate:** Percentage of "successful" plays (gaining 50% of needed yards on 1st down, 70% on 2nd, 100% on 3rd/4th). Higher is better for offense, lower for defense.
- **Explosiveness:** Measures the magnitude of successful plays.
- **Power Success Rate:** Percentage of successful runs on 3rd/4th and short. Measures short-yardage rushing ability.
- **Stuff Rate:** Percentage of runs stopped at or behind the line of scrimmage. Measures defensive line dominance.
- **Havoc Rate:** Percentage of plays where the defense records a TFL, forced fumble, pass breakup, or interception.
- **Points Per Opportunity (PPO):** Average points scored on drives that cross the opponent's 40-yard line.
- **Line Yards:** Avg. rushing yards attributed to the offensive line (0-5 yards past LOS).
- **Second Level Yards:** Avg. rushing yards gained 5-10 yards past the LOS.
- **Open Field Yards:** Avg. rushing yards gained 10+ yards past the LOS. Measures an offense's ability to create explosive "home run" plays.
- **Front Seven Havoc:** Percentage of plays where the defensive line or linebackers record a TFL, forced fumble, or pass breakup. Measures disruption at and behind the line of scrimmage.
- **Avg. Starting Field Position:** The average starting yard line for an offense.
- **SP+ Rating:** A tempo- and opponent-adjusted measure of college football efficiency. It is a predictive measure of future performance.
- **Special Teams SP+ Rating:** The SP+ rating for the team's special teams unit.
- **Total Returning Production (%):** The overall percentage of the team's production returning from the previous season.
**CONTEXTUAL DATA:**
-   **Game Date & Time:** ${gameDateTime}
-   **Matchup:** ${awayData.name} at ${homeData.name}
${spreadContextLine}
-   **AI-Generated News Summary:**
${newsSummary}
-   **Head-to-Head (Last 5 Years):** - ${formatHeadToHead(headToHead)}
${currentSPSection}
${previousSPSection}
-   **Key Injuries:**
    -   **${homeData.name}:** ${formatInjuries(homeInjuries)}
    -   **${awayData.name}:** ${formatInjuries(awayInjuries)}
**PRE-SEASON DATA (Based on ${previousYear} Season):**
-   **${homeData.name}:**
    -   **Record:** ${homeData.record}
    -   **Composite Talent Score (${currentYear}):** ${homeData.talentScore}
    -   **Total Returning Production:** ${(homeData.returningProduction?.percentPPA * 100).toFixed(1) || 'N/A'}%
-   **${awayData.name}:**
    -   **Record:** ${awayData.record}
    -   **Composite Talent Score (${currentYear}):** ${awayData.talentScore}
    -   **Total Returning Production:** ${(awayData.returningProduction?.percentPPA * 100).toFixed(1) || 'N/A'}%
-   **Key Returning Players (${previousYear} Honors):**
    -   **${homeData.name}:** ${homeKeyPlayers}
    -   **${awayData.name}:** ${awayKeyPlayers}
${currentSeasonRecordSection}
${previousSeasonStatsSection}
${currentSeasonStatsSection}
---
${instructions}
`;
            }

            function buildConsensusPrompt(analyses, homeTeam, awayTeam, analysisType) {
                let analysisSection = '';
                analyses.forEach((analysis, index) => {
                    analysisSection += `
---
### Analyst Report ${index + 1}
${analysis}
`;
                });

                let taskDescription;
                switch (analysisType) {
                    case 'odds':
                        taskDescription = 'determine which team is most likely to cover the spread';
                        break;
                    case 'no-spread':
                    case 'consensus':
                    default:
                        taskDescription = 'determine the most likely winner';
                        break;
                }

                return `
You are a lead college football analyst. You have received three independent analyses from your team regarding the upcoming game between ${awayTeam} and ${homeTeam}. Your task is to synthesize these reports into a single, definitive consensus prediction.
**Your instructions are:**
1.  **Review all three analyst reports provided below.**
2.  **Identify the majority opinion.** Based on the reports, ${taskDescription}.
3.  **Synthesize the reasoning.** Combine the key data points and arguments from the reports that support the majority pick.
4.  **Formulate a final confidence score.** Based on the confidence levels expressed in the individual reports and the level of agreement, assign a final consensus confidence score (Low, Medium, High, Very High).
5.  **Write the Consensus Report.** Structure your response using Markdown with the following two sections:
    -   **### Consensus Synopsis:** A brief summary of the matchup, integrating the common themes from the analyst reports.
    -   **### Consensus Prediction:** Clearly state the consensus pick, the final confidence score, and a justification that synthesizes the strongest arguments from the provided analyses.
**Do not introduce any new data or opinions. Your entire response must be based solely on the three analyst reports provided.**
${analysisSection}
`;
            }

            function buildFinalAnalysisPrompt(analyses, userPicks, homeTeam, awayTeam) {
                let analysisSection = '';
                for (const [type, text] of Object.entries(analyses)) {
                    analysisSection += `
---
### ${type.replace('-', ' ')} Analysis
${text}
`;
                }

                let userPicksSection = '';
                for (const [type, pick] of Object.entries(userPicks)) {
                     userPicksSection += `- **${type.replace('-', ' ')} Pick:** ${pick.team} (Confidence: ${pick.confidence})\n`;
                }
                
                return `
You are a master college football analyst. Your task is to synthesize three different AI-generated consensus reports and the user's own saved picks to produce one final, ultimate recommendation for the game between ${awayTeam} and ${homeTeam}.
**Your instructions are:**
1.  **Review the three AI reports:** "Winner Prediction," "Spread Analysis," and "Game Analysis." Note their conclusions and key arguments.
2.  **Review the User's Picks:** Pay close attention to the user's selected team and their confidence level for each of the three analysis types. This represents the user's own judgment after reading the initial reports.
3.  **Synthesize Everything:** Weigh all inputs. If the AI reports and user picks are aligned, your job is to create a confident, summary conclusion. If they conflict, your job is to highlight the disagreement and make a final judgment call, explaining why you are siding with one perspective over the other.
4.  **Formulate a Final Pick and Confidence:** Declare a final pick (either for the winner or to cover the spread, depending on what makes the most sense from the synthesis) and a final confidence score (Low, Medium, High, Very High).
5.  **Write the Final Report:** Structure your response using Markdown with the following two sections:
    -   **### Final Synopsis:** Briefly summarize the different analytical perspectives and the user's inputs.
    -   **### Final Recommendation:** Clearly state your final pick, the final confidence score, and a concise justification for your decision, explaining how you synthesized the provided information.
**You must base your entire response on the provided reports and user picks.**
${analysisSection}
---
### User's Saved Picks
${userPicksSection}
`;
            }

            // --- Event Handling ---
            async function handleAnalysisClick(button) {
                const allButtonsInRow = button.closest('li').querySelectorAll('button');
                allButtonsInRow.forEach(el => { el.disabled = true; });

                const gameId = button.dataset.gameId;
                const homeTeam = button.dataset.homeTeam;
                const awayTeam = button.dataset.awayTeam;
                const spread = button.dataset.spread;
                const commenceTime = button.dataset.commenceTime;
                const analysisType = button.dataset.analysisType;

                let analysisTitle = "Analysis";
                if(analysisType === 'consensus') analysisTitle = 'Winner Prediction';
                if(analysisType === 'odds') analysisTitle = 'Spread Analysis';
                if(analysisType === 'no-spread') analysisTitle = 'Game Analysis';
                
                const savedAnalysis = savedAnalysesCache.get(`${gameId}_${analysisType}`);
                if (savedAnalysis) {
                    const gameDetails = { gameId, homeTeam, awayTeam, spread, commenceTime, analysisType };
                    displayNarrative(savedAnalysis, gameDetails, {}, analysisType === 'odds', analysisTitle, "Prompt not available for saved analysis.");
                    allButtonsInRow.forEach(el => { el.disabled = false; });
                    return;
                }

                showModalLoadingState({ homeTeam, awayTeam, analysisType: analysisTitle });
                narrativeModal.classList.remove('hidden');
                clearError();

                try {
                    const currentYear = new Date().getFullYear();
                    const previousYear = currentYear - 1;
                    
                    updateModalStatus('Fetching current week...');
                    const currentWeek = await fetchCurrentWeek();

                    updateModalStatus('Gathering cached data...');
                    const homeData = await fetchTeamData(homeTeam);
                    const awayData = await fetchTeamData(awayTeam);
                    
                    const [
                        homeRecordCurrent, awayRecordCurrent, headToHeadData, 
                        homeSP, awaySP, homeSPPrev, awaySPPrev, 
                        homeInjuries, awayInjuries, 
                        homeStatsPrev, awayStatsPrev, homeStatsCurrent, awayStatsCurrent, 
                        newsArticles, homeKeyPlayers, awayKeyPlayers
                    ] = await Promise.all([
                        Promise.resolve(recordsCache[currentYear]?.[homeData.name] || null),
                        Promise.resolve(recordsCache[currentYear]?.[awayData.name] || null),
                        fetchHeadToHead(homeData.name, awayData.name),
                        fetchSPRatings(homeData.name, currentYear),
                        fetchSPRatings(awayData.name, currentYear),
                        fetchSPRatings(homeData.name, previousYear),
                        fetchSPRatings(awayData.name, previousYear),
                        fetchInjuries(homeData.name),
                        fetchInjuries(awayData.name),
                        fetchAdvancedSeasonStats(homeData.name, previousYear),
                        fetchAdvancedSeasonStats(awayData.name, previousYear),
                        fetchAdvancedSeasonStats(homeData.name, currentYear),
                        fetchAdvancedSeasonStats(awayData.name, currentYear),
                        fetchGameNews(`"${homeData.name}" vs "${awayData.name}" football`),
                        fetchKeyReturningPlayers(homeData.name, previousYear),
                        fetchKeyReturningPlayers(awayData.name, previousYear)
                    ]);

                    const headToHead = headToHeadData?.games || [];
                    
                    updateModalStatus('Summarizing news...');
                    const newsSummary = await summarizeNews(newsArticles, homeData.name, awayData.name);
                    
                    const gameDateTime = new Date(commenceTime).toLocaleString('en-US', { dateStyle: 'full', timeStyle: 'short' });
                    const gameDetails = { gameDateTime, spread, newsSummary };
                    
                    const singleAnalysisPrompt = buildPrompt(gameDetails, homeData, awayData, 
                                               homeStatsPrev, awayStatsPrev, homeStatsCurrent, awayStatsCurrent,
                                               headToHead, homeSP, awaySP, homeSPPrev, awaySPPrev, 
                                               homeInjuries, awayInjuries, analysisType, homeRecordCurrent, awayRecordCurrent,
                                               homeKeyPlayers, awayKeyPlayers, currentWeek);

                    const individualAnalyses = [];
                    for (let i = 0; i < 3; i++) {
                        updateModalStatus(`Running Analysis ${i + 1} of 3...`);
                        const narrative = await generateNarrative(singleAnalysisPrompt);
                        individualAnalyses.push(narrative);
                    }

                    updateModalStatus('Synthesizing results...');
                    const consensusPrompt = buildConsensusPrompt(individualAnalyses, homeTeam, awayTeam, analysisType);
                    const consensusNarrative = await generateNarrative(consensusPrompt);
                    
                    if (user) {
                        await saveAnalysis(gameId, analysisType, consensusNarrative);
                        savedAnalysesCache.set(`${gameId}_${analysisType}`, consensusNarrative);
                        if (!button.textContent.includes('‚úì')) {
                            button.textContent += ' ‚úì';
                        }
                    }

                    const rawData = { 
                        homeData, awayData, headToHead, homeSP, awaySP, homeSPPrev, awaySPPrev, 
                        homeStatsPrev, awayStatsPrev, homeInjuries, awayInjuries, newsArticles,
                        homeRecordCurrent, awayRecordCurrent,
                        homeStatsCurrent, awayStatsCurrent,
                        individualAnalyses, homeKeyPlayers, awayKeyPlayers
                    };
                    displayNarrative(consensusNarrative, { gameId, homeTeam, awayTeam, spread, commenceTime, analysisType: analysisType }, rawData, analysisType === 'odds', analysisTitle, consensusPrompt);

                } catch (error) {
                    console.error("Consensus generation failed:", error);
                    narrativeModal.classList.add('hidden');
                    showError(`Could not generate consensus. ${error.message}`);
                } finally {
                     allButtonsInRow.forEach(el => { el.disabled = false; });
                }
            }
            
            async function handleFinalAnalysisClick(button) {
                const allButtonsInRow = button.closest('li').querySelectorAll('button');
                allButtonsInRow.forEach(el => { el.disabled = true; });

                const gameId = button.dataset.gameId;
                const homeTeam = button.dataset.homeTeam;
                const awayTeam = button.dataset.awayTeam;
                const analysisType = 'final';

                const savedAnalysis = savedAnalysesCache.get(`${gameId}_${analysisType}`);
                if (savedAnalysis) {
                    displayNarrative(savedAnalysis, { gameId, homeTeam, awayTeam, commenceTime: new Date().toISOString(), analysisType }, {}, false, 'Final Analysis', "Prompt not available for saved analysis.");
                    allButtonsInRow.forEach(el => { el.disabled = false; });
                    return;
                }
                
                showModalLoadingState({ homeTeam, awayTeam, analysisType: 'Final Analysis' });
                narrativeModal.classList.remove('hidden');
                clearError();

                try {
                    updateModalStatus('Fetching saved analyses...');
                    const savedAnalyses = await getSavedAnalyses(gameId);
                    if (!savedAnalyses.consensus || !savedAnalyses.odds || !savedAnalyses['no-spread']) {
                        throw new Error("One or more required analyses are missing.");
                    }

                    const userPicks = {
                        'Winner-Prediction': gamePicks.get(`${gameId}_consensus`),
                        'Spread-Analysis': gamePicks.get(`${gameId}_odds`),
                        'Game-Analysis': gamePicks.get(`${gameId}_no-spread`),
                    };

                    updateModalStatus('Generating final synthesis...');
                    const prompt = buildFinalAnalysisPrompt(savedAnalyses, userPicks, homeTeam, awayTeam);
                    const finalNarrative = await generateNarrative(prompt);

                    await saveAnalysis(gameId, 'final', finalNarrative);
                    savedAnalysesCache.set(`${gameId}_${analysisType}`, finalNarrative);
                    if (!button.textContent.includes('‚úì')) {
                        button.textContent += ' ‚úì';
                    }


                    displayNarrative(finalNarrative, { gameId, homeTeam, awayTeam, commenceTime: new Date().toISOString(), analysisType }, {}, false, 'Final Analysis', prompt);

                } catch (error) {
                    console.error("Final analysis generation failed:", error);
                    narrativeModal.classList.add('hidden');
                    showError(`Could not generate final analysis. ${error.message}`);
                } finally {
                    allButtonsInRow.forEach(el => { el.disabled = false; });
                }
            }


            gamesList.addEventListener('click', async (e) => {
                const button = e.target.closest('button');
                if (!button) return;

                if (button.classList.contains('analysis-btn')) {
                    handleAnalysisClick(button);
                } else if (button.classList.contains('final-analysis-btn')) {
                    handleFinalAnalysisClick(button);
                }
            });

            // --- Firebase Functions ---
            async function handleSavePick(gameId, analysisType) {
                if (!user) {
                    alert("Please log in to save your pick.");
                    return;
                }
                const selectedButton = modalFooter.querySelector('.pick-btn.selected');
                if (!selectedButton) {
                    alert("Please select a team before saving.");
                    return;
                }
                const team = selectedButton.dataset.teamName;
                const confidence = modalFooter.querySelector('#pick-confidence').value;
                
                const pickKey = `${gameId}_${analysisType}`;
                gamePicks.set(pickKey, { team, confidence });

                await saveGamePicks();
                updatePickDisplayOnCard(gameId, analysisType, team, confidence);
                narrativeModal.classList.add('hidden');
            }
            
            function updatePickDisplayOnCard(gameId, analysisType, team, confidence) {
                const gameItem = document.querySelector(`.game-item[data-game-id="${gameId}"]`);
                if (!gameItem) return;

                // Update button with checkmark
                const button = gameItem.querySelector(`[data-analysis-type="${analysisType}"]`);
                if (button && !button.textContent.includes('‚úì')) {
                    button.textContent += ' ‚úì';
                }

                // Update or add pick display text
                const pickDisplayContainer = gameItem.querySelector('.pick-display');
                let pickElement = pickDisplayContainer.querySelector(`[data-pick-type="${analysisType}"]`);
                if (!pickElement) {
                    pickElement = document.createElement('div');
                    let className = 'text-xs mt-1 ';
                    if (analysisType === 'final') {
                         className += 'text-green-400 font-bold';
                    } else {
                         className += 'text-yellow-400';
                    }
                    pickElement.className = className;
                    pickElement.dataset.pickType = analysisType;
                    pickDisplayContainer.appendChild(pickElement);
                }
                let label = 'Your Pick:';
                switch(analysisType) {
                    case 'consensus': label = 'Winner Pick:'; break;
                    case 'odds': label = 'Spread Pick:'; break;
                    case 'no-spread': label = 'Game Pick:'; break;
                    case 'final': label = 'Final Pick:'; break;
                }
                pickElement.textContent = `${label} ${team} (Confidence: ${confidence})`;

                // Check if all three initial picks are made to show the final analysis button
                const consensusPick = gamePicks.get(`${gameId}_consensus`);
                const oddsPick = gamePicks.get(`${gameId}_odds`);
                const noSpreadPick = gamePicks.get(`${gameId}_no-spread`);
                if (consensusPick && oddsPick && noSpreadPick) {
                    const finalBtn = gameItem.querySelector('.final-analysis-btn');
                    if (finalBtn) finalBtn.classList.remove('hidden');
                }
            }
            
            async function saveGamePicks() {
                if (!user) return;
                const userDocRef = doc(db, "users", user.uid);
                const picksObject = Object.fromEntries(gamePicks);
                await setDoc(userDocRef, { gamePicks: picksObject }, { merge: true });
            }
            
            async function loadGamePicks() {
                if (!user) return;
                const userDocRef = doc(db, "users", user.uid);
                const docSnap = await getDoc(userDocRef);
                if (docSnap.exists() && docSnap.data().gamePicks) {
                    const picksObject = docSnap.data().gamePicks;
                    gamePicks = new Map(Object.entries(picksObject));
                } else {
                    gamePicks = new Map();
                }
            }
            
            async function loadSavedAnalyses() {
                if (!user) return;
                savedAnalysesCache.clear();
                const analysesRef = collection(db, "game_analyses");
                const q = query(analysesRef, where("userId", "==", user.uid));
                const querySnapshot = await getDocs(q);
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const cacheKey = `${data.gameId}_${data.analysisType}`;
                    savedAnalysesCache.set(cacheKey, data.analysisText);
                });
            }


            async function saveAnalysis(gameId, analysisType, analysisText) {
                if (!user) return;
                try {
                    const analysesRef = collection(db, "game_analyses");
                    const q = query(analysesRef, where("userId", "==", user.uid), where("gameId", "==", gameId), where("analysisType", "==", analysisType));
                    const querySnapshot = await getDocs(q);

                    if (querySnapshot.empty) {
                        await addDoc(analysesRef, {
                            userId: user.uid,
                            gameId: gameId,
                            analysisType: analysisType,
                            analysisText: analysisText,
                            createdAt: new Date()
                        });
                    } else {
                        const docId = querySnapshot.docs[0].id;
                        const docRef = doc(db, "game_analyses", docId);
                        await setDoc(docRef, { analysisText: analysisText, createdAt: new Date() }, { merge: true });
                    }
                } catch (error) {
                    console.error("Error saving analysis to Firestore:", error);
                }
            }

            async function getSavedAnalyses(gameId) {
                if (!user) return {};
                const analyses = {};
                const analysesRef = collection(db, "game_analyses");
                const q = query(analysesRef, where("userId", "==", user.uid), where("gameId", "==", gameId));
                const querySnapshot = await getDocs(q);
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    analyses[data.analysisType] = data.analysisText;
                });
                return analyses;
            }


            function updateUserProfile() {
                if (user) {
                    userProfileContainer.innerHTML = `
                        <img src="${user.photoURL}" alt="User" class="w-10 h-10 rounded-full mr-4">
                        <button id="sign-out-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md transition">Sign Out</button>
                    `;
                    document.getElementById('sign-out-btn').addEventListener('click', () => {
                        signOut(auth).then(() => {
                            // The onAuthStateChanged listener will handle UI updates
                        });
                    });
                } else {
                    userProfileContainer.innerHTML = `
                        <button id="sign-in-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition">Sign In with Google</button>
                    `;
                    document.getElementById('sign-in-btn').addEventListener('click', () => {
                        const provider = new GoogleAuthProvider();
                        signInWithPopup(auth, provider);
                    });
                }
            }

            // --- Start the app ---
            init();
        });
    </script>
</body>
</html>
