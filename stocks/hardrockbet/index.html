<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>College Football AI Narratives</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üèà</text></svg>">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .card-enter {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        .card-enter-active {
            opacity: 1;
            transform: translateY(0);
        }
        .prose {
            font-size: 1.125rem;
            line-height: 1.75;
        }
        .prose h1, .prose h2, .prose h3, .prose h4 {
            color: #fff;
        }
        .prose p, .prose li, .prose blockquote {
            color: #d1d5db;
            margin-top: 1.25em;
            margin-bottom: 1.25em;
        }
        .prose strong {
            color: #fff;
        }
        .prose blockquote {
            border-left-color: #4a5568;
            padding-left: 1em;
        }
        .prose a {
            color: #60a5fa;
        }
        .prose h3 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-top: 2em;
            margin-bottom: 1em;
            border-bottom: 1px solid #4a5568;
            padding-bottom: 0.5rem;
        }
        /* Custom Scrollbar Styles */
        #narrativeModalContent::-webkit-scrollbar {
            width: 8px;
        }
        #narrativeModalContent::-webkit-scrollbar-track {
            background: #2d3748; /* gray-800 */
        }
        #narrativeModalContent::-webkit-scrollbar-thumb {
            background-color: #4a5568; /* gray-600 */
            border-radius: 10px;
            border: 2px solid #2d3748; /* gray-800 */
        }
        /* Accordion Styles */
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out, margin 0.3s ease-out;
            padding-left: 1rem;
            padding-right: 1rem;
        }
        .accordion-arrow {
            transition: transform 0.3s ease;
        }
        /* Input Focus Glow */
        .input-glow:focus {
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
        }
        .confidence-low { border-left: 4px solid #3b82f6; } /* blue-500 */
        .confidence-medium { border-left: 4px solid #22c55e; } /* green-500 */
        .confidence-high { border-left: 4px solid #f97316; } /* orange-500 */
        .confidence-very-high { border-left: 4px solid #ef4444; } /* red-500 */
        .pick-btn.selected {
            background-color: #2563eb; /* blue-600 */
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.7);
            border-color: #3b82f6;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div id="user-profile" class="absolute top-4 right-4 flex items-center"></div>

    <div id="apiKeyModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-gray-800 p-8 rounded-lg shadow-2xl w-full max-w-md mx-4 overflow-y-auto max-h-screen">
            <h2 class="text-2xl font-bold mb-4 text-center">Enter API Keys & Config</h2>
            <p class="text-gray-400 mb-6 text-center">Please provide your API keys and Firebase config to start.</p>
            <form id="apiKeyForm">
                <div class="mb-4">
                    <label for="oddsApiKeyInput" class="block text-gray-400 text-sm font-bold mb-2">The Odds API Key:</label>
                    <input type="password" id="oddsApiKeyInput" class="input-glow w-full bg-gray-700 border border-gray-600 rounded-md px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Your Odds API Key">
                </div>
                <div class="mb-4">
                    <label for="cfbDataApiKeyInput" class="block text-gray-400 text-sm font-bold mb-2">College Football Data API Key:</label>
                    <input type="password" id="cfbDataApiKeyInput" class="input-glow w-full bg-gray-700 border border-gray-600 rounded-md px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-red-500" placeholder="Your CFB Data API Key">
                </div>
                <div class="mb-4">
                    <label for="geminiApiKeyInput" class="block text-gray-400 text-sm font-bold mb-2">Google Gemini API Key:</label>
                    <input type="password" id="geminiApiKeyInput" class="input-glow w-full bg-gray-700 border border-gray-600 rounded-md px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-green-500" placeholder="Your Gemini API Key">
                </div>
                 <div class="mb-4">
                    <label for="googleApiKeyInput" class="block text-gray-400 text-sm font-bold mb-2">Google Search API Key:</label>
                    <input type="password" id="googleApiKeyInput" class="input-glow w-full bg-gray-700 border border-gray-600 rounded-md px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-500" placeholder="Your Google API Key">
                </div>
                <div class="mb-4">
                    <label for="googleCxInput" class="block text-gray-400 text-sm font-bold mb-2">Google Engine ID (CX):</label>
                    <input type="password" id="googleCxInput" class="input-glow w-full bg-gray-700 border border-gray-600 rounded-md px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-500" placeholder="Your Google Engine ID">
                </div>
                <div class="mb-6">
                    <label for="firebaseConfigInput" class="block text-gray-400 text-sm font-bold mb-2">Firebase Config (JSON):</label>
                    <textarea id="firebaseConfigInput" rows="6" class="input-glow w-full bg-gray-700 border border-gray-600 rounded-md px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-yellow-500" placeholder='{ "apiKey": "...", "authDomain": "...", ... }'></textarea>
                </div>
                <button type="submit" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition duration-300">Start Application</button>
            </form>
        </div>
    </div>

    <div id="narrativeModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 p-8 rounded-lg shadow-2xl w-full max-w-4xl mx-4 relative flex flex-col">
            <button id="closeNarrativeModal" class="absolute top-4 right-6 text-gray-400 hover:text-white text-3xl font-bold z-10">&times;</button>
            <div id="narrativeModalContent" class="flex-grow max-h-[80vh] overflow-y-auto pr-8 pb-8">
                </div>
            <div id="modal-footer" class="flex-shrink-0 pt-4 border-t border-gray-600">
                 <!-- Footer content is now dynamically generated -->
            </div>
        </div>
    </div>


    <div id="app" class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-10">
            <h1 class="text-4xl md:text-5xl font-bold">College Football Weekly</h1>
            <p class="text-gray-400 mt-2">AI-Generated Game Narratives Based on Live Spreads</p>
        </header>

        <div id="mainLoader" class="flex justify-center items-center my-16 hidden">
            <div class="loader"></div>
            <p id="mainLoaderText" class="ml-4 text-lg">Fetching upcoming games...</p>
        </div>
        
        <div id="errorDisplay" class="hidden bg-red-900 border border-red-700 text-red-200 px-4 py-3 rounded-lg relative my-4" role="alert">
            <strong class="font-bold">Error:</strong>
            <span id="errorMessage" class="block sm:inline"></span>
        </div>

        <div id="featured-game" class="mb-12"></div>

        <div id="games-list" class="space-y-8">
            </div>

    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, addDoc, collection, query, where, getDocs } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";

        // Version 9.3 - Refined seasonal weighting logic and prompt language.
        document.addEventListener('DOMContentLoaded', () => {
            const apiKeyModal = document.getElementById('apiKeyModal');
            const apiKeyForm = document.getElementById('apiKeyForm');
            const oddsApiKeyInput = document.getElementById('oddsApiKeyInput');
            const cfbDataApiKeyInput = document.getElementById('cfbDataApiKeyInput');
            const geminiApiKeyInput = document.getElementById('geminiApiKeyInput');
            const googleApiKeyInput = document.getElementById('googleApiKeyInput');
            const googleCxInput = document.getElementById('googleCxInput');
            const firebaseConfigInput = document.getElementById('firebaseConfigInput');
            
            const narrativeModal = document.getElementById('narrativeModal');
            const narrativeModalContent = document.getElementById('narrativeModalContent');
            const closeNarrativeModal = document.getElementById('closeNarrativeModal');
            const modalFooter = document.getElementById('modal-footer');

            const mainLoader = document.getElementById('mainLoader');
            const mainLoaderText = document.getElementById('mainLoaderText');
            const errorDisplay = document.getElementById('errorDisplay');
            const errorMessage = document.getElementById('errorMessage');
            const gamesList = document.getElementById('games-list');
            const featuredGameContainer = document.getElementById('featured-game');
            const userProfileContainer = document.getElementById('user-profile');
            
            let oddsApiKey = '', cfbDataApiKey = '', geminiApiKey = '', googleApiKey = '', googleCx = '';
            let currentNarrativeText = '';
            let gamePicks = new Map();
            let savedAnalysesCache = new Map();
            let auth, db, user;
            let initialLoadComplete = false;

            // --- Caching Objects ---
            let teamDataCache = {};
            let spCache = {};
            let talentCache = {};
            let recordsCache = {};
            let returningProductionCache = {};
            let advancedStatsCache = {};

            const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

            // --- Initialization ---
            function init() {
                apiKeyModal.classList.remove('hidden');
            }

            apiKeyForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const oddsKey = oddsApiKeyInput.value.trim();
                const cfbDataKey = cfbDataApiKeyInput.value.trim();
                const geminiKey = geminiApiKeyInput.value.trim();
                const googleKey = googleApiKeyInput.value.trim();
                const cxKey = googleCxInput.value.trim();
                const firebaseConfigString = firebaseConfigInput.value.trim();
                
                if (oddsKey && cfbDataKey && geminiKey && googleKey && cxKey && firebaseConfigString) {
                    try {
                        const firebaseConfig = JSON.parse(firebaseConfigString);
                        initializeApp(firebaseConfig);
                        auth = getAuth();
                        db = getFirestore();
                        
                        oddsApiKey = oddsKey;
                        cfbDataApiKey = cfbDataKey;
                        geminiApiKey = geminiKey;
                        googleApiKey = googleKey;
                        googleCx = cxKey;
                        apiKeyModal.classList.add('hidden');

                        await initializeAndCacheData();

                        onAuthStateChanged(auth, async (currentUser) => {
                            user = currentUser;
                            updateUserProfile();
                            if (user) {
                                await Promise.all([loadGamePicks(), loadSavedAnalyses()]);
                            } else {
                                gamePicks.clear();
                                savedAnalysesCache.clear();
                            }

                            if(!initialLoadComplete) {
                                fetchOdds();
                                initialLoadComplete = true;
                            } else {
                                fetchOdds();
                            }
                        });

                    } catch (error) {
                        alert("Invalid Firebase configuration or caching failed. Please check console.");
                        console.error("Initialization error:", error);
                    }
                } else {
                    alert('Please provide all API keys and the Firebase config.');
                }
            });

            closeNarrativeModal.addEventListener('click', () => {
                narrativeModal.classList.add('hidden');
            });

            // --- Caching and API Fetching ---

            async function initializeAndCacheData() {
                showLoader(true, "Caching seasonal data...");
                try {
                    const currentYear = new Date().getFullYear();
                    const previousYear = currentYear - 1;

                    let talentData = await cfbApiFetch(`https://api.collegefootballdata.com/talent?year=${currentYear}`);
                    if (!talentData || talentData.length === 0) {
                        console.log(`Talent data for ${currentYear} not found, falling back to ${previousYear}.`);
                        talentData = await cfbApiFetch(`https://api.collegefootballdata.com/talent?year=${previousYear}`);
                    }

                    const endpoints = {
                        spCurrent: `https://api.collegefootballdata.com/ratings/sp?year=${currentYear}`,
                        spPrevious: `https://api.collegefootballdata.com/ratings/sp?year=${previousYear}`,
                        recordsCurrent: `https://api.collegefootballdata.com/records?year=${currentYear}`,
                        recordsPrevious: `https://api.collegefootballdata.com/records?year=${previousYear}`,
                        returningProduction: `https://api.collegefootballdata.com/player/returning?year=${previousYear}`,
                        statsCurrent: `https://api.collegefootballdata.com/stats/season/advanced?year=${currentYear}`,
                        statsPrevious: `https://api.collegefootballdata.com/stats/season/advanced?year=${previousYear}`
                    };

                    const [
                        spCurrentData, spPreviousData,
                        recordsCurrentData, recordsPreviousData,
                        returningData, statsCurrentData, statsPreviousData
                    ] = await Promise.all(Object.values(endpoints).map(url => cfbApiFetch(url)));

                    const processData = (data, key) => data ? data.reduce((acc, item) => {
                        acc[item[key]] = item;
                        return acc;
                    }, {}) : {};
                    
                    if (talentData) talentCache = processData(talentData, 'school');
                    spCache[currentYear] = processData(spCurrentData, 'team');
                    spCache[previousYear] = processData(spPreviousData, 'team');
                    recordsCache[currentYear] = processData(recordsCurrentData, 'team');
                    recordsCache[previousYear] = processData(recordsPreviousData, 'team');
                    returningProductionCache = processData(returningData, 'team');
                    advancedStatsCache[currentYear] = processData(statsCurrentData, 'team');
                    advancedStatsCache[previousYear] = processData(statsPreviousData, 'team');

                } catch (error) {
                    console.error("Failed to cache seasonal data:", error);
                    showError("Could not initialize app data. Please check API keys and refresh.");
                    throw error;
                } finally {
                    showLoader(false);
                }
            }

            async function fetchOdds() {
                showLoader(true, "Fetching upcoming games...");
                clearError();
                gamesList.innerHTML = '';
                featuredGameContainer.innerHTML = '';

                const sport = 'americanfootball_ncaaf';
                const regions = 'us';
                const markets = 'spreads';
                const oddsFormat = 'american';
                const apiUrl = `https://api.the-odds-api.com/v4/sports/${sport}/odds/?regions=${regions}&markets=${markets}&oddsFormat=${oddsFormat}&apiKey=${oddsApiKey}`;

                try {
                    const response = await fetch(apiUrl);
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    if (data.length === 0) {
                        throw new Error("No upcoming college football games found.");
                    }
                    const teamData = await fetchAllTeamLogos();
                    displayGames(data, teamData);
                } catch (error) {
                    console.error('Error fetching odds:', error);
                    showError(`Failed to fetch odds: ${error.message}`);
                } finally {
                    showLoader(false);
                }
            }
            
            async function fetchAllTeamLogos() {
                const url = `https://api.collegefootballdata.com/teams/fbs?year=${new Date().getFullYear()}`;
                const data = await cfbApiFetch(url);
                if (!data) return {};
                return data.reduce((acc, team) => {
                    let logoUrl = team.logos?.[0] || null;
                    if (logoUrl && logoUrl.startsWith('http://')) {
                        logoUrl = logoUrl.replace('http://', 'https://');
                    }
                    acc[team.school] = logoUrl;
                    return acc;
                }, {});
            }
            
            const teamNameAliases = {
                "Alabama Crimson Tide": "Alabama", "Arkansas Razorbacks": "Arkansas", "Auburn Tigers": "Auburn", "Florida Gators": "Florida", "Georgia Bulldogs": "Georgia", "Kentucky Wildcats": "Kentucky", "LSU Tigers": "LSU", "Mississippi State Bulldogs": "Mississippi State", "Missouri Tigers": "Missouri", "Oklahoma Sooners": "Oklahoma", "Ole Miss Rebels": "Mississippi", "South Carolina Gamecocks": "South Carolina", "Tennessee Volunteers": "Tennessee", "Texas A&M Aggies": "Texas A&M", "Texas Longhorns": "Texas", "Vanderbilt Commodores": "Vanderbilt",
                "Illinois Fighting Illini": "Illinois", "Indiana Hoosiers": "Indiana", "Iowa Hawkeyes": "Iowa", "Maryland Terrapins": "Maryland", "Michigan State Spartans": "Michigan State", "Michigan Wolverines": "Michigan", "Minnesota Golden Gophers": "Minnesota", "Nebraska Cornhuskers": "Nebraska", "Northwestern Wildcats": "Northwestern", "Ohio State Buckeyes": "Ohio State", "Oregon Ducks": "Oregon", "Penn State Nittany Lions": "Penn State", "Purdue Boilermakers": "Purdue", "Rutgers Scarlet Knights": "Rutgers", "UCLA Bruins": "UCLA", "USC Trojans": "USC", "Washington Huskies": "Washington", "Wisconsin Badgers": "Wisconsin",
                "Arizona State Sun Devils": "Arizona State", "Arizona Wildcats": "Arizona", "Baylor Bears": "Baylor", "BYU Cougars": "BYU", "Cincinnati Bearcats": "Cincinnati", "Colorado Buffaloes": "Colorado", "Houston Cougars": "Houston", "Iowa State Cyclones": "Iowa State", "Kansas Jayhawks": "Kansas", "Kansas State Wildcats": "Kansas State", "Oklahoma State Cowboys": "Oklahoma State", "TCU Horned Frogs": "TCU", "Texas Tech Red Raiders": "Texas Tech", "UCF Knights": "UCF", "Utah Utes": "Utah", "West Virginia Mountaineers": "West Virginia",
                "Boston College Eagles": "Boston College", "California Golden Bears": "California", "Clemson Tigers": "Clemson", "Duke Blue Devils": "Duke", "Florida State Seminoles": "Florida State", "Georgia Tech Yellow Jackets": "Georgia Tech", "Louisville Cardinals": "Louisville", "Miami Hurricanes": "Miami", "NC State Wolfpack": "NC State", "North Carolina Tar Heels": "North Carolina", "Pittsburgh Panthers": "Pittsburgh", "SMU Mustangs": "SMU", "Stanford Cardinal": "Stanford", "Syracuse Orange": "Syracuse", "Virginia Cavaliers": "Virginia", "Virginia Tech Hokies": "Virginia Tech", "Wake Forest Demon Deacons": "Wake Forest",
                "Army Black Knights": "Army", "Charlotte 49ers": "Charlotte", "East Carolina Pirates": "East Carolina", "Florida Atlantic Owls": "Florida Atlantic", "Memphis Tigers": "Memphis", "Navy Midshipmen": "Navy", "North Texas Mean Green": "North Texas", "Rice Owls": "Rice", "South Florida Bulls": "South Florida", "Temple Owls": "Temple", "Tulane Green Wave": "Tulane", "Tulsa Golden Hurricane": "Tulsa", "UAB Blazers": "UAB", "UTSA Roadrunners": "UT San Antonio",
                "FIU Panthers": "Florida International", "Jacksonville State Gamecocks": "Jacksonville State", "Kennesaw State Owls": "Kennesaw State", "Liberty Flames": "Liberty", "Louisiana Tech Bulldogs": "Louisiana Tech", "Middle Tennessee Blue Raiders": "Middle Tennessee", "New Mexico State Aggies": "New Mexico State", "Sam Houston Bearkats": "Sam Houston State", "UTEP Miners": "UTEP", "Western Kentucky Hilltoppers": "Western Kentucky", "Delaware Fightin' Blue Hens": "Delaware",
                "Akron Zips": "Akron", "Ball State Cardinals": "Ball State", "Bowling Green Falcons": "Bowling Green", "Buffalo Bulls": "Buffalo", "Central Michigan Chippewas": "Central Michigan", "Eastern Michigan Eagles": "Eastern Michigan", "Kent State Golden Flashes": "Kent State", "Miami (OH) RedHawks": "Miami (OH)", "Northern Illinois Huskies": "Northern Illinois", "Ohio Bobcats": "Ohio", "Toledo Rockets": "Toledo", "Western Michigan Broncos": "Western Michigan",
                "Air Force Falcons": "Air Force", "Boise State Broncos": "Boise State", "Colorado State Rams": "Colorado State", "Fresno State Bulldogs": "Fresno State", "Hawaii Rainbow Warriors": "Hawai'i", "Nevada Wolf Pack": "Nevada", "New Mexico Lobos": "New Mexico", "San Diego State Aztecs": "San Diego State", "San Jose State Spartans": "San Jos√© State", "UNLV Rebels": "UNLV", "Utah State Aggies": "Utah State", "Wyoming Cowboys": "Wyoming", "Oregon State Beavers": "Oregon State", "Washington State Cougars": "Washington State",
                "Appalachian State Mountaineers": "Appalachian St.", "Arkansas State Red Wolves": "Arkansas State", "Coastal Carolina Chanticleers": "Coastal Carolina", "Georgia Southern Eagles": "Georgia Southern", "Georgia State Panthers": "Georgia State", "James Madison Dukes": "James Madison", "Louisiana Ragin' Cajuns": "Louisiana", "UL Monroe Warhawks": "UL Monroe", "Marshall Thundering Herd": "Marshall", "Old Dominion Monarchs": "Old Dominion", "South Alabama Jaguars": "South Alabama", "Southern Miss Golden Eagles": "Southern Miss", "Texas State Bobcats": "Texas State", "Troy Trojans": "Troy",
                "Notre Dame Fighting Irish": "Notre Dame", "UConn Huskies": "Connecticut", "UMass Minutemen": "UMass",
            };

            async function cfbApiFetch(url) {
                const headers = { 'Authorization': `Bearer ${cfbDataApiKey}` };
                try {
                    const response = await fetch(url, { headers });
                    if (!response.ok) {
                        console.error(`API Error for ${url}: ${response.status}`);
                        return null;
                    }
                    return await response.json();
                } catch (error) {
                    console.error(`Fetch error for ${url}:`, error);
                    return null;
                }
            }

            async function fetchTeamData(teamName) {
                const aliasedTeamName = teamNameAliases[teamName] || teamName;
                const previousYear = new Date().getFullYear() - 1;
                const teamRecordData = recordsCache[previousYear]?.[aliasedTeamName];
                const record = teamRecordData ? `${teamRecordData.total.wins}-${teamRecordData.total.losses}` : 'N/A';
                const returningProduction = returningProductionCache[aliasedTeamName];
                const talentScore = talentCache[aliasedTeamName]?.talent || 'N/A';
                return { name: aliasedTeamName, record, returningProduction, talentScore };
            }
            
            async function fetchAdvancedSeasonStats(teamName, year) { return advancedStatsCache[year]?.[teamName] || null; }
            async function fetchHeadToHead(team1, team2) {
                const url = `https://api.collegefootballdata.com/teams/matchup?team1=${encodeURIComponent(team1)}&team2=${encodeURIComponent(team2)}`;
                return await cfbApiFetch(url);
            }
            async function fetchSPRatings(team, year) { return spCache[year]?.[team] || null; }
            async function fetchInjuries(team) {
                const currentYear = new Date().getFullYear();
                const url = `https://api.collegefootballdata.com/injuries?year=${currentYear}&team=${encodeURIComponent(team)}`;
                return await cfbApiFetch(url);
            }

            async function fetchCoachData(team) {
                const currentYear = new Date().getFullYear();
                const url = `https://api.collegefootballdata.com/coaches?team=${encodeURIComponent(team)}&minYear=2024&maxYear=2025`;
                return await cfbApiFetch(url);
            }
            
            async function fetchBettingLines(team1, team2) {
                const currentYear = new Date().getFullYear();
                const url = `https://api.collegefootballdata.com/lines?year=${currentYear}&team=${encodeURIComponent(team1)}`;
                const lines = await cfbApiFetch(url);
                if (!lines || lines.length === 0) return null;
                return lines.find(line => line.homeTeam === team1 && line.awayTeam === team2 || line.homeTeam === team2 && line.awayTeam === team1);
            }

            async function fetchWinProbability(team1, team2) {
                const currentYear = new Date().getFullYear();
                const url = `https://api.collegefootballdata.com/ppa/predicted?year=${currentYear}&team=${encodeURIComponent(team1)}`;
                const predictions = await cfbApiFetch(url);
                 if (!predictions || predictions.length === 0) return null;
                return predictions.find(pred => pred.homeTeam === team1 && pred.awayTeam === team2 || pred.homeTeam === team2 && pred.awayTeam === team1);
            }

            async function fetchKeyPlayersData(teamName) {
                const currentYear = new Date().getFullYear();
                const previousYear = currentYear - 1;

                const urls = {
                    postSeason: `https://api.collegefootballdata.com/awards?year=${previousYear}&team=${encodeURIComponent(teamName)}`,
                    preSeason: `https://api.collegefootballdata.com/awards?year=${currentYear}&team=${encodeURIComponent(teamName)}`
                };

                const [postSeasonData, preSeasonData] = await Promise.all([
                    cfbApiFetch(urls.postSeason),
                    cfbApiFetch(urls.preSeason)
                ]);

                const keyAwards = [ "Walter Camp", "FWAA", "AP", "Sporting News", "AFCA", "Heisman", "Maxwell", "Davey O'Brien", "Doak Walker", "Biletnikoff", "John Mackey", "Rimington", "Outland", "Nagurski", "Bednarik", "Jim Thorpe", "Lou Groza", "Ray Guy" ];

                const processAwards = (data) => {
                    if (!data || data.length === 0) return 'None';
                    const keyPlayers = data.filter(award => keyAwards.some(keyAward => award.name.includes(keyAward))).map(award => `${award.recipient} (${award.name})`);
                    const uniquePlayers = [...new Set(keyPlayers)];
                    return uniquePlayers.length > 0 ? uniquePlayers.join(', ') : 'None';
                };

                return {
                    postSeasonHonors: processAwards(postSeasonData),
                    preSeasonWatchlist: processAwards(preSeasonData)
                };
            }

            async function fetchGameNews(query) {
                let allArticles = [];
                const numPages = 2;
                try {
                    for (let i = 0; i < numPages; i++) {
                        const start = i * 10 + 1;
                        const apiUrl = `https://www.googleapis.com/customsearch/v1?key=${googleApiKey}&cx=${googleCx}&q=${encodeURIComponent(query)}&start=${start}`;
                        const response = await fetch(apiUrl);
                        if (!response.ok) { console.error(`Google Search API error on page ${i+1}! Status: ${response.status}`); break; }
                        const data = await response.json();
                        if (data.items && data.items.length > 0) {
                            allArticles.push(...data.items.map(item => ({ title: item.title, link: item.link, snippet: item.snippet })));
                        } else { break; }
                        await sleep(250);
                    }
                    return allArticles;
                } catch (error) {
                    console.error('Error fetching game news:', error);
                    return [];
                }
            }
            
            async function summarizeNews(articles, homeTeam, awayTeam) {
                if (!articles || articles.length === 0) {
                    return { summary: "No recent news found for this matchup.", prompt: "No prompt generated as no news was found." };
                }
                const snippets = articles.map(a => `Title: ${a.title}\nSnippet: ${a.snippet}`).join('\n---\n');
                const prompt = `
                    You are a sports news analyst. Your task is to read the following collection of news article snippets 
                    about an upcoming game between ${homeTeam} and ${awayTeam} and synthesize them into a concise, structured summary.
                    **Format your response exactly as follows using Markdown:**

                    ### News & Narrative Summary
                    -   **Key Narratives:**
                        -   [Narrative 1]
                        -   [Narrative 2]
                    -   **Player Status Updates:**
                        -   **${homeTeam}:** [List any updates or "None mentioned"]
                        -   **${awayTeam}:** [List any updates or "None mentioned"]
                    -   **Team Sentiment:**
                        -   **${homeTeam}:** [Positive/Negative/Neutral]
                        -   **${awayTeam}:** [Positive/Negative/Neutral]

                    **Article Snippets to Analyze:**
                    ${snippets}`;
                const summary = await generateNarrative(prompt);
                return { summary, prompt };
            }
            
            async function fetchCurrentWeek() {
                const currentYear = new Date().getFullYear();
                const url = `https://api.collegefootballdata.com/calendar?year=${currentYear}`;
                const calendar = await cfbApiFetch(url);
                if (!calendar) return 1;
                const now = new Date();
                for (const weekData of calendar) {
                    const startDate = new Date(weekData.firstGameStart);
                    const endDate = new Date(weekData.lastGameStart);
                    endDate.setDate(endDate.getDate() + 1);
                    if (now >= startDate && now <= endDate) return weekData.week;
                }
                return 1;
            }
            
            async function generateNarrative(prompt, retries = 3, delay = 1000) {
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${geminiApiKey}`;
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                    });
                    if (!response.ok) {
                        if (response.status >= 500 && retries > 0) {
                            await sleep(delay);
                            return generateNarrative(prompt, retries - 1, delay * 2);
                        }
                        throw new Error(`AI generation failed. Status: ${response.status}`);
                    }
                    const result = await response.json();
                    if (result.candidates?.[0]?.content?.parts?.[0]) {
                        return result.candidates[0].content.parts[0].text;
                    } else {
                        if (retries > 0) {
                            await sleep(delay);
                            return generateNarrative(prompt, retries - 1, delay * 2);
                        }
                        throw new Error("Could not parse the AI's response.");
                    }
                } catch (error) {
                    if (error instanceof TypeError && retries > 0) {
                         await sleep(delay);
                         return generateNarrative(prompt, retries - 1, delay * 2);
                    }
                    throw error;
                }
            }

            // --- UI Rendering ---

            function displayGames(games, teamData) {
                gamesList.innerHTML = '';
                gamesList.className = 'space-y-8';

                const fbsTeamSet = new Set(Object.keys(teamNameAliases));
                const allGamesProcessed = games.map(game => {
                    const homeTeam = game.home_team;
                    const awayTeam = game.away_team;
                    if (!fbsTeamSet.has(homeTeam) || !fbsTeamSet.has(awayTeam)) return null;

                    const bookmaker = game.bookmakers.find(b => b.key === 'draftkings' || b.key === 'fanduel') || game.bookmakers[0];
                    const spreadMarket = bookmaker.markets.find(m => m.key === 'spreads');
                    if (!spreadMarket) return null;

                    const homeOutcome = spreadMarket.outcomes.find(o => o.name === homeTeam);
                    const awayOutcome = spreadMarket.outcomes.find(o => o.name === awayTeam);
                    if (!homeOutcome || !awayOutcome) return null;
                    
                    const absoluteSpread = Math.abs(homeOutcome.point);
                    const spreadDisplay = `${homeOutcome.name} ${homeOutcome.point > 0 ? '+' : ''}${homeOutcome.point}`;
                    
                    const homeTeamAlias = teamNameAliases[game.home_team];
                    const awayTeamAlias = teamNameAliases[game.away_team];
                    const homeTalent = talentCache[homeTeamAlias]?.talent || 0;
                    const awayTalent = talentCache[awayTeamAlias]?.talent || 0;

                    return { ...game, absoluteSpread, spreadDisplay, homeTalent, awayTalent };
                }).filter(Boolean);

                const majorConferenceTeams = new Set(["Alabama", "Arkansas", "Auburn", "Florida", "Georgia", "Kentucky", "LSU", "Mississippi State", "Missouri", "Oklahoma", "Mississippi", "South Carolina", "Tennessee", "Texas A&M", "Texas", "Vanderbilt", "Illinois", "Indiana", "Iowa", "Maryland", "Michigan State", "Michigan", "Minnesota", "Nebraska", "Northwestern", "Ohio State", "Oregon", "Penn State", "Purdue", "Rutgers", "UCLA", "USC", "Washington", "Wisconsin", "Arizona State", "Arizona", "Baylor", "BYU", "Cincinnati", "Colorado", "Houston", "Iowa State", "Kansas", "Kansas State", "Oklahoma State", "TCU", "Texas Tech", "UCF", "Utah", "West Virginia", "Boston College", "California", "Clemson", "Duke", "Florida State", "Georgia Tech", "Louisville", "Miami", "NC State", "North Carolina", "Pittsburgh", "SMU", "Stanford", "Syracuse", "Virginia", "Virginia Tech", "Wake Forest"]);
                const majorConferenceGames = allGamesProcessed.filter(game => majorConferenceTeams.has(teamNameAliases[game.home_team]) && majorConferenceTeams.has(teamNameAliases[game.away_team]));

                if (majorConferenceGames.length > 0) {
                    const featuredGame = [...majorConferenceGames].sort((a, b) => {
                        if (a.absoluteSpread !== b.absoluteSpread) return a.absoluteSpread - b.absoluteSpread;
                        return (b.homeTalent + b.awayTalent) - (a.homeTalent + a.awayTalent);
                    })[0];
                    displayFeaturedGame(featuredGame, teamData);
                }

                const gamesByDate = allGamesProcessed.reduce((acc, game) => {
                    const dateKey = new Date(game.commence_time).toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
                    if (!acc[dateKey]) acc[dateKey] = [];
                    acc[dateKey].push(game);
                    return acc;
                }, {});

                const sortedDates = Object.keys(gamesByDate).sort((a, b) => new Date(a) - new Date(b));
                if (sortedDates.length === 0) { showError("No upcoming FBS vs. FBS games found with available odds."); return; }

                sortedDates.forEach((dateKey, index) => {
                    const gamesForDate = gamesByDate[dateKey].sort((a, b) => b.absoluteSpread - a.absoluteSpread);
                    const gamesHtml = gamesForDate.map(game => {
                        const homeLogo = teamData[teamNameAliases[game.home_team]] || '';
                        const awayLogo = teamData[teamNameAliases[game.away_team]] || '';
                        
                        const consensusPick = gamePicks.get(`${game.id}_consensus`);
                        const matchupPick = gamePicks.get(`${game.id}_matchup`);
                        const noSpreadPick = gamePicks.get(`${game.id}_no-spread`);
                        const finalPick = gamePicks.get(`${game.id}_final`);

                        const hasConsensusAnalysis = savedAnalysesCache.has(`${game.id}_consensus`);
                        const hasMatchupAnalysis = savedAnalysesCache.has(`${game.id}_matchup`);
                        const hasNoSpreadAnalysis = savedAnalysesCache.has(`${game.id}_no-spread`);
                        const hasFinalAnalysis = savedAnalysesCache.has(`${game.id}_final`);

                        const pickDisplayHtml = (pick, type) => {
                            if (!pick) return '';
                            let label = '';
                            switch(type) {
                                case 'consensus': label = 'Winner Pick:'; break;
                                case 'matchup': label = 'Matchup Breakdown:'; break;
                                case 'no-spread': label = 'Game Analysis:'; break;
                                case 'final': label = 'Final Analysis:'; break;
                            }
                            return `<div class="text-xs mt-1 ${type === 'final' ? 'text-green-400 font-bold' : 'text-yellow-400'}" data-pick-type="${type}">${label} ${pick.team} (Confidence: ${pick.confidence})</div>`;
                        };
                        
                        const allPicksMade = consensusPick && matchupPick && noSpreadPick;

                        return `
                        <li class="game-item flex flex-col md:flex-row justify-between items-center p-4 rounded-lg hover:bg-gray-700 transition duration-200" data-game-id="${game.id}">
                            <div class="flex flex-col items-start mb-4 md:mb-0 flex-grow">
                                <div class="flex items-center">
                                    <img src="${awayLogo}" alt="${game.away_team}" class="w-8 h-8 mr-3 object-contain">
                                    <span class="font-bold text-lg">${game.away_team}</span>
                                    <span class="mx-2 text-gray-400">@</span>
                                    <img src="${homeLogo}" alt="${game.home_team}" class="w-8 h-8 mr-3 object-contain">
                                    <span class="font-bold text-lg">${game.home_team}</span>
                                </div>
                                <div class="pick-display mt-2 pl-1">
                                    ${pickDisplayHtml(consensusPick, 'consensus')}
                                    ${pickDisplayHtml(matchupPick, 'matchup')}
                                    ${pickDisplayHtml(noSpreadPick, 'no-spread')}
                                    ${pickDisplayHtml(finalPick, 'final')}
                                </div>
                            </div>
                            <div class="w-full md:w-auto flex flex-col md:flex-row items-center md:space-x-4">
                               <p class="text-blue-400 font-semibold w-full md:w-auto text-left md:text-right mb-2 md:mb-0">${game.spreadDisplay}</p>
                               <div class="flex w-full md:w-auto space-x-2">
                                    <button data-game-id="${game.id}" data-home-team="${game.home_team}" data-away-team="${game.away_team}" data-spread="${game.spreadDisplay}" data-commence-time="${game.commence_time}" class="analysis-btn flex-1 bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-3 rounded-md transition duration-300 text-sm whitespace-nowrap" data-analysis-type="consensus">${hasConsensusAnalysis ? 'Predict Winner ‚úì' : 'Predict Winner'}</button>
                                    <button data-game-id="${game.id}" data-home-team="${game.home_team}" data-away-team="${game.away_team}" data-spread="${game.spreadDisplay}" data-commence-time="${game.commence_time}" class="analysis-btn flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-3 rounded-md transition duration-300 text-sm whitespace-nowrap" data-analysis-type="matchup">${hasMatchupAnalysis ? 'Matchup Breakdown ‚úì' : 'Matchup Breakdown'}</button>
                                    <button data-game-id="${game.id}" data-home-team="${game.home_team}" data-away-team="${game.away_team}" data-spread="${game.spreadDisplay}" data-commence-time="${game.commence_time}" class="analysis-btn flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-md transition duration-300 text-sm whitespace-nowrap" data-analysis-type="no-spread">${hasNoSpreadAnalysis ? 'Analyze Game ‚úì' : 'Analyze Game'}</button>
                                    <button data-game-id="${game.id}" data-home-team="${game.home_team}" data-away-team="${game.away_team}" class="final-analysis-btn flex-1 bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-3 rounded-md transition duration-300 text-sm whitespace-nowrap ${allPicksMade ? '' : 'hidden'}" data-analysis-type="final">${hasFinalAnalysis ? 'Final Analysis ‚úì' : 'Final Analysis'}</button>
                                </div>
                            </div>
                        </li>`;
                    }).join('');

                    const dateCard = document.createElement('div');
                    dateCard.className = 'bg-gray-800 rounded-lg shadow-lg overflow-hidden card-enter';
                    dateCard.innerHTML = `
                        <div class="bg-gray-700 p-4 border-b border-gray-600"><h2 class="text-2xl font-bold text-white">${dateKey}</h2></div>
                        <ul class="divide-y divide-gray-600">${gamesHtml}</ul>`;
                    gamesList.appendChild(dateCard);
                    setTimeout(() => dateCard.classList.add('card-enter-active'), index * 100);
                });
            }

            function displayFeaturedGame(game, teamData) {
                const homeLogo = teamData[teamNameAliases[game.home_team]] || '';
                const awayLogo = teamData[teamNameAliases[game.away_team]] || '';
                const gameTime = new Date(game.commence_time).toLocaleTimeString('en-US', { timeStyle: 'short' });
                featuredGameContainer.innerHTML = `
                    <div class="bg-gray-800 rounded-lg shadow-lg p-6 border-2 border-yellow-400">
                        <h2 class="text-2xl font-bold text-center mb-4 text-yellow-300">Featured Game of the Week</h2>
                        <div class="flex justify-around items-center text-center">
                            <div class="flex flex-col items-center">
                                <img src="${awayLogo}" alt="${game.away_team}" class="w-20 h-20 mb-2 object-contain">
                                <p class="text-xl font-semibold">${game.away_team}</p>
                            </div>
                            <div>
                                <p class="text-4xl font-bold text-gray-400">VS</p>
                                <p class="text-lg text-blue-400 mt-2">${game.spreadDisplay}</p>
                                <p class="text-sm text-gray-400">${gameTime}</p>
                            </div>
                            <div class="flex flex-col items-center">
                                <img src="${homeLogo}" alt="${game.home_team}" class="w-20 h-20 mb-2 object-contain">
                                <p class="text-xl font-semibold">${game.home_team}</p>
                            </div>
                        </div>
                    </div>`;
            }

            function showModalLoadingState(details) {
                const analysisTypeDisplay = details.analysisType ? `<div class="text-center mb-4"><span class="bg-gray-700 text-gray-300 text-sm font-semibold px-3 py-1 rounded-full uppercase tracking-wider">${details.analysisType.replace('-', ' ')}</span></div>` : '';
                modalFooter.innerHTML = '';
                narrativeModalContent.innerHTML = `
                    <h2 class="text-3xl font-bold mb-2 text-center">${details.awayTeam} vs. ${details.homeTeam}</h2>
                    ${analysisTypeDisplay}
                    <div class="flex flex-col items-center justify-center my-16">
                        <div class="loader"></div>
                        <p id="modalStatusText" class="mt-4 text-lg text-gray-300">Initializing...</p>
                    </div>`;
            }

            function updateModalStatus(message) {
                const statusTextElement = document.getElementById('modalStatusText');
                if (statusTextElement) statusTextElement.textContent = message;
            }
            
            function displayNarrative(narrative, gameDetails, rawData, analysisTitle, consensusPrompt) {
                currentNarrativeText = narrative;
                const formattedNarrative = marked.parse(narrative);
                const gameDateTime = new Date(gameDetails.commenceTime).toLocaleString('en-US', { dateStyle: 'full', timeStyle: 'short' });
                const analysisTypeDisplay = analysisTitle ? `<div class="text-center mb-4"><span class="bg-gray-700 text-gray-300 text-sm font-semibold px-3 py-1 rounded-full uppercase tracking-wider">${analysisTitle}</span></div>` : '';
                
                // --- Accordion HTML Generation ---
                let notablePlayersAccordionHtml = '';
                if (rawData.homeNotablePlayers && rawData.awayNotablePlayers) {
                    notablePlayersAccordionHtml = `<div class="mt-8 border-t border-gray-600 pt-4"><button class="accordion-toggle w-full text-left text-lg font-semibold text-gray-300 hover:text-white focus:outline-none"><span class="accordion-arrow transform transition-transform duration-300 inline-block mr-2">‚ñ∂</span> Scouting Report: Notable Players</button><div class="accordion-content bg-gray-900 rounded-md"><h4 class="font-bold text-md mb-2 text-gray-400">Home Team: ${gameDetails.homeTeam}</h4><div class="prose prose-sm prose-invert max-w-none text-gray-400">${marked.parse(rawData.homeNotablePlayers)}</div><h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Away Team: ${gameDetails.awayTeam}</h4><div class="prose prose-sm prose-invert max-w-none text-gray-400">${marked.parse(rawData.awayNotablePlayers)}</div></div></div>`;
                }

                let rawDataAccordionHtml = '';
                if (rawData && rawData.homeData) {
                    rawDataAccordionHtml = `<div class="mt-4 border-t border-gray-600 pt-4"><button class="accordion-toggle w-full text-left text-lg font-semibold text-gray-300 hover:text-white focus:outline-none"><span class="accordion-arrow transform transition-transform duration-300 inline-block mr-2">‚ñ∂</span> View Raw API Data</button><div class="accordion-content bg-gray-900 rounded-md"><h4 class="font-bold text-md mb-2 text-gray-400">Team Overview Data (Home: ${rawData.homeData.name})</h4><pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">${JSON.stringify(rawData.homeData, null, 2)}</pre><h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Team Overview Data (Away: ${rawData.awayData.name})</h4><pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">${JSON.stringify(rawData.awayData, null, 2)}</pre><h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Key Player Accolades</h4><pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">Home: ${JSON.stringify(rawData.homeKeyPlayersData, null, 2)}\nAway: ${JSON.stringify(rawData.awayKeyPlayersData, null, 2)}</pre><h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Current Year Record (Home)</h4><pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">${JSON.stringify(rawData.homeRecordCurrent, null, 2)}</pre><h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Current Year Record (Away)</h4><pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">${JSON.stringify(rawData.awayRecordCurrent, null, 2)}</pre><h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Head to Head</h4><pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">${JSON.stringify(rawData.headToHead, null, 2)}</pre><h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Coach Data</h4><pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">Home: ${JSON.stringify(rawData.homeCoachData, null, 2)}\nAway: ${JSON.stringify(rawData.awayCoachData, null, 2)}</pre><h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Betting Lines</h4><pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">${JSON.stringify(rawData.bettingLines, null, 2)}</pre><h4 class="font-bold text-md mt-4 mb-2 text-gray-400">PPA Win Probability</h4><pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">${JSON.stringify(rawData.winProbability, null, 2)}</pre><h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Current Year SP+ Ratings</h4><pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">Home: ${JSON.stringify(rawData.homeSP, null, 2)}\nAway: ${JSON.stringify(rawData.awaySP, null, 2)}</pre><h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Previous Year SP+ Ratings</h4><pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">Home: ${JSON.stringify(rawData.homeSPPrev, null, 2)}\nAway: ${JSON.stringify(rawData.awaySPPrev, null, 2)}</pre><h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Advanced Season Stats (Previous Year)</h4><pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">Home: ${JSON.stringify(rawData.homeStatsPrev, null, 2)}\nAway: ${JSON.stringify(rawData.awayStatsPrev, null, 2)}</pre><h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Advanced Season Stats (Current Year)</h4><pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">Home: ${JSON.stringify(rawData.homeStatsCurrent, null, 2)}\nAway: ${JSON.stringify(rawData.awayStatsCurrent, null, 2)}</pre><h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Injuries</h4><pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">Home: ${JSON.stringify(rawData.homeInjuries, null, 2)}\nAway: ${JSON.stringify(rawData.awayInjuries, null, 2)}</pre></div></div>`;
                }

                let newsAccordionHtml = '';
                if (rawData.newsArticles && rawData.newsArticles.length > 0) {
                    const newsItems = rawData.newsArticles.map(article => `<li class="mb-3 pb-3 border-b border-gray-700 last:border-b-0 last:mb-0 last:pb-0"><a href="${article.link}" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:underline font-semibold">${article.title}</a><p class="text-sm text-gray-400 mt-1">${article.snippet}</p></li>`).join('');
                    newsAccordionHtml = `<div class="mt-4 border-t border-gray-600 pt-4"><button class="accordion-toggle w-full text-left text-lg font-semibold text-gray-300 hover:text-white focus:outline-none"><span class="accordion-arrow transform transition-transform duration-300 inline-block mr-2">‚ñ∂</span> View Raw News Articles</button><div class="accordion-content bg-gray-900 rounded-md"><ul class="list-none">${newsItems}</ul></div></div>`;
                }

                let newsSummaryAccordionHtml = '';
                if (rawData.newsSummaryPrompt) {
                    newsSummaryAccordionHtml = `<div class="mt-4 border-t border-gray-600 pt-4"><button class="accordion-toggle w-full text-left text-lg font-semibold text-gray-300 hover:text-white focus:outline-none"><span class="accordion-arrow transform transition-transform duration-300 inline-block mr-2">‚ñ∂</span> Step 1: View News Summary Prompt & Result</button><div class="accordion-content bg-gray-900 rounded-md"><h4 class="font-bold text-md mb-2 text-gray-400">Prompt Sent to AI:</h4><pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">${rawData.newsSummaryPrompt}</pre><h4 class="font-bold text-md mt-4 mb-2 text-gray-400">Resulting Summary:</h4><div class="prose prose-sm prose-invert max-w-none text-gray-400">${marked.parse(rawData.newsSummary)}</div></div></div>`;
                }

                let mainAnalysisPromptAccordionHtml = '';
                if (rawData.mainAnalysisPrompt) {
                     mainAnalysisPromptAccordionHtml = `<div class="mt-4 border-t border-gray-600 pt-4"><button class="accordion-toggle w-full text-left text-lg font-semibold text-gray-300 hover:text-white focus:outline-none"><span class="accordion-arrow transform transition-transform duration-300 inline-block mr-2">‚ñ∂</span> Step 2: View Main Analysis Prompt</button><div class="accordion-content bg-gray-900 rounded-md"><pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">${rawData.mainAnalysisPrompt}</pre></div></div>`;
                }

                let individualAnalysesHtml = '';
                if (rawData.individualAnalyses && rawData.individualAnalyses.length > 0) {
                    const analysisItems = rawData.individualAnalyses.map((analysis, index) => `<div class="mb-4 border-b border-gray-700 pb-4 last:border-b-0 last:pb-0"><h5 class="font-bold text-md mb-2 text-gray-400">Analyst Report ${index + 1}</h5><div class="prose prose-sm prose-invert max-w-none text-gray-400">${marked.parse(analysis)}</div></div>`).join('');
                    individualAnalysesHtml = `<div class="mt-4 border-t border-gray-600 pt-4"><button class="accordion-toggle w-full text-left text-lg font-semibold text-gray-300 hover:text-white focus:outline-none"><span class="accordion-arrow transform transition-transform duration-300 inline-block mr-2">‚ñ∂</span> Step 3: View Individual Analyst Reports</button><div class="accordion-content bg-gray-900 rounded-md">${analysisItems}</div></div>`;
                }

                let consensusPromptAccordionHtml = '';
                if (consensusPrompt && !consensusPrompt.includes('not available')) {
                    consensusPromptAccordionHtml = `<div class="mt-8 border-t border-gray-600 pt-4"><button class="accordion-toggle w-full text-left text-lg font-semibold text-gray-300 hover:text-white focus:outline-none"><span class="accordion-arrow transform transition-transform duration-300 inline-block mr-2">‚ñ∂</span> Step 4: View Final Consensus Prompt</button><div class="accordion-content bg-gray-900 rounded-md"><pre class="text-xs text-gray-400 whitespace-pre-wrap break-words">${consensusPrompt}</pre></div></div>`;
                }
                
                // --- Final Modal Assembly ---
                narrativeModalContent.innerHTML = `
                    <h2 class="text-3xl font-bold mb-2 text-center">${gameDetails.awayTeam} vs. ${gameDetails.homeTeam}</h2>
                    <p class="text-center text-gray-400 text-sm mb-2">${gameDateTime}</p>
                    <div class="mb-6"></div>
                    ${analysisTypeDisplay}
                    <div class="prose prose-invert max-w-none text-gray-300">${formattedNarrative}</div>
                    ${notablePlayersAccordionHtml}
                    ${rawDataAccordionHtml}
                    ${newsAccordionHtml}
                    ${newsSummaryAccordionHtml}
                    ${mainAnalysisPromptAccordionHtml}
                    ${individualAnalysesHtml}
                    ${consensusPromptAccordionHtml}`;

                modalFooter.innerHTML = `
                    <div class="flex justify-center space-x-4">
                        <button id="copyNarrativeBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-300">Copy Text</button>
                        <button id="refreshAnalysisBtn" 
                                data-game-id="${gameDetails.gameId}" 
                                data-home-team="${gameDetails.homeTeam}" 
                                data-away-team="${gameDetails.awayTeam}" 
                                data-spread="${gameDetails.spread}" 
                                data-commence-time="${gameDetails.commenceTime}" 
                                data-analysis-type="${gameDetails.analysisType}"
                                class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition duration-300">
                            Refresh Analysis
                        </button>
                    </div>`;
                
                document.getElementById('copyNarrativeBtn').addEventListener('click', () => {
                    navigator.clipboard.writeText(currentNarrativeText).then(() => {
                        const btn = document.getElementById('copyNarrativeBtn');
                        btn.textContent = 'Copied!';
                        setTimeout(() => { btn.textContent = 'Copy Text'; }, 2000);
                    });
                });

                document.getElementById('refreshAnalysisBtn').addEventListener('click', (e) => {
                    const button = e.currentTarget;
                    if (button.dataset.analysisType === 'final') {
                        handleFinalAnalysisClick(button, true);
                    } else {
                        handleAnalysisClick(button, true);
                    }
                });

                narrativeModal.classList.remove('hidden');

                document.querySelectorAll('.accordion-toggle').forEach(button => {
                    button.addEventListener('click', () => {
                        const content = button.nextElementSibling;
                        const arrow = button.querySelector('.accordion-arrow');
                        const isExpanded = content.style.maxHeight && content.style.maxHeight !== '0px';
                        if (isExpanded) {
                            content.style.maxHeight = '0px';
                            content.style.paddingTop = null;
                            content.style.paddingBottom = null;
                            content.style.marginTop = null;
                            arrow.style.transform = 'rotate(0deg)';
                        } else {
                            content.style.paddingTop = '1rem';
                            content.style.paddingBottom = '1rem';
                            content.style.marginTop = '0.5rem';
                            content.style.maxHeight = content.scrollHeight + 'px';
                            arrow.style.transform = 'rotate(90deg)';
                        }
                    });
                });
            }

            function showLoader(isLoading, message = "Loading...") {
                mainLoaderText.textContent = message;
                mainLoader.classList.toggle('hidden', !isLoading);
            }
            function showError(message) {
                errorMessage.textContent = message;
                errorDisplay.classList.remove('hidden');
            }
            function clearError() { errorDisplay.classList.add('hidden'); }
            
            function buildNotablePlayersPrompt(teamA, teamB, allData) {
                const {
                    newsSummary, homeData, awayData, homeStatsPrev, awayStatsPrev,
                    homeStatsCurrent, awayStatsCurrent, homeInjuries, awayInjuries,
                    homeKeyPlayersData, awayKeyPlayersData
                } = allData;

                const teamAData = teamA === homeData.name ? {
                    statsPrev: homeStatsPrev,
                    statsCurrent: homeStatsCurrent,
                    injuries: homeInjuries,
                    keyPlayers: homeKeyPlayersData
                } : {
                    statsPrev: awayStatsPrev,
                    statsCurrent: awayStatsCurrent,
                    injuries: awayInjuries,
                    keyPlayers: awayKeyPlayersData
                };

                const teamBData = teamB === homeData.name ? {
                    statsPrev: homeStatsPrev,
                    statsCurrent: homeStatsCurrent
                } : {
                    statsPrev: awayStatsPrev,
                    statsCurrent: awayStatsCurrent
                };

                const formatInjuries = (injuries) => !injuries || injuries.length === 0 ? 'None reported.' : injuries.map(i => `${i.firstName} ${i.lastName} (${i.position}) - ${i.status}`).join(', ');
                const createStatsBlock = (stats, teamName) => {
                    if (!stats) return `No advanced stats available for ${teamName}.`;
                    return `
-   **${teamName}:**
    -   Offense: PPA: ${stats.offense?.ppa?.toFixed(2) || 'N/A'}, Success Rate: ${(stats.offense?.successRate * 100).toFixed(1) || 'N/A'}%
    -   Defense: PPA: ${stats.defense?.ppa?.toFixed(2) || 'N/A'}, Success Rate: ${(stats.defense?.successRate * 100).toFixed(1) || 'N/A'}%, Havoc: ${(stats.defense?.havoc?.total * 100).toFixed(1) || 'N/A'}%`;
                };

                return `Act as an expert college football analyst and scout, similar to one from ESPN or The Athletic.

Your task is to analyze the notable players for ${teamA} and identify the "unfair advantages" they create in their upcoming matchup against ${teamB}.

For each key player you identify (focus on 3-5 of the most impactful), provide a detailed breakdown covering the following points:

1.  **Player Profile:**
    * Name, Position, Year (e.g., Junior, Senior).
    * A brief summary of their role and playing style.

2.  **The "Unfair Advantage" vs. ${teamB}:**
    * This is the most critical section. Explain precisely how this player's skills create a significant mismatch against ${teamB}'s specific personnel, scheme, or known weaknesses.
    * Reference specific stats or tendencies for ${teamB}. For example: "[Team B]'s offensive line has allowed a 25% pressure rate on third downs," or "[Team B]'s top cornerback is only 5'9" and struggles with taller receivers]."

3.  **Supporting Evidence & Star Power:**
    * **Key Stats:** Provide current season statistics that highlight their dominance. Compare these stats to national or conference leaders to provide context (e.g., "His 8 sacks rank 3rd in the SEC").
    * **Proven Abilities:** Mention any awards, All-American/All-Conference honors, or standout performances from past seasons.
    * **NFL Draft Stock:** Briefly comment on their potential as a pro prospect (e.g., "Projected first-round pick," "Considered a top-5 QB in the upcoming draft class").

Please structure your response clearly, with a separate section for each player. Conclude with a short summary of which matchup advantage you believe will be the most decisive in the game.

Format the response as a simple Markdown bulleted list.

**AVAILABLE DATA FOR YOUR ANALYSIS:**
- **News Summary:**
${newsSummary}
- **${teamA} Key Player Accolades:**
  - Previous Season Honors: ${teamAData.keyPlayers.postSeasonHonors}
  - Current Pre-Season Watchlists: ${teamAData.keyPlayers.preSeasonWatchlist}
- **${teamA} Injuries:** ${formatInjuries(teamAData.injuries)}
- **Advanced Stats (${new Date().getFullYear() - 1}):**
  ${createStatsBlock(teamAData.statsPrev, teamA)}
  ${createStatsBlock(teamBData.statsPrev, teamB)}
- **Advanced Stats (${new Date().getFullYear()}):**
  ${createStatsBlock(teamAData.statsCurrent, teamA)}
  ${createStatsBlock(teamBData.statsCurrent, teamB)}
`;
            }

            function buildPrompt(gameDetails, homeData, awayData, 
                                 homeStatsPrev, awayStatsPrev, homeStatsCurrent, awayStatsCurrent,
                                 headToHead, homeSP, awaySP, homeSPPrev, awaySPPrev, 
                                 homeInjuries, awayInjuries, analysisType, homeRecordCurrent, awayRecordCurrent,
                                 homeKeyPlayersData, awayKeyPlayersData, currentWeek, homeCoachData, awayCoachData,
                                 bettingLines, winProbability, homeNotablePlayers, awayNotablePlayers) {
                                 
                const { gameDateTime, newsSummary } = gameDetails;
                const currentYear = new Date().getFullYear();
                const previousYear = currentYear - 1;

                const marketAndModelInstructions = `
**MARKET & MODEL ANALYSIS DIRECTIVE:**
-   **Game Total Context:** A high game total (e.g., >60) suggests an offensive shootout. Prioritize offensive stats like PPA and Success Rate. A low total (e.g., <45) suggests a defensive battle. Prioritize defensive stats like Havoc, Stuff Rate, and field position.
-   **PPA Win Probability:** Use the PPA Win Probability as a quantitative baseline. Your main task is to determine if the qualitative data (injuries, news, coaching) and key statistical matchups support or contradict this baseline prediction.
`;

                const seasonalWeightingInstructions = currentWeek < 3 ? 
                    `**SEASONAL ANALYSIS DIRECTIVE: EARLY SEASON (Current Week: ${currentWeek})**\n-   **Primary Weighting:** Assign primary weight to previous-year data (${previousYear}), pre-season SP+ ratings, and returning production percentages, as these are the most reliable indicators of team quality at this stage.\n-   **Secondary Weighting:** Use current-season data (${currentYear}) cautiously as a secondary indicator due to small sample sizes. Note significant deviations from pre-season expectations but do not overreact to stats from one or two games.\n-   **Focus:** Identify if teams are meeting, exceeding, or falling short of their pre-season projections based on the limited data available.` : 
                    `**SEASONAL ANALYSIS DIRECTIVE: MID/LATE SEASON (Current Week: ${currentWeek})**\n-   **Primary Weighting:** Assign primary weight to current-season data (${currentYear}). Performance metrics are now more indicative of team quality than pre-season projections.\n-   **Secondary Weighting:** Use previous-year data (${previousYear}) and pre-season SP+ ratings as context to understand a team's baseline talent and coaching, but prioritize demonstrated on-field performance from this year.\n-   **Focus:** Analyze established trends, statistical strengths and weaknesses from the current season, and how teams have performed against comparable opponents.`;
                
                const confidenceRubric = `Provide a confidence score based on the following rubric:\n- **Low**: Key data points are highly conflicting, making the outcome a statistical coin flip.\n- **Medium**: Data shows a discernible advantage for one team, but the opponent has significant strengths that could counter it.\n- **High**: Data shows a clear and consistent advantage for one team across most important categories.\n- **Very High**: Data indicates a significant mismatch in nearly every critical metric.`;
                
                const formatInjuries = (injuries) => !injuries || injuries.length === 0 ? 'None reported.' : injuries.map(i => `${i.firstName} ${i.lastName} (${i.position}) - ${i.status}`).join(', ');
                const formatHeadToHead = (h2h) => !h2h || h2h.length === 0 ? 'No recent meetings.' : h2h.map(g => `${g.season}: ${g.homeTeam} ${g.homeScore}-${g.awayScore} ${g.awayTeam}`).join('\n    - ');
                
                const formatCoachData = (coachArray) => {
                    if (!coachArray || coachArray.length === 0) return 'No data for 2024-2025.';
                    
                    const coach = coachArray[0];
                    
                    if (!coach.seasons || coach.seasons.length === 0) return 'No data for 2024-2025.';

                    const record = coach.seasons.reduce((acc, season) => {
                        acc.wins += season.wins;
                        acc.losses += season.losses;
                        return acc;
                    }, { wins: 0, losses: 0 });
                    
                    const school = coach.seasons[coach.seasons.length - 1].school;

                    return `${coach.first_name} ${coach.last_name} (2024-2025 Record at ${school}: ${record.wins}-${record.losses})`;
                };

                const createStatsBlock = (stats, teamName) => {
                    if (!stats) return '';
                    return `
-   **${teamName}:**
    -   **Offense Breakdown:**
        - Overall: PPA: ${stats.offense?.ppa?.toFixed(2) || 'N/A'} | Success: ${(stats.offense?.successRate * 100).toFixed(1) || 'N/A'}% | Explosiveness: ${stats.offense?.explosiveness?.toFixed(2) || 'N/A'}
        - Rushing: PPA: ${stats.offense?.rushingPlays?.ppa?.toFixed(2) || 'N/A'} | Success: ${(stats.offense?.rushingPlays?.successRate * 100).toFixed(1) || 'N/A'}% | Explosiveness: ${stats.offense?.rushingPlays?.explosiveness?.toFixed(2) || 'N/A'}
        - Passing: PPA: ${stats.offense?.passingPlays?.ppa?.toFixed(2) || 'N/A'} | Success: ${(stats.offense?.passingPlays?.successRate * 100).toFixed(1) || 'N/A'}% | Explosiveness: ${stats.offense?.passingPlays?.explosiveness?.toFixed(2) || 'N/A'}
    -   **Defense Breakdown:**
        - Overall: PPA: ${stats.defense?.ppa?.toFixed(2) || 'N/A'} | Success: ${(stats.defense?.successRate * 100).toFixed(1) || 'N/A'}% | Havoc (Total): ${(stats.defense?.havoc?.total * 100).toFixed(1) || 'N/A'}%
        - Vs. Rush: PPA: ${stats.defense?.rushingPlays?.ppa?.toFixed(2) || 'N/A'} | Success: ${(stats.defense?.rushingPlays?.successRate * 100).toFixed(1) || 'N/A'}% | Stuff Rate: ${(stats.defense?.stuffRate * 100).toFixed(1) || 'N/A'}%
        - Vs. Pass: PPA: ${stats.defense?.passingPlays?.ppa?.toFixed(2) || 'N/A'} | Success: ${(stats.defense?.passingPlays?.successRate * 100).toFixed(1) || 'N/A'}% | DB Havoc: ${(stats.defense?.havoc?.db * 100).toFixed(1) || 'N/A'}%
        - Havoc Breakdown: Front Seven: ${(stats.defense?.havoc?.frontSeven * 100).toFixed(1) || 'N/A'}% | DBs: ${(stats.defense?.havoc?.db * 100).toFixed(1) || 'N/A'}%
    -   **Line of Scrimmage & Explosiveness:**
        - Off. Line Yards: ${stats.offense?.lineYards?.toFixed(2) || 'N/A'} | Second Level Yards: ${stats.offense?.secondLevelYards?.toFixed(2) || 'N/A'} | Open Field Yards: ${stats.offense?.openFieldYards?.toFixed(2) || 'N/A'}
        - Def. Line Yards Allowed: ${stats.defense?.lineYards?.toFixed(2) || 'N/A'} | Second Level Yards Allowed: ${stats.defense?.secondLevelYards?.toFixed(2) || 'N/A'} | Open Field Yards Allowed: ${stats.defense?.openFieldYards?.toFixed(2) || 'N/A'}
    -   **Situational & Efficiency:**
        - Passing Downs Success: ${(stats.offense?.passingDowns?.successRate * 100).toFixed(1) || 'N/A'}% | Standard Downs Success: ${(stats.offense?.standardDowns?.successRate * 100).toFixed(1) || 'N/A'}%
        - Power Success: ${(stats.offense?.powerSuccess * 100).toFixed(1) || 'N/A'}% | Points Per Opportunity: ${stats.offense?.pointsPerOpportunity?.toFixed(2) || 'N/A'}
        - Avg. Field Position: ${stats.offense?.fieldPosition?.averageStart?.toFixed(1) || 'N/A'}`;
                };

                const homeStatsPrevBlock = createStatsBlock(homeStatsPrev, homeData.name);
                const awayStatsPrevBlock = createStatsBlock(awayStatsPrev, awayData.name);
                const homeStatsCurrentBlock = createStatsBlock(homeStatsCurrent, homeData.name);
                const awayStatsCurrentBlock = createStatsBlock(awayStatsCurrent, awayData.name);

                const previousSeasonStatsSection = (homeStatsPrevBlock || awayStatsPrevBlock) ? `\n**ADVANCED STATS (PREVIOUS SEASON - ${previousYear}):**${homeStatsPrevBlock}${awayStatsPrevBlock}` : '';
                const currentSeasonStatsSection = (homeStatsCurrentBlock || awayStatsCurrentBlock) ? `\n**ADVANCED STATS (CURRENT SEASON - ${currentYear}):**${homeStatsCurrentBlock}${awayStatsCurrentBlock}` : '';
                const currentSeasonRecordSection = (homeRecordCurrent || awayRecordCurrent) ? `\n**CURRENT SEASON DATA (${currentYear}):**\n-   **${homeData.name} Record:** ${homeRecordCurrent ? `${homeRecordCurrent.total.wins}-${homeRecordCurrent.total.losses}` : 'N/A'}\n-   **${awayData.name} Record:** ${awayRecordCurrent ? `${awayRecordCurrent.total.wins}-${awayRecordCurrent.total.losses}` : 'N/A'}` : '';
                const currentSPSection = (homeSP?.rating && awaySP?.rating) ? `\n-   **SP+ Ratings (${currentYear} PRE-SEASON):**\n    -   **${homeData.name}:** ${homeSP.rating?.toFixed(1)} (Overall), ${homeSP.offense?.rating?.toFixed(1)} (Off), ${homeSP.defense?.rating?.toFixed(1)} (Def), ${homeSP.specialTeams?.rating?.toFixed(1)} (ST)\n    -   **${awayData.name}:** ${awaySP.rating?.toFixed(1)} (Overall), ${awaySP.offense?.rating?.toFixed(1)} (Off), ${awaySP.defense?.rating?.toFixed(1)} (Def), ${awaySP.specialTeams?.rating?.toFixed(1)} (ST)` : '';
                const previousSPSection = (homeSPPrev?.rating && awaySPPrev?.rating) ? `\n-   **SP+ Ratings (${previousYear} FINAL):**\n    -   **${homeData.name}:** ${homeSPPrev.rating?.toFixed(1)} (Overall), ${homeSPPrev.offense?.rating?.toFixed(1)} (Off), ${homeSPPrev.defense?.rating?.toFixed(1)} (Def), ${homeSPPrev.specialTeams?.rating?.toFixed(1)} (ST)\n    -   **${awayData.name}:** ${awaySPPrev.rating?.toFixed(1)} (Overall), ${awaySPPrev.offense?.rating?.toFixed(1)} (Off), ${awaySPPrev.defense?.rating?.toFixed(1)} (Def), ${awaySPPrev.specialTeams?.rating?.toFixed(1)} (ST)` : '';
                
                let instructions;
                switch(analysisType) {
                    case 'consensus':
                        instructions = `\n### Game Synopsis\nUsing all the data provided, write a brief, data-driven synopsis of the matchup. Synthesize data on key strengths and weaknesses based on SP+ ratings, advanced stats, and talent.\n---\n### AI-Powered Prediction\nPredict the most likely winner of the game. Weigh all factors: SP+ ratings, advanced stats, talent scores, returning production, head-to-head results, and injuries. Declare a clear winner and justify your prediction with specific data points. \n${confidenceRubric}`;
                        break;
                    case 'matchup':
                        instructions = `\n### Key Matchup Analysis\nIdentify the single most important positional or schematic battle that will decide this game (e.g., Home Team's passing offense vs. Away Team's pass defense, or Away Team's defensive line vs. Home Team's offensive line). Justify your choice using specific data points provided, such as PPA, Success Rates, Havoc Rates, or Line Yards.\n---\n### Strategic Prediction\nBased on your analysis of the key matchup above, predict the winner of the game. Explain how the team with the advantage in that specific matchup will leverage it to control the game and secure a victory.\n${confidenceRubric}`;
                        break;
                    case 'no-spread':
                        instructions = `\n### Pre-Game Narrative\nWrite a compelling, data-driven pre-game narrative. Weave in pre-season expectations (talent, returning production), SP+ ratings, historical matchups, and any available in-season performance data. Integrate news snippets and injury reports for context.\n---\n### Analyst's Pick\nPerform a deeper analysis to determine the likely winner. Analyze factors like SP+ ratings, key statistical mismatches (PPA, success rates), returning production, talent, and injuries. Clearly state your pick and provide a step-by-step justification referencing the provided data.\n${confidenceRubric}`;
                        break;
                }

                return `You are an expert college football analyst. Your task is to generate a two-part analysis for the upcoming game using detailed data.
**Format your entire response using Markdown.** This includes using headings, bold/italic text, and lists to structure your analysis for readability.
**Crucially, you must only use the data provided below in your analysis. Do not invent or infer any statistics not present in the data.**
**Use the "Key Player Accolades" data, especially the pre-season watchlists, to identify elite, game-changing talent that might not be fully captured by team-level stats.**
${seasonalWeightingInstructions}
${marketAndModelInstructions}
**DATA DEFINITIONS:**
- **PPA (Predicted Points Added):** Measures points added/prevented vs. average. Higher is better for offense, lower for defense.
- **Success Rate:** Percentage of "successful" plays (gaining 50% of needed yards on 1st down, 70% on 2nd, 100% on 3rd/4th). Higher is better for offense, lower for defense.
- **Explosiveness:** Measures the magnitude of successful plays.
- **Power Success Rate:** Percentage of successful runs on 3rd/4th and short. Measures short-yardage rushing ability.
- **Stuff Rate:** Percentage of runs stopped at or behind the line of scrimmage. Measures defensive line dominance.
- **Havoc Rate:** Percentage of plays where the defense records a TFL, forced fumble, pass breakup, or interception.
- **Points Per Opportunity (PPO):** Average points scored on drives that cross the opponent's 40-yard line.
- **Line Yards:** Avg. rushing yards attributed to the offensive line (0-5 yards past LOS).
- **Second Level Yards:** Avg. rushing yards gained 5-10 yards past the LOS.
- **Open Field Yards:** Avg. rushing yards gained 10+ yards past the LOS. Measures an offense's ability to create explosive "home run" plays.
- **Front Seven Havoc:** Percentage of plays where the defensive line or linebackers record a TFL, forced fumble, or pass breakup. Measures disruption at and behind the line of scrimmage.
- **Avg. Starting Field Position:** The average starting yard line for an offense.
- **SP+ Rating:** A tempo- and opponent-adjusted measure of college football efficiency. It is a predictive measure of future performance.
- **Special Teams SP+ Rating:** The SP+ rating for the team's special teams unit.
- **Total Returning Production (%):** The overall percentage of the team's production returning from the previous season.
**CONTEXTUAL DATA:**
-   **Game Date & Time:** ${gameDateTime}
-   **Matchup:** ${awayData.name} at ${homeData.name}
-   **Coaching Matchup:**
    -   **${homeData.name}:** ${formatCoachData(homeCoachData)}
    -   **${awayData.name}:** ${formatCoachData(awayCoachData)}
-   **Market & Model Predictions:**
    -   **Consensus Game Total:** ${bettingLines?.lines?.[0]?.overUnder || 'N/A'}
    -   **PPA Model Win Probability:** ${winProbability ? `${winProbability.homeTeam === homeData.name ? homeData.name : awayData.name} ${(winProbability.winProbability * 100).toFixed(1)}%` : 'N/A'}
-   **AI-Generated News Summary:**
${newsSummary}
**SCOUTING REPORT: NOTABLE PLAYERS**
- **${homeData.name}:**
${homeNotablePlayers}
- **${awayData.name}:**
${awayNotablePlayers}
-   **Head-to-Head (Last 5 Years):** - ${formatHeadToHead(headToHead)}${currentSPSection}${previousSPSection}
-   **Key Injuries:**
    -   **${homeData.name}:** ${formatInjuries(homeInjuries)}
    -   **${awayData.name}:** ${formatInjuries(awayInjuries)}
**PRE-SEASON DATA (Based on ${previousYear} Season):**
-   **${homeData.name}:**
    -   **Record:** ${homeData.record}
    -   **Composite Talent Score (${currentYear}):** ${homeData.talentScore}
    -   **Total Returning Production:** ${(homeData.returningProduction?.percentPPA * 100).toFixed(1) || 'N/A'}%
-   **${awayData.name}:**
    -   **Record:** ${awayData.record}
    -   **Composite Talent Score (${currentYear}):** ${awayData.talentScore}
    -   **Total Returning Production:** ${(awayData.returningProduction?.percentPPA * 100).toFixed(1) || 'N/A'}%
-   **Key Player Accolades:**
    -   **${homeData.name} (${previousYear} Post-Season Honors):** ${homeKeyPlayersData.postSeasonHonors}
    -   **${homeData.name} (${currentYear} Pre-Season Watchlists):** ${homeKeyPlayersData.preSeasonWatchlist}
    -   **${awayData.name} (${previousYear} Post-Season Honors):** ${awayKeyPlayersData.postSeasonHonors}
    -   **${awayData.name} (${currentYear} Pre-Season Watchlists):** ${awayKeyPlayersData.preSeasonWatchlist}${currentSeasonRecordSection}${previousSeasonStatsSection}${currentSeasonStatsSection}
---
${instructions}`;
            }

            function buildConsensusPrompt(analyses, homeTeam, awayTeam) {
                const analysisSection = analyses.map((analysis, index) => `\n---\n### Analyst Report ${index + 1}\n${analysis}`).join('');
                const taskDescription = 'determine the most likely winner';
                return `You are a lead college football analyst. You have received three independent analyses from your team regarding the upcoming game between ${awayTeam} and ${homeTeam}. Your task is to synthesize these reports into a single, definitive consensus prediction.
**Your instructions are:**
1.  **Review all three analyst reports provided below.**
2.  **Identify the majority opinion.** Based on the reports, ${taskDescription}.
3.  **Synthesize Everything:** Weigh all inputs, giving significant weight to any high-confidence or very-high-confidence picks. If the AI reports and saved picks are aligned, create a confident, summary conclusion. If they conflict, highlight the disagreement and make a final judgment call, explaining why you are siding with one perspective over the other (e.g., "Siding with the high-confidence pick despite one conflicting AI analysis).
4.  **Formulate a final confidence score.** Based on the confidence levels expressed in the individual reports and the level of agreement, assign a final consensus confidence score (Low, Medium, High, Very High).
5.  **Write the Consensus Report.** Structure your response using Markdown with the following two sections:
    -   **### Consensus Synopsis:** A brief summary of the matchup, integrating the common themes from the analyst reports.
    -   **### Consensus Prediction:** Clearly state the consensus pick, the final confidence score, and a justification that synthesizes the strongest arguments from the provided analyses.
**Do not introduce any new data or opinions. Your entire response must be based solely on the three analyst reports provided.**
**Crucially, you must end your prediction with the final pick on its own, separate line, in the exact format: **Team Name** (Confidence: Level)**${analysisSection}`;
            }

            function buildFinalAnalysisPrompt(analyses, userPicks, homeTeam, awayTeam) {
                const analysisSection = Object.entries(analyses).map(([type, text]) => `\n---\n### ${type.replace('-', ' ')} Analysis\n${text}`).join('');
                const userPicksSection = Object.entries(userPicks).map(([type, pick]) => `- **${type.replace('-', ' ')} Pick:** ${pick.team} (Confidence: ${pick.confidence})`).join('\n');
                
                return `You are a master college football analyst. Your task is to synthesize three different AI-generated consensus reports and the user's own saved picks to produce one final, ultimate recommendation for the game between ${awayTeam} and ${homeTeam}.
**Your instructions are:**
1.  **Review the three AI reports:** "Winner Prediction," "Matchup Breakdown," and "Game Analysis." Note their conclusions and key arguments.
2.  **Review the User's Picks:** Pay close attention to the user's selected team and their confidence level for each of the three analysis types. This represents the user's own judgment after reading the initial reports.
3.  **Synthesize Everything:** Weigh all inputs, giving significant weight to any high-confidence or very-high-confidence picks. If the AI reports and saved picks are aligned, create a confident, summary conclusion. If they conflict, highlight the disagreement and make a final judgment call, explaining why you are siding with one perspective over the other (e.g., "Siding with the high-confidence pick despite one conflicting AI analysis...").
4.  **Formulate a Final Pick and Confidence:** Declare a final pick for the winner and a final confidence score (Low, Medium, High, Very High).
5.  **Write the Final Report:** Structure your response using Markdown with the following two sections:
    -   **### Final Synopsis:** Briefly summarize the different analytical perspectives and the user's inputs.
    -   **### Final Recommendation:** Clearly state your final pick, the final confidence score, and a concise justification for your decision, explaining how you synthesized the provided information.
**You must base your entire response on the provided reports and user picks.**
**Crucially, you must end your recommendation with the final pick on its own, separate line, in the exact format: **Team Name** (Confidence: Level)**
${analysisSection}
---
### User's Saved Picks
${userPicksSection}`;
            }

            // --- Event Handling & Analysis Logic ---
            async function handleAnalysisClick(button, forceRefresh = false) {
                const allButtonsInRow = button.closest('li')?.querySelectorAll('button');
                if(allButtonsInRow) allButtonsInRow.forEach(el => { el.disabled = true; });

                const gameId = button.dataset.gameId;
                const homeTeam = button.dataset.homeTeam;
                const awayTeam = button.dataset.awayTeam;
                const spread = button.dataset.spread;
                const commenceTime = button.dataset.commenceTime;
                const analysisType = button.dataset.analysisType;

                let analysisTitle = "Analysis";
                if(analysisType === 'consensus') analysisTitle = 'Winner Prediction';
                if(analysisType === 'matchup') analysisTitle = 'Matchup Breakdown';
                if(analysisType === 'no-spread') analysisTitle = 'Game Analysis';
                
                const savedAnalysisPackage = savedAnalysesCache.get(`${gameId}_${analysisType}`);
                if (savedAnalysisPackage && !forceRefresh) {
                    displayNarrative(savedAnalysisPackage.analysisText, { gameId, homeTeam, awayTeam, commenceTime, analysisType, spread }, savedAnalysisPackage.rawData, analysisTitle, savedAnalysisPackage.consensusPrompt);
                    if(allButtonsInRow) allButtonsInRow.forEach(el => { el.disabled = false; });
                    return;
                }

                showModalLoadingState({ homeTeam, awayTeam, analysisType: analysisTitle });
                narrativeModal.classList.remove('hidden');
                clearError();

                try {
                    const currentYear = new Date().getFullYear();
                    const previousYear = currentYear - 1;
                    
                    updateModalStatus('Fetching current week...');
                    const currentWeek = await fetchCurrentWeek();

                    updateModalStatus('Gathering team data...');
                    const homeData = await fetchTeamData(homeTeam);
                    const awayData = await fetchTeamData(awayTeam);
                    
                    const [homeRecordCurrent, awayRecordCurrent, headToHeadData, homeSP, awaySP, homeSPPrev, awaySPPrev, homeInjuries, awayInjuries, homeStatsPrev, awayStatsPrev, homeStatsCurrent, awayStatsCurrent, newsArticles, homeKeyPlayersData, awayKeyPlayersData, homeCoachData, awayCoachData, bettingLines, winProbability] = await Promise.all([
                        Promise.resolve(recordsCache[currentYear]?.[homeData.name] || null), Promise.resolve(recordsCache[currentYear]?.[awayData.name] || null),
                        fetchHeadToHead(homeData.name, awayData.name), fetchSPRatings(homeData.name, currentYear), fetchSPRatings(awayData.name, currentYear),
                        fetchSPRatings(homeData.name, previousYear), fetchSPRatings(awayData.name, previousYear),
                        fetchInjuries(homeData.name), fetchInjuries(awayData.name),
                        fetchAdvancedSeasonStats(homeData.name, previousYear), fetchAdvancedSeasonStats(awayData.name, previousYear),
                        fetchAdvancedSeasonStats(homeData.name, currentYear), fetchAdvancedSeasonStats(awayData.name, currentYear),
                        fetchGameNews(`"${homeData.name}" vs "${awayData.name}" football`),
                        fetchKeyPlayersData(homeData.name), 
                        fetchKeyPlayersData(awayData.name),
                        fetchCoachData(homeData.name), 
                        fetchCoachData(awayData.name),
                        fetchBettingLines(homeData.name, awayData.name),
                        fetchWinProbability(homeData.name, awayData.name)
                    ]);

                    const headToHead = headToHeadData?.games || [];
                    updateModalStatus('Summarizing news...');
                    const { summary: newsSummary, prompt: newsSummaryPrompt } = await summarizeNews(newsArticles, homeData.name, awayData.name);
                    
                    const allDataForScouting = { newsSummary, homeData, awayData, homeStatsPrev, awayStatsPrev, homeStatsCurrent, awayStatsCurrent, homeInjuries, awayInjuries, homeKeyPlayersData, awayKeyPlayersData };
                    
                    updateModalStatus(`Scouting ${homeData.name}...`);
                    const homeNotablePlayersPrompt = buildNotablePlayersPrompt(homeData.name, awayData.name, allDataForScouting);
                    const homeNotablePlayers = await generateNarrative(homeNotablePlayersPrompt);

                    updateModalStatus(`Scouting ${awayData.name}...`);
                    const awayNotablePlayersPrompt = buildNotablePlayersPrompt(awayData.name, homeData.name, allDataForScouting);
                    const awayNotablePlayers = await generateNarrative(awayNotablePlayersPrompt);

                    const gameDateTime = new Date(commenceTime).toLocaleString('en-US', { dateStyle: 'full', timeStyle: 'short' });
                    const gameDetails = { gameDateTime, spread, newsSummary };
                    
                    const mainAnalysisPrompt = buildPrompt(gameDetails, homeData, awayData, homeStatsPrev, awayStatsPrev, homeStatsCurrent, awayStatsCurrent, headToHead, homeSP, awaySP, homeSPPrev, awaySPPrev, homeInjuries, awayInjuries, analysisType, homeRecordCurrent, awayRecordCurrent, homeKeyPlayersData, awayKeyPlayersData, currentWeek, homeCoachData, awayCoachData, bettingLines, winProbability, homeNotablePlayers, awayNotablePlayers);

                    const individualAnalyses = [];
                    for (let i = 0; i < 3; i++) {
                        updateModalStatus(`Running Analysis ${i + 1} of 3...`);
                        individualAnalyses.push(await generateNarrative(mainAnalysisPrompt));
                    }

                    updateModalStatus('Synthesizing results...');
                    const consensusPrompt = buildConsensusPrompt(individualAnalyses, homeTeam, awayTeam);
                    const consensusNarrative = await generateNarrative(consensusPrompt);
                    
                    const rawData = { homeData, awayData, headToHead, homeSP, awaySP, homeSPPrev, awaySPPrev, homeStatsPrev, awayStatsPrev, homeInjuries, awayInjuries, newsArticles, newsSummary, newsSummaryPrompt, mainAnalysisPrompt, homeRecordCurrent, awayRecordCurrent, homeStatsCurrent, awayStatsCurrent, individualAnalyses, homeKeyPlayersData, awayKeyPlayersData, homeCoachData, awayCoachData, bettingLines, winProbability, homeNotablePlayers, awayNotablePlayers };
                    const analysisPackage = { analysisText: consensusNarrative, rawData, consensusPrompt };

                    if (user) {
                        await saveAnalysis(gameId, analysisType, analysisPackage);
                        savedAnalysesCache.set(`${gameId}_${analysisType}`, analysisPackage);
                        await parseAndSavePick(consensusNarrative, gameId, analysisType, homeTeam, awayTeam);
                        if(allButtonsInRow) {
                            const originalButton = Array.from(allButtonsInRow).find(b => b.dataset.analysisType === analysisType);
                            if (originalButton && !originalButton.textContent.includes('‚úì')) originalButton.textContent += ' ‚úì';
                        }
                    }
                    
                    displayNarrative(consensusNarrative, { gameId, homeTeam, awayTeam, commenceTime, analysisType, spread }, rawData, analysisTitle, consensusPrompt);

                } catch (error) {
                    console.error("Analysis generation failed:", error);
                    narrativeModal.classList.add('hidden');
                    showError(`Could not generate analysis. ${error.message}`);
                } finally {
                     if(allButtonsInRow) allButtonsInRow.forEach(el => { el.disabled = false; });
                }
            }
            
            async function handleFinalAnalysisClick(button, forceRefresh = false) {
                const allButtonsInRow = button.closest('li')?.querySelectorAll('button');
                if(allButtonsInRow) allButtonsInRow.forEach(el => { el.disabled = true; });

                const gameId = button.dataset.gameId;
                const homeTeam = button.dataset.homeTeam;
                const awayTeam = button.dataset.awayTeam;
                const analysisType = 'final';

                const savedAnalysisPackage = savedAnalysesCache.get(`${gameId}_${analysisType}`);
                if (savedAnalysisPackage && !forceRefresh) {
                    displayNarrative(savedAnalysisPackage.analysisText, { gameId, homeTeam, awayTeam, commenceTime: new Date().toISOString(), analysisType, spread: button.dataset.spread }, savedAnalysisPackage.rawData, 'Final Analysis', savedAnalysisPackage.prompt);
                    if(allButtonsInRow) allButtonsInRow.forEach(el => { el.disabled = false; });
                    return;
                }
                
                showModalLoadingState({ homeTeam, awayTeam, analysisType: 'Final Analysis' });
                narrativeModal.classList.remove('hidden');
                clearError();

                try {
                    updateModalStatus('Fetching saved analyses...');
                    const savedAnalyses = await getSavedAnalyses(gameId);
                    if (!savedAnalyses.consensus || !savedAnalyses.matchup || !savedAnalyses['no-spread']) {
                        throw new Error("One or more required analyses are missing.");
                    }

                    const userPicks = {
                        'Winner-Prediction': gamePicks.get(`${gameId}_consensus`),
                        'Matchup-Breakdown': gamePicks.get(`${gameId}_matchup`),
                        'Game-Analysis': gamePicks.get(`${gameId}_no-spread`),
                    };

                    updateModalStatus('Generating final synthesis...');
                    const prompt = buildFinalAnalysisPrompt(savedAnalyses, userPicks, homeTeam, awayTeam);
                    const finalNarrative = await generateNarrative(prompt);
                    
                    const analysisPackage = { analysisText: finalNarrative, rawData: { individualAnalyses: Object.values(savedAnalyses) }, prompt };

                    if (user) {
                        await saveAnalysis(gameId, 'final', analysisPackage);
                        savedAnalysesCache.set(`${gameId}_${analysisType}`, analysisPackage);
                        await parseAndSavePick(finalNarrative, gameId, analysisType, homeTeam, awayTeam);
                         if(allButtonsInRow) {
                            const originalButton = Array.from(allButtonsInRow).find(b => b.dataset.analysisType === analysisType);
                            if (originalButton && !originalButton.textContent.includes('‚úì')) originalButton.textContent += ' ‚úì';
                        }
                    }

                    displayNarrative(finalNarrative, { gameId, homeTeam, awayTeam, commenceTime: new Date().toISOString(), analysisType, spread: button.dataset.spread }, analysisPackage.rawData, 'Final Analysis', prompt);

                } catch (error) {
                    console.error("Final analysis generation failed:", error);
                    narrativeModal.classList.add('hidden');
                    showError(`Could not generate final analysis. ${error.message}`);
                } finally {
                    if(allButtonsInRow) allButtonsInRow.forEach(el => { el.disabled = false; });
                }
            }

            gamesList.addEventListener('click', async (e) => {
                const button = e.target.closest('button');
                if (!button) return;
                if (button.classList.contains('analysis-btn')) handleAnalysisClick(button);
                else if (button.classList.contains('final-analysis-btn')) handleFinalAnalysisClick(button);
            });

            // --- Firebase & Automation Functions ---
            async function parseAndSavePick(narrativeText, gameId, analysisType, homeTeam, awayTeam) {
                if (!user) return;

                const regex = new RegExp(`\\*\\*(?<team>.+?)\\*\\*\\s*\\(Confidence:\\s*(?<confidence>Low|Medium|High|Very High)\\)`, "im");
                const match = narrativeText.match(regex);

                if (match && match.groups) {
                    let { team, confidence } = match.groups;
                    
                    let finalTeamName = team.trim();
                    if (homeTeam.includes(finalTeamName)) {
                        finalTeamName = homeTeam;
                    } else if (awayTeam.includes(finalTeamName)) {
                        finalTeamName = awayTeam;
                    }
                    
                    console.log(`Auto-saving pick for ${analysisType}: ${finalTeamName} with ${confidence} confidence.`);
                    
                    const pickKey = `${gameId}_${analysisType}`;
                    gamePicks.set(pickKey, { team: finalTeamName, confidence });

                    await saveGamePicks();
                    updatePickDisplayOnCard(gameId, analysisType, finalTeamName, confidence);
                } else {
                    console.warn(`Could not automatically parse pick for game ${gameId}, type ${analysisType}. No match found in text.`);
                }
            }
            
            function updatePickDisplayOnCard(gameId, analysisType, team, confidence) {
                const gameItem = document.querySelector(`.game-item[data-game-id="${gameId}"]`);
                if (!gameItem) return;

                const button = gameItem.querySelector(`[data-analysis-type="${analysisType}"]`);
                if (button && !button.textContent.includes('‚úì')) button.textContent += ' ‚úì';

                const pickDisplayContainer = gameItem.querySelector('.pick-display');
                let pickElement = pickDisplayContainer.querySelector(`[data-pick-type="${analysisType}"]`);
                if (!pickElement) {
                    pickElement = document.createElement('div');
                    pickElement.className = `text-xs mt-1 ${analysisType === 'final' ? 'text-green-400 font-bold' : 'text-yellow-400'}`;
                    pickElement.dataset.pickType = analysisType;
                    pickDisplayContainer.appendChild(pickElement);
                }
                let label = '';
                switch(analysisType) {
                    case 'consensus': label = 'Predict Winner:'; break;
                    case 'matchup': label = 'Matchup Breakdown:'; break;
                    case 'no-spread': label = 'Analyze Game:'; break;
                    case 'final': label = 'Final Analysis:'; break;
                }
                pickElement.textContent = `${label} ${team} (Confidence: ${confidence})`;

                const consensusPick = gamePicks.get(`${gameId}_consensus`);
                const matchupPick = gamePicks.get(`${gameId}_matchup`);
                const noSpreadPick = gamePicks.get(`${gameId}_no-spread`);
                if (consensusPick && matchupPick && noSpreadPick) {
                    const finalBtn = gameItem.querySelector('.final-analysis-btn');
                    if (finalBtn) finalBtn.classList.remove('hidden');
                }
            }
            
            async function saveGamePicks() {
                if (!user) return;
                const userDocRef = doc(db, "users", user.uid);
                const picksObject = Object.fromEntries(gamePicks);
                await setDoc(userDocRef, { gamePicks: picksObject }, { merge: true });
            }
            
            async function loadGamePicks() {
                if (!user) return;
                const userDocRef = doc(db, "users", user.uid);
                const docSnap = await getDoc(userDocRef);
                if (docSnap.exists() && docSnap.data().gamePicks) {
                    gamePicks = new Map(Object.entries(docSnap.data().gamePicks));
                } else {
                    gamePicks = new Map();
                }
            }
            
            async function loadSavedAnalyses() {
                if (!user) return;
                savedAnalysesCache.clear();
                const analysesRef = collection(db, "game_analyses");
                const q = query(analysesRef, where("userId", "==", user.uid));
                const querySnapshot = await getDocs(q);
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    if (data.analysisPackage) {
                         savedAnalysesCache.set(`${data.gameId}_${data.analysisType}`, data.analysisPackage);
                    } else if (data.analysisText) { // Backward compatibility
                        const backwardCompatiblePackage = {
                            analysisText: data.analysisText,
                            rawData: {},
                            consensusPrompt: "Prompt not available for this legacy analysis."
                        };
                        savedAnalysesCache.set(`${data.gameId}_${data.analysisType}`, backwardCompatiblePackage);
                    }
                });
            }

            async function saveAnalysis(gameId, analysisType, analysisPackage) {
                if (!user) return;
                try {
                    const analysesRef = collection(db, "game_analyses");
                    const q = query(analysesRef, where("userId", "==", user.uid), where("gameId", "==", gameId), where("analysisType", "==", analysisType));
                    const querySnapshot = await getDocs(q);
                    const dataToSave = { 
                        userId: user.uid, 
                        gameId: gameId, 
                        analysisType: analysisType, 
                        analysisPackage: analysisPackage, 
                        createdAt: new Date() 
                    };

                    if (querySnapshot.empty) {
                        await addDoc(analysesRef, dataToSave);
                    } else {
                        const docRef = doc(db, "game_analyses", querySnapshot.docs[0].id);
                        await setDoc(docRef, dataToSave, { merge: true });
                    }
                } catch (error) {
                    console.error("Error saving analysis to Firestore:", error);
                }
            }

            async function getSavedAnalyses(gameId) {
                if (!user) return {};
                const analyses = {};
                const analysesRef = collection(db, "game_analyses");
                const q = query(analysesRef, where("userId", "==", user.uid), where("gameId", "==", gameId));
                const querySnapshot = await getDocs(q);
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    if (data.analysisPackage) {
                        analyses[data.analysisType] = data.analysisPackage.analysisText;
                    } else if (data.analysisText) { // Backward compatibility
                        analyses[data.analysisType] = data.analysisText;
                    }
                });
                return analyses;
            }

            function updateUserProfile() {
                if (user) {
                    userProfileContainer.innerHTML = `<img src="${user.photoURL}" alt="User" class="w-10 h-10 rounded-full mr-4"><button id="sign-out-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md transition">Sign Out</button>`;
                    document.getElementById('sign-out-btn').addEventListener('click', () => signOut(auth));
                } else {
                    userProfileContainer.innerHTML = `<button id="sign-in-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition">Sign In with Google</button>`;
                    document.getElementById('sign-in-btn').addEventListener('click', () => signInWithPopup(auth, new GoogleAuthProvider()));
                }
            }

            init();
        });
    </script>
</body>
</html>
