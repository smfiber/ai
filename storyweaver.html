<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Story Weaver</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- html-to-image library for PNG export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html-to-image/1.11.11/html-to-image.min.js" xintegrity="sha512-7tWCg0J26Mk+c9J3nZq+pKS2i/Jq2K3QdDaeI2o2PzMA+d4wWd/6TqL/iUnKxYIIm9D6McV2Rk1Ts1A/1S/2w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <!-- interact.js for drag, resize, rotate -->
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <style>
        /* Embedded Google Fonts to prevent CORS issues with html-to-image */
        @font-face {
          font-family: 'Inter';
          font-style: normal;
          font-weight: 400;
          font-display: swap;
          src: url(https://fonts.gstatic.com/s/inter/v13/UcC73FwrK3iLTeHuS_fvQtMwCp50KnMa1ZL7W0Q5nw.woff2) format('woff2');
        }
         @font-face {
            font-family: 'Dancing Script';
            src: url(https://fonts.gstatic.com/s/dancingscript/v25/If2cXTr6YS-zF4S-kcSWSVi_sxjsohD9F50Ruu7BMg.woff2) format('woff2');
        }
        @font-face {
            font-family: 'Lobster';
            src: url(https://fonts.gstatic.com/s/lobster/v30/neILzCirqoswsqX9_oU-pA.woff2) format('woff2');
        }
         @font-face {
            font-family: 'Pacifico';
            src: url(https://fonts.gstatic.com/s/pacifico/v22/FwZY7-Qmy14u9lezJ-6H6MmBpA.woff2) format('woff2');
        }
        @font-face {
            font-family: 'Great Vibes';
            src: url(https://fonts.gstatic.com/s/greatvibes/v15/6q1c0ofG6NKsEhAc2eh-3Y4v_w.woff2) format('woff2');
        }
        @font-face {
            font-family: 'Sacramento';
            src: url(https://fonts.gstatic.com/s/sacramento/v11/buEzpo6gcdjy0EiZMBUG0CoV_w.woff2) format('woff2');
        }


        body { font-family: 'Inter', sans-serif; }

        .story-paragraph-wrapper { opacity: 0; transform: translateY(20px); animation: fadeIn 0.5s ease-out forwards; }
        @keyframes fadeIn { to { opacity: 1; transform: translateY(0); } }
        .user-paragraph { background-image: linear-gradient(to right, #374151, #2f3743); }
        .ai-paragraph { background-image: linear-gradient(to left, #1e293b, #1a222f); }
        .insight-paragraph { background-image: linear-gradient(to left, #0f766e, #134e4a); color: #f0fdfa; }
        .error-paragraph, .system-message-paragraph { align-self: center; text-align: center; padding: 1rem; border-radius: 0.5rem; font-weight: bold; max-width: 80%; }
        .error-paragraph { background-color: #dc2626; color: #fee2e2; }
        .system-message-paragraph { background-color: #374151; color: #a78bfa; white-space: pre-wrap; }
        #story-container::-webkit-scrollbar, textarea::-webkit-scrollbar, #instructions-modal-content::-webkit-scrollbar { width: 8px; }
        #story-container::-webkit-scrollbar-track, textarea::-webkit-scrollbar-track, #instructions-modal-content::-webkit-scrollbar-track { background: #1f2937; }
        #story-container::-webkit-scrollbar-thumb, textarea::-webkit-scrollbar-thumb, #instructions-modal-content::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        #story-container::-webkit-scrollbar-thumb:hover, textarea::-webkit-scrollbar-thumb:hover, #instructions-modal-content::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        .illustration-container { margin-bottom: 1rem; position: relative; width: 100%; padding-top: 56.25%; /* 16:9 Aspect Ratio */ border-radius: 0.5rem; overflow: hidden; }
        .illustration-container img, .illustration-container .loading-placeholder { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }

        /* Styles for the interactive text overlay */
        .resizable-text-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            min-height: 50px;
            width: 70%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            background-color: rgba(0,0,0,0.5);
            border: 2px dashed #fff;
            border-radius: 0.5rem;
            color: white;
            touch-action: none; /* prevent default browser actions */
            box-sizing: border-box;
            cursor: move;
            z-index: 10;
        }
        .resizable-text-box.hide-borders {
            border: none;
            background-color: transparent;
        }
        .resizable-text-box p {
            width: 100%;
            height: 100%;
            margin: 0;
            overflow: hidden;
            text-align: center;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body class="bg-gray-900 text-white h-full flex items-center justify-center p-4 antialiased">
    <div id="app-container" class="w-full max-w-5xl h-[95vh] flex flex-col bg-gray-800 rounded-2xl shadow-2xl p-4 sm:p-6">
        <!-- Header Section -->
        <header class="flex flex-col sm:flex-row justify-between items-start w-full mb-4 pb-4 border-b border-gray-700">
            <div class="flex-shrink-0 mr-6">
                <h1 class="text-xl font-bold text-white flex items-baseline gap-2">
                    AI Story Weaver
                    <span id="version-number" class="text-xs font-mono bg-gray-700 px-2 py-1 rounded">1.95</span>
                    <button id="help-icon" title="How to Use">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-question-circle text-gray-400 hover:text-white" viewBox="0 0 16 16">
                            <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                            <path d="M5.255 5.786a.237.237 0 0 0 .241.247h.825c.138 0 .248-.113.266-.25.09-.656.54-1.134 1.342-1.134.686 0 1.314.343 1.314 1.168 0 .635-.374.927-.965 1.371-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486.609-.463 1.244-.977 1.244-2.056 0-1.511-1.276-2.241-2.673-2.241-1.267 0-2.655.59-2.75 2.286zm1.557 5.763c0 .533.425.927 1.01.927.609 0 1.028-.394 1.028-.927 0-.552-.42-.94-1.029-.94-.584 0-1.009.388-1.009.94z"/>
                        </svg>
                    </button>
                </h1>
                <p class="text-xs text-gray-400 mt-1 max-w-xs">Collaboratively write stories with an AI partner. Guide the narrative, add your own insights, and illustrate your scenes.</p>
            </div>
            
            <div class="flex-grow flex flex-col items-end gap-2 mt-4 sm:mt-0">
                <div class="flex flex-col sm:flex-row gap-4 w-full justify-end">
                    <div class="flex-1 min-w-[150px] max-w-xs">
                        <label for="persona-select" class="block mb-1 text-gray-400 text-sm">AI Persona:</label>
                        <select id="persona-select" class="w-full p-2 bg-gray-700 border border-gray-600 rounded-lg text-white text-base focus:ring-indigo-500 focus:border-indigo-500"></select>
                    </div>
                    <div class="flex-1 min-w-[150px] max-w-xs">
                        <label for="tone-select" class="block mb-1 text-gray-400 text-sm">Story Tone:</label>
                        <select id="tone-select" class="w-full p-2 bg-gray-700 border border-gray-600 rounded-lg text-white text-base focus:ring-indigo-500 focus:border-indigo-500"></select>
                    </div>
                     <div class="flex-1 min-w-[150px] max-w-xs">
                        <label for="image-style-select" class="block mb-1 text-gray-400 text-sm">Image Style:</label>
                        <select id="image-style-select" class="w-full p-2 bg-gray-700 border border-gray-600 rounded-lg text-white text-base focus:ring-indigo-500 focus:border-indigo-500"></select>
                    </div>
                     <div class="flex-1 min-w-[120px] max-w-xs">
                        <label for="sentence-length-select" class="block mb-1 text-gray-400 text-sm">Sentences:</label>
                        <select id="sentence-length-select" class="w-full p-2 bg-gray-700 border border-gray-600 rounded-lg text-white text-base focus:ring-indigo-500 focus:border-indigo-500"></select>
                    </div>
                </div>
                <div class="flex flex-col items-end gap-2 mt-2">
                    <!-- Row 1: Save buttons -->
                    <div class="flex flex-wrap justify-end gap-2">
                        <button id="save-story-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white text-xs py-1 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Save Story (HTML)</button>
                        <button id="save-weaver-btn" class="bg-gray-700 hover:bg-gray-600 text-white text-xs py-1 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Save Weaver</button>
                        <button id="save-prompts-btn" class="bg-gray-700 hover:bg-gray-600 text-white text-xs py-1 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Save Prompts</button>
                        <button id="save-lamination-btn" class="bg-green-600 hover:bg-green-700 text-white text-xs py-1 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Save Lamination</button>
                        <button id="save-last-content-btn" class="bg-teal-600 hover:bg-teal-700 text-white text-xs py-1 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Save Last Content</button>
                    </div>
                    <!-- Row 2: Action buttons -->
                    <div class="flex flex-wrap justify-end gap-2">
                         <button id="undo-btn" class="bg-gray-700 hover:bg-gray-600 text-white text-xs py-1 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Undo</button>
                         <button id="redo-btn" class="bg-gray-700 hover:bg-gray-600 text-white text-xs py-1 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Redo</button>
                         <button id="reset-story-btn" class="bg-red-700 hover:bg-red-600 text-white text-xs py-1 px-3 rounded-lg transition-colors">New Story</button>
                    </div>
                </div>
            </div>
        </header>

        <!-- Story Display Area -->
        <main id="story-container" class="flex-grow w-full min-h-0 overflow-y-auto p-4 space-y-6 flex flex-col"></main>
        
        <!-- User Input Area -->
        <footer class="mt-4 pt-4 border-t border-gray-700">
            <textarea id="prompt-input" class="w-full bg-gray-700 text-white rounded-lg p-3 focus:ring-2 focus:ring-indigo-500 focus:outline-none transition resize-none" rows="3" placeholder="Add the next part of the story..."></textarea>
            <div class="flex justify-end items-center mt-2 gap-4">
                 <button id="create-lamination-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    Create Lamination
                </button>
                 <button id="create-content-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                    Create Content
                </button>
                <button id="continue-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200 shadow-md hover:shadow-lg active:scale-95 flex items-center gap-2 disabled:bg-gray-500 disabled:cursor-not-allowed">
                    <span id="btn-text">Add to Story</span>
                    <svg id="loading-spinner" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </button>
            </div>
        </footer>
    </div>
    
    <!-- Instructions Modal -->
    <div id="instructions-modal" class="hidden fixed inset-0 bg-black/75 flex items-center justify-center p-4 z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-3xl h-[80vh] flex flex-col">
            <h2 class="text-2xl font-bold mb-4 text-white text-center">How to Use AI Story Weaver</h2>
            <div id="instructions-modal-content" class="flex-grow overflow-y-auto pr-4 text-gray-300 space-y-4">
                <div class="prose prose-invert">
                    <h3 class="font-semibold text-white">Core Controls</h3>
                    <ul class="list-disc pl-5 space-y-1">
                        <li><strong>Add to Story:</strong> Submits your text as a prompt for the AI to continue the narrative. This is the main way to build your story turn-by-turn.</li>
                        <li><strong>Create Content:</strong> Uses your text to generate various types of social media content (e.g., Quote Cards, Key Takeaways).</li>
                        <li><strong>Create Lamination:</strong> Takes the text in the prompt box and generates a single, shareable image with the text overlaid on a themed background.</li>
                    </ul>
                    <h3 class="font-semibold text-white mt-4">Creative Direction</h3>
                    <ul class="list-disc pl-5 space-y-1">
                        <li><strong>AI Persona:</strong> Choose the AI's personality. This sets the overall narrative style and voice. Changing this will start a new story.</li>
                        <li><strong>Story Tone:</strong> Select the emotional mood of the AI's writing. Changing this will also start a new story.</li>
                        <li><strong>Image Style:</strong> Pick an artistic style for the illustrations you generate.</li>
                        <li><strong>Sentences:</strong> Control the length of the AI's response (1-5 sentences, or Unlimited for a longer response).</li>
                    </ul>
                     <h3 class="font-semibold text-white mt-4">Editing & Refining</h3>
                    <ul class="list-disc pl-5 space-y-1">
                        <li><strong>Edit:</strong> Appears next to your prompts and insights. Click to modify your text.</li>
                        <li><strong>Regen:</strong> Appears next to AI-generated paragraphs. Click to ask the AI for a different response based on the same preceding text.</li>
                        <li><strong>Illustrate:</strong> Appears next to AI-generated paragraphs and your insights. Click to generate an image based on the text of that paragraph. You can re-click to get a new image.</li>
                         <li><strong>Undo/Redo:</strong> Step backward or forward through your story's history.</li>
                    </ul>
                     <h3 class="font-semibold text-white mt-4">Saving Your Work</h3>
                    <ul class="list-disc pl-5 space-y-1">
                        <li><strong>Save Story (HTML):</strong> Saves the full story, including dialogue and images, as a self-contained HTML file.</li>
                        <li><strong>Save Weaver:</strong> Saves the complete back-and-forth dialogue between you and the AI as a .txt file.</li>
                        <li><strong>Save Prompts:</strong> Saves only your prompts as a .txt file.</li>
                        <li><strong>Save Last Content:</strong> Saves the last piece of content you created (e.g., Quote Card, Key Takeaways) as a single PNG image.</li>
                        <li><strong>Save Lamination:</strong> Opens a dialog to save the current lamination as a 4-up sheet for printing or as a single full-size PNG for social media.</li>
                    </ul>
                     <h3 class="font-semibold text-white mt-4">Lamination Text Editing</h3>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>Once a lamination is created, a new set of controls appears.</li>
                        <li><strong>Font Family:</strong> Choose from a wide variety of fonts, including several cursive styles.</li>
                        <li><strong>Font Size:</strong> Select a size from a dropdown list.</li>
                        <li><strong>Font Color:</strong> Pick a custom color for your text.</li>
                        <li><strong>Styling:</strong> Toggle Bold, Italic, and Underline formatting.</li>
                        <li><strong>Interaction:</strong> You can drag, resize, and rotate the text box directly on the image to position it perfectly.</li>
                    </ul>
                </div>
            </div>
            <div class="flex justify-end mt-6">
                <button id="close-instructions-modal-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Lamination Save Options Modal -->
    <div id="lamination-save-modal" class="hidden fixed inset-0 bg-black/75 flex items-center justify-center p-4 z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm text-center">
            <h3 class="text-xl font-bold mb-4">Save Lamination As...</h3>
            <div class="flex justify-center gap-4">
                <button id="save-4up-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">4-Up Print Sheet</button>
                <button id="save-full-png-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg">Full Size PNG</button>
            </div>
             <button id="close-save-modal-btn" class="mt-6 text-sm text-gray-400 hover:text-white">Cancel</button>
        </div>
    </div>

    <!-- Content Format Selection Modal (New) -->
    <div id="content-format-modal" class="hidden fixed inset-0 bg-black/75 flex items-center justify-center p-4 z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-xl text-center">
            <h3 class="text-xl font-bold mb-4 text-white">Choose Content Format</h3>
            <div class="flex flex-wrap justify-center gap-4">
                <button id="format-quote-card-btn" class="format-btn bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition-colors">Quote Card</button>
                <button id="format-key-takeaways-btn" class="format-btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition-colors">Key Takeaways</button>
                <button id="format-inspirational-btn" class="format-btn bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-6 rounded-lg transition-colors">Inspirational</button>
            </div>
            <button id="close-content-format-modal-btn" class="mt-6 text-sm text-gray-400 hover:text-white">Cancel</button>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Element References ---
            const storyContainer = document.getElementById('story-container');
            const promptInput = document.getElementById('prompt-input');
            const continueBtn = document.getElementById('continue-btn');
            const createContentBtn = document.getElementById('create-content-btn'); // Renamed
            const createLaminationBtn = document.getElementById('create-lamination-btn');
            const btnText = document.getElementById('btn-text');
            const loadingSpinner = document.getElementById('loading-spinner');
            const personaSelect = document.getElementById('persona-select');
            const toneSelect = document.getElementById('tone-select');
            const imageStyleSelect = document.getElementById('image-style-select');
            const sentenceLengthSelect = document.getElementById('sentence-length-select');
            const resetStoryBtn = document.getElementById('reset-story-btn');
            const saveStoryBtn = document.getElementById('save-story-btn');
            const saveWeaverBtn = document.getElementById('save-weaver-btn');
            const savePromptsBtn = document.getElementById('save-prompts-btn');
            const saveLaminationBtn = document.getElementById('save-lamination-btn');
            const saveLastContentBtn = document.getElementById('save-last-content-btn'); // Renamed
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const helpIcon = document.getElementById('help-icon');
            const instructionsModal = document.getElementById('instructions-modal');
            const closeInstructionsModalBtn = document.getElementById('close-instructions-modal-btn');
            const laminationSaveModal = document.getElementById('lamination-save-modal');
            const save4UpBtn = document.getElementById('save-4up-btn');
            const saveFullPngBtn = document.getElementById('save-full-png-btn');
            const closeSaveModalBtn = document.getElementById('close-save-modal-btn');
            const contentFormatModal = document.getElementById('content-format-modal'); // New
            const closeContentFormatModalBtn = document.getElementById('close-content-format-modal-btn'); // New
            const formatQuoteCardBtn = document.getElementById('format-quote-card-btn'); // New
            const formatKeyTakeawaysBtn = document.getElementById('format-key-takeaways-btn'); // New
            const formatInspirationalBtn = document.getElementById('format-inspirational-btn'); // New


            // --- Application State ---
            const MAX_PROMPTS = 10;
            let isAITurn = false;
            let isEditing = false;
            let editingParagraphIndex = null;
            let currentPersonaIndex = 0;
            let currentToneIndex = 0;
            let currentImageStyleIndex = 0;
            let currentSentenceLength = 2;
            let isLaminationMode = false;
            let currentLaminationText = '';
            let lastGeneratedContentElement = null; // To store the element for "Save Last Content"

            let storyHistory = [];
            let historyStack = [];
            let historyPointer = -1;

            // --- Persona, Tone, Style & Length Data (Sorted) ---
             const personas = [
                { name: "The Hero/Heroine", systemPrompt: "You are The Hero/Heroine. Generate narrative from the perspective of a protagonist on a journey, facing challenges, and achieving a goal." },
                { name: "The Mentor/Sage", systemPrompt: "You are The Mentor/Sage. Generate narrative as a wise guide who offers advice, training, or magical aid to the hero." },
                { name: "The Villain/Antagonist", systemPrompt: "You are The Villain/Antagonist. Generate narrative as the opposing force, creating conflict and obstacles for the hero." },
                { name: "The Trickster", systemPrompt: "You are The Trickster. Generate narrative as a mischievous character who causes disruption, often for their own amusement or to teach a lesson." },
                { name: "The Innocent", systemPrompt: "You are The Innocent. Generate narrative as a pure, optimistic character who often serves as a moral compass or a source of wonder." },
                { name: "The Explorer", systemPrompt: "You are The Explorer. Generate narrative as a character driven by curiosity and a desire for discovery, often embarking on literal or metaphorical journeys." },
                { name: "The Lover", systemPrompt: "You are The Lover. Generate narrative focusing on themes of romance, intimacy, passion, and emotional connection." },
                { name: "The Rebel/Outlaw", systemPrompt: "You are The Rebel/Outlaw. Generate narrative as a character who challenges societal norms, authority, or established systems." },
                { name: "The Everyman/Everywoman", systemPrompt: "You are The Everyman/Everywoman. Generate narrative as a relatable, ordinary character whose struggles and triumphs reflect common human experiences." },
                { name: "The Caregiver", systemPrompt: "You are The Caregiver. Generate narrative as a nurturing, protective, and compassionate character, often putting others' needs before their own." },
                { name: "The Lore Master/World-Builder", systemPrompt: "You are The Lore Master/World-Builder. Your role is to help users develop intricate world details, histories, and background lore for their stories." },
                { name: "The Idea Generator/Creative Muse", systemPrompt: "You are The Idea Generator/Creative Muse. Focus on brainstorming plot twists, character concepts, unique settings, or overcoming writer's block." },
                { name: "The Genre Specialist", systemPrompt: "You are The Genre Specialist. Generate stories adhering strictly to the conventions of a specific genre (e.g., 'Hard Sci-Fi Narrator,' 'Cozy Mystery Solver,' 'Gritty Noir Detective')." },
                { name: "The Dialogue Writer", systemPrompt: "You are The Dialogue Writer. Specialize in generating realistic, character-driven dialogue for specific personas or scenes." },
                { name: "The Emotional Instigator", systemPrompt: "You are The Emotional Instigator. Explore complex emotions, psychological states, and character motivations, often for dramatic effect." },
                { name: "The Ethical Dilemma Presenter", systemPrompt: "You are The Ethical Dilemma Presenter. Craft narratives that explore moral ambiguities, difficult choices, and their consequences." },
                { name: "The Data-Driven Narrator", systemPrompt: "You are The Data-Driven Narrator. Weave factual information, statistics, or historical events into a compelling narrative." },
                { name: "The Interactive Story Guide", systemPrompt: "You are The Interactive Story Guide. Facilitate choose-your-own-adventure style narratives, adapting the story based on user choices." },
                { name: "The Archetype Bender/Deconstructor", systemPrompt: "You are The Archetype Bender/Deconstructor. Intentionally subvert or combine traditional archetypes in novel ways for unique storytelling." },
                { name: "The Style Mimic", systemPrompt: "You are The Style Mimic. Generate stories in the style of a specific author, literary movement, or historical period." }
            ].sort((a, b) => a.name.localeCompare(b.name));

            const tones = [
                { name: "Informative/Explanatory", description: "an informative and explanatory" },
                { name: "Neutral/Objective", description: "a neutral and objective" },
                { name: "Formal", description: "a formal" },
                { name: "Enthusiastic/Optimistic", description: "an enthusiastic and optimistic" },
                { name: "Descriptive/Evocative", description: "a descriptive and evocative" },
                { name: "Mysterious/Suspenseful", description: "a mysterious and suspenseful" },
                { name: "Whimsical/Fantastical", description: "a whimsical and fantastical" },
                { name: "Melancholic/Somber", description: "a melancholic and somber" },
                { name: "Humorous/Playful", description: "a humorous and playful" },
                { name: "Dramatic/Intense", description: "a dramatic and intense" },
                { name: "Sarcastic/Ironic", description: "a sarcastic and ironic" },
                { name: "Cynical/Skeptical", description: "a cynical and skeptical" },
                { name: "Nostalgic", description: "a nostalgic" },
                { name: "Urgent/Pressing", description: "an urgent and pressing" },
                { name: "Philosophical/Reflective", description: "a philosophical and reflective" },
                { name: "Gritty/Realistic", description: "a gritty and realistic" },
                { name: "Empathetic/Compassionate", description: "an empathetic and compassionate" },
                { name: "Authoritative/Confident", description: "an authoritative and confident" },
                { name: "Playful/Flirty", description: "a playful and flirty" },
                { name: "Foreboding/Ominous", description: "a foreboding and ominous" }
            ].sort((a, b) => a.name.localeCompare(b.name));

             const imageStyles = [
                { name: "3D Model", prefix: "A professional 3D model of {placeholder}, rendered in a cinematic style with dynamic lighting, suitable for a portfolio, 8k, octane render." },
                { name: "Anime", prefix: "A vibrant, high-quality anime screenshot of {placeholder}, cinematic lighting, detailed, by Studio Ghibli and Makoto Shinkai." },
                { name: "Art Deco", prefix: "An elegant art deco illustration of {placeholder}, featuring geometric patterns, bold lines, and a luxurious feel, 1920s style." },
                { name: "Blueprint", prefix: "A detailed blueprint diagram of {placeholder}, with annotations, measurements, and technical specifications on a blue background." },
                { name: "Charcoal Sketch", prefix: "A dramatic charcoal sketch of {placeholder} on textured paper, with deep blacks, high contrast, and expressive strokes." },
                { name: "Cubism", prefix: "A cubist painting of {placeholder}, fragmented and abstracted, showing the subject from multiple viewpoints, in the style of Picasso." },
                { name: "Cyberpunk", prefix: "A neon-drenched cyberpunk city scene featuring {placeholder}, with towering skyscrapers, holographic ads, and a Blade Runner aesthetic." },
                { name: "Fantasy Art", prefix: "An epic fantasy art painting of {placeholder}, with dramatic lighting, mystical elements, and a high level of detail, in the style of Frank Frazetta." },
                { name: "Gothic Art", prefix: "A dark and moody gothic art piece depicting {placeholder}, with dramatic shadows, intricate details, and a sense of sublime horror." },
                { name: "Highly Detailed", prefix: "An extremely detailed, intricate illustration of {placeholder}, hyper-realistic, 8k resolution, sharp focus." },
                { name: "Impressionism", prefix: "An impressionist painting of {placeholder}, with visible brush strokes, soft focus, and an emphasis on light and its changing qualities, in the style of Monet." },
                { name: "Infographic", prefix: "Create a clean, professional infographic about '{placeholder}'. CRITICAL: ALL TEXT MUST BE SPELLED CORRECTLY. Double-check all spelling. Use clear, legible fonts, icons, and charts to present the information." },
                { name: "Minimalist", prefix: "A minimalist, simple line drawing of {placeholder}, clean and elegant, with plenty of negative space." },
                { name: "Oil Painting", prefix: "A classic oil painting of {placeholder}, with rich colors, deep shadows, and visible canvas texture, in the style of Rembrandt." },
                { name: "Photorealistic", prefix: "A photorealistic, cinematic, 4k, high-resolution photograph of {placeholder}, sharp focus, professional quality." },
                { name: "Pixel Art", prefix: "A detailed 16-bit pixel art scene of {placeholder}, vibrant colors, in the style of a classic SNES RPG." },
                { name: "Pop Art", prefix: "A pop art image of {placeholder}, with bold colors, thick outlines, and a comic book feel, in the style of Andy Warhol." },
                { name: "Rococo", prefix: "An ornate Rococo painting of {placeholder}, with soft colors, curving lines, and themes of love and nature." },
                { name: "Steampunk", prefix: "A detailed steampunk illustration of {placeholder}, featuring gears, cogs, steam pipes, and Victorian-era technology." },
                { name: "Surreal", prefix: "A surrealist painting of {placeholder}, dreamlike and bizarre, with unexpected juxtapositions, in the style of Salvador Dali." },
                { name: "Synthwave", prefix: "A synthwave art piece of {placeholder}, with neon grids, a retro-futuristic aesthetic, and a 1980s color palette of pink and blue." },
                { name: "Tribal Art", prefix: "A tribal art depiction of {placeholder}, using traditional patterns, earthy colors, and symbolic imagery." },
                { name: "Vintage Photo", prefix: "A vintage, sepia-toned photograph of {placeholder} from the 1940s, with a soft focus and film grain." },
                { name: "Watercolor", prefix: "A beautiful watercolor painting of {placeholder}, with soft, translucent colors, and a gentle, blended look." }
            ].sort((a, b) => a.name.localeCompare(b.name));
            
            const sentenceLengths = [1, 2, 3, 4, 5, 0]; // 0 represents "Unlimited"

            // --- Core Functions ---

            function initializeApp() {
                populatePersonaSelect();
                populateToneSelect();
                populateImageStyleSelect();
                populateSentenceLengthSelect();
                
                currentPersonaIndex = personas.findIndex(p => p.name === "The Hero/Heroine"); // Updated default persona
                currentToneIndex = tones.findIndex(t => t.name === "Informative/Explanatory"); // Updated default tone
                personaSelect.value = currentPersonaIndex;
                toneSelect.value = currentToneIndex;
                sentenceLengthSelect.value = 2;

                resetApp();
            }

            function resetApp() {
                storyContainer.classList.remove('hidden');
                isLaminationMode = false;
                storyContainer.innerHTML = '';
                storyHistory = [ ]; // Start with a clean slate
                historyStack = [ JSON.parse(JSON.stringify(storyHistory)) ];
                historyPointer = 0;
                isEditing = false;
                editingParagraphIndex = null;
                lastGeneratedContentElement = null; // Clear last generated content
                
                updateUIFromHistory();
                displaySystemMessage("Provide a prompt to begin your story.", 'system-message');
                promptInput.focus();
            }
            
            // This function now generates the system instruction string
            function getSystemInstructionString() {
                const selectedPersona = personas[currentPersonaIndex];
                const selectedTone = tones[currentToneIndex];
                let lengthConstraint = `Limit your response to exactly ${currentSentenceLength} sentence(s).`;
                if(currentSentenceLength == 0) {
                     lengthConstraint = "There is no limit to the length of your response.";
                }
                return `${selectedPersona.systemPrompt} Continue the story based on the user's prompt. The story should have ${selectedTone.description} tone. ${lengthConstraint}`;
            }

            function populatePersonaSelect() {
                personaSelect.innerHTML = ''; // Clear existing options
                personas.forEach((persona, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = persona.name;
                    personaSelect.appendChild(option);
                });
            }

            function populateToneSelect() {
                toneSelect.innerHTML = ''; // Clear existing options
                tones.forEach((tone, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = tone.name;
                    toneSelect.appendChild(option);
                });
            }
            
             function populateImageStyleSelect() {
                imageStyleSelect.innerHTML = ''; // Clear existing options
                imageStyles.forEach((style, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = style.name;
                    imageStyleSelect.appendChild(option);
                });
            }

            function populateSentenceLengthSelect() {
                 sentenceLengthSelect.innerHTML = ''; // Clear existing options
                 sentenceLengths.forEach(length => {
                    const option = document.createElement('option');
                    option.value = length;
                    option.textContent = length === 0 ? "Unlimited" : length;
                    sentenceLengthSelect.appendChild(option);
                });
            }

            async function handleContinueStory() {
                const userPrompt = promptInput.value.trim();
                if (!userPrompt || isAITurn || (getUserPromptCount() >= MAX_PROMPTS && currentSentenceLength !== 0)) return;

                setLoading(true);

                if (isEditing) {
                    storyHistory[editingParagraphIndex].parts[0].text = userPrompt;
                    storyHistory.splice(editingParagraphIndex + 1);
                } else {
                    storyHistory.push({ role: 'user', parts: [{ text: userPrompt }] });
                }
                
                promptInput.value = '';
                isEditing = false;
                editingParagraphIndex = null;
                updateUIFromHistory();

                try {
                    // Pass the system instruction string separately
                    const aiResponseText = await getAIResponse(storyHistory, getSystemInstructionString());
                    storyHistory.push({ role: 'model', parts: [{ text: aiResponseText }] });
                    pushToHistory();
                } catch (error) {
                    console.error("Error continuing story:", error);
                     if (error.message.includes("overloaded")) {
                        displaySystemMessage("The AI model is currently busy. Please try again in a moment.", 'error');
                    } else {
                        displaySystemMessage(error.message, 'error');
                    }
                    storyHistory.pop(); // Remove the user prompt if AI response fails
                } finally {
                    setLoading(false);
                    updateUIFromHistory();
                }
            }

            // New function to handle "Create Content"
            async function handleCreateContent() {
                currentLaminationText = promptInput.value.trim();
                if (!currentLaminationText || isAITurn) return;

                contentFormatModal.classList.remove('hidden');
            }

            // Function to generate content based on format
            async function generateContent(format) {
                contentFormatModal.classList.add('hidden');
                storyContainer.classList.remove('hidden');
                isLaminationMode = true; // Enter content creation mode
                storyContainer.innerHTML = ''; // Clear story display
                setLoading(true);

                const contentDisplayArea = document.createElement('div');
                contentDisplayArea.id = "content-display-area";
                contentDisplayArea.className = 'w-full max-w-2xl relative pt-[75%] bg-gray-700 rounded-lg flex flex-col items-center justify-center p-8 text-white text-center shadow-lg';
                contentDisplayArea.style.overflow = 'hidden'; // Ensure content doesn't spill
                storyContainer.appendChild(contentDisplayArea);
                lastGeneratedContentElement = contentDisplayArea; // Set this for saving

                const loadingSvg = `<svg class="animate-spin h-8 w-8 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`;

                try {
                    // Generate a relevant background image
                    const imagePromptBase = imageStyles[currentImageStyleIndex].prefix.replace('{placeholder}', currentLaminationText);
                    const imageUrl = await generateImage(imagePromptBase + ", subtle background");
                    
                    contentDisplayArea.style.backgroundImage = `url('${imageUrl}')`;
                    contentDisplayArea.style.backgroundSize = 'cover';
                    contentDisplayArea.style.backgroundPosition = 'center';
                    contentDisplayArea.style.position = 'relative'; // For text overlay positioning

                    let contentHtml = '';
                    switch(format) {
                        case 'quote-card':
                            const quote = currentLaminationText.split('—');
                            const quoteText = quote[0].trim();
                            const author = quote.length > 1 ? `— ${quote[1].trim()}` : '';
                            contentHtml = `
                                <div class="relative z-10 p-4 bg-black bg-opacity-60 rounded-lg max-w-[80%]">
                                    <p class="text-3xl font-serif italic mb-2 leading-tight">${quoteText}</p>
                                    ${author ? `<p class="text-xl font-semibold">${author}</p>` : ''}
                                </div>
                            `;
                            break;
                        case 'key-takeaways':
                            // Use AI to format into a list
                            const listPrompt = `Based on the following text, extract 3-5 concise key takeaways as a bulleted list:\n\n${currentLaminationText}\n\nFormat as: - Point 1\n- Point 2`;
                            const aiListResponse = await getAIResponse([{ role: 'user', parts: [{ text: listPrompt }] }], "You are a concise summarizer. Respond only with the bulleted list.");
                            const listItems = aiListResponse.split('\n').filter(line => line.startsWith('-')).map(line => line.substring(1).trim());

                            contentHtml = `
                                <div class="relative z-10 p-6 bg-blue-900 bg-opacity-70 rounded-xl max-w-[80%] text-left">
                                    <h3 class="text-2xl font-bold mb-4">Key Takeaways</h3>
                                    <ul class="list-none space-y-3">
                                        ${listItems.map(item => `
                                            <li class="flex items-start gap-3">
                                                <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" class="flex-shrink-0 w-6 h-6 text-blue-300 mt-1" viewBox="0 0 16 16">
                                                    <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.08z"/>
                                                </svg>
                                                <span>${item}</span>
                                            </li>`).join('')}
                                    </ul>
                                </div>
                            `;
                            break;
                        case 'inspirational':
                            // Let AI rephrase into an inspirational thought
                            const inspirationalPrompt = `Rephrase the following text as a short, uplifting, and inspirational thought for social media:\n\n"${currentLaminationText}"`;
                            const aiInspirationalResponse = await getAIResponse([{ role: 'user', parts: [{ text: inspirationalPrompt }] }], "You are an inspirational content creator. Keep it concise and positive.");
                            contentHtml = `
                                <div class="relative z-10 p-6 bg-gradient-to-br from-purple-800 to-pink-800 bg-opacity-80 rounded-full max-w-[80%] flex items-center justify-center text-center aspect-square flex-col shadow-2xl">
                                    <p class="text-2xl font-bold leading-snug">${aiInspirationalResponse}</p>
                                </div>
                            `;
                            break;
                    }
                    contentDisplayArea.innerHTML = contentHtml; // Place generated content
                    setupTextInteraction(contentDisplayArea.querySelector('.resizable-text-box') || contentDisplayArea.querySelector('p, div')); // Make text draggable/resizable if applicable
                    renderLaminationControls(contentDisplayArea, contentDisplayArea.querySelector('.resizable-text-box') || contentDisplayArea.querySelector('p, div')); // Add controls if needed
                } catch (error) {
                    console.error("Error creating content:", error);
                    contentDisplayArea.innerHTML = `<p class="text-red-400 text-center p-4">Error creating content: ${error.message}</p>`;
                } finally {
                    setLoading(false);
                }
            }


             async function handleCreateLamination(themePrompt) {
                if(!themePrompt) { 
                     currentLaminationText = promptInput.value.trim();
                     if (!currentLaminationText || isAITurn) return;
                     isLaminationMode = true;
                     storyContainer.innerHTML = ''; 
                }
               
                setLoading(true);
                storyContainer.innerHTML = `<div id="lamination-creator" class="w-full h-full p-4 flex flex-col items-center"></div>`;
                const laminationCreatorEl = document.getElementById('lamination-creator');
                lastGeneratedContentElement = laminationCreatorEl; // Set this for saving

                const imageDisplayContainer = document.createElement('div');
                imageDisplayContainer.id = "lamination-image-container";
                imageDisplayContainer.className = 'w-full max-w-2xl relative pt-[75%] bg-gray-700 rounded-lg flex items-center justify-center';
                imageDisplayContainer.innerHTML = `<svg class="animate-spin h-8 w-8 text-white absolute" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`;
                laminationCreatorEl.appendChild(imageDisplayContainer);

                const controlsContainer = document.createElement('div');
                controlsContainer.id = "lamination-controls";
                controlsContainer.className = "flex flex-wrap items-center justify-center gap-4 mt-4";
                laminationCreatorEl.appendChild(controlsContainer);
                
                const imagePrompt = `Photorealistic image, 4k, high resolution: ${themePrompt || 'a beautiful, serene background'}`;

                try {
                    const imageUrl = await generateImage(imagePrompt);
                    imageDisplayContainer.innerHTML = ''; 
                    
                    const img = new Image();
                    img.crossOrigin = "anonymous"; // Important for canvas saving
                    img.src = imageUrl;
                    img.className = 'absolute top-0 left-0 w-full h-full object-cover rounded-lg';
                    imageDisplayContainer.appendChild(img);
                    
                    const textOverlay = document.createElement('div');
                    textOverlay.id = 'lamination-text-overlay';
                    textOverlay.className = 'resizable-text-box';
                    textOverlay.innerHTML = `<p>${currentLaminationText}</p>`;
                    textOverlay.setAttribute('data-x', 0);
                    textOverlay.setAttribute('data-y', 0);
                    textOverlay.setAttribute('data-angle', 0);

                    imageDisplayContainer.appendChild(textOverlay);

                    setupTextInteraction(textOverlay);
                    renderLaminationControls(controlsContainer, textOverlay);

                } catch (error) {
                    console.error("Error creating lamination:", error);
                    imageDisplayContainer.innerHTML = `<p class="text-red-400 text-center p-4">Image generation failed. Please try again.</p>`;
                } finally {
                    setLoading(false);
                }
            }
            
            function renderLaminationControls(container, textElement) {
                container.innerHTML = ''; 

                const backgroundRow = document.createElement('div');
                backgroundRow.className = "w-full flex items-center justify-center gap-2 mb-2";
                
                const searchLabel = document.createElement('label');
                searchLabel.textContent = "Background:";
                searchLabel.className = "text-sm text-gray-400";
                backgroundRow.appendChild(searchLabel);

                const searchInput = document.createElement('input');
                searchInput.type = "text";
                searchInput.placeholder = "e.g., 'a field of wildflowers at dawn'";
                searchInput.className = "flex-grow p-2 bg-gray-600 border border-gray-500 rounded-lg text-white";
                backgroundRow.appendChild(searchInput);

                const redesignButton = document.createElement('button');
                redesignButton.textContent = "Generate";
                redesignButton.className = "bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-3 rounded-lg";
                redesignButton.onclick = () => handleCreateLamination(searchInput.value);
                backgroundRow.appendChild(redesignButton);

                container.appendChild(backgroundRow);

                const fontRow = document.createElement('div');
                fontRow.className = "w-full flex flex-wrap items-center justify-center gap-4";
                
                const fontList = [
                    'Arial, sans-serif', 'Verdana, sans-serif', 'Georgia, serif', 'Times New Roman, serif',
                    'Courier New, monospace', 'Lucida Console, monospace', 'Impact, sans-serif', 
                    'Comic Sans MS, cursive', 'Trebuchet MS, sans-serif', 'Palatino Linotype, book antiqua, palatino, serif',
                    'Dancing Script, cursive', 'Lobster, cursive', 'Pacifico, cursive', 'Great Vibes, cursive', 'Sacramento, cursive',
                    'Calibri, sans-serif', 'Bahnschrift, system-ui'
                ].sort();

                const fontSelect = createSelect(fontList, (e) => { textElement.style.fontFamily = e.target.value; });
                fontSelect.className = "p-2 bg-gray-600 border border-gray-500 rounded-lg text-white max-w-[150px]";
                fontRow.appendChild(fontSelect);

                const sizeSelect = document.createElement('select');
                sizeSelect.className = "p-2 bg-gray-600 border border-gray-500 rounded-lg text-white";
                for(let i = 8; i <= 72; i += 2) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `${i}px`;
                    sizeSelect.appendChild(option);
                }
                sizeSelect.value = 24;
                textElement.style.fontSize = '24px';
                sizeSelect.addEventListener('change', (e) => { textElement.style.fontSize = `${e.target.value}px`; });
                fontRow.appendChild(sizeSelect);
                
                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                colorInput.value = '#FFFFFF';
                colorInput.className = "w-10 h-10 p-1 bg-gray-600 rounded border-0 cursor-pointer";
                colorInput.addEventListener('input', (e) => { textElement.style.color = e.target.value; });
                fontRow.appendChild(colorInput);

                const styleButtonWrapper = document.createElement('div');
                styleButtonWrapper.className = 'flex items-center bg-gray-600 rounded-lg';
                
                const boldButton = createStyleButton('B', 'font-bold', () => { textElement.style.fontWeight = textElement.style.fontWeight === 'bold' ? 'normal' : 'bold'; });
                const italicButton = createStyleButton('I', 'italic', () => { textElement.style.fontStyle = textElement.style.fontStyle === 'italic' ? 'normal' : 'italic'; });
                const underlineButton = createStyleButton('U', 'underline', () => { textElement.style.textDecoration = textElement.style.textDecoration === 'underline' ? 'none' : 'underline'; });

                styleButtonWrapper.appendChild(boldButton);
                styleButtonWrapper.appendChild(italicButton);
                styleButtonWrapper.appendChild(underlineButton);
                fontRow.appendChild(styleButtonWrapper);

                container.appendChild(fontRow);
            }

            function createStyleButton(text, styleClass, onClick) {
                const button = document.createElement('button');
                button.textContent = text;
                button.classList.add('px-3', 'py-1', styleClass, 'text-white', 'transition-colors', 'duration-200', 'rounded-lg');
                button.addEventListener('click', () => {
                    onClick();
                    button.classList.toggle('bg-indigo-500');
                });
                return button;
            }

            function createSelect(options, onChange) {
                const select = document.createElement('select');
                select.className = "p-2 bg-gray-600 border border-gray-500 rounded-lg text-white";
                options.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt;
                    option.textContent = opt.split(',')[0];
                    select.appendChild(option);
                });
                select.addEventListener('change', onChange);
                return select;
            }

             function setupTextInteraction(target) {
                const position = { x: 0, y: 0, angle: 0 };

                interact(target)
                    .draggable({
                        listeners: {
                            move(event) {
                                position.x += event.dx;
                                position.y += event.dy;
                                event.target.style.transform = `translate(${position.x}px, ${position.y}px) rotate(${position.angle}deg)`;
                            },
                        },
                        modifiers: [
                            interact.modifiers.restrictRect({
                                restriction: 'parent'
                            })
                        ]
                    })
                    .resizable({
                        edges: { left: true, right: true, bottom: true, top: true },
                        listeners: {
                            move(event) {
                                let { x, y } = event.target.dataset;
                                x = (parseFloat(x) || 0) + event.deltaRect.left;
                                y = (parseFloat(y) || 0) + event.deltaRect.top;
                                Object.assign(event.target.style, {
                                    width: `${event.rect.width}px`,
                                    height: `${event.rect.height}px`,
                                });
                                Object.assign(event.target.dataset, { x, y });
                            }
                        },
                        modifiers: [
                           interact.modifiers.restrictEdges({
                             outer: 'parent'
                           }),
                           interact.modifiers.restrictSize({
                              min: { width: 100, height: 50 }
                           })
                        ],
                    })
                    .gesturable({
                         listeners: {
                            move (event) {
                              position.angle += event.da
                              event.target.style.transform = `translate(${position.x}px, ${position.y}px) rotate(${position.angle}deg)`
                            },
                          }
                    });
            }

            // --- UI & Display ---

            function updateUIFromHistory() {
                if (isLaminationMode) return; // Don't update story UI if in lamination/content mode
                storyContainer.innerHTML = '';
                storyHistory.forEach((part, i) => {
                    addParagraphToUI(part, i);
                });
                storyContainer.scrollTop = storyContainer.scrollHeight;
                updateButtonStates();
                if (!promptInput.disabled) {
                    promptInput.focus();
                }
            }
            
            function addParagraphToUI(part, index) {
                const { role, parts, imageUrl } = part;
                const text = parts[0].text;

                const wrapper = document.createElement('div');
                wrapper.classList.add('story-paragraph-wrapper', 'flex', 'items-start', 'gap-4');
                wrapper.dataset.role = role; 
                
                const paragraphContent = document.createElement('div');
                paragraphContent.classList.add('flex-grow', 'p-4', 'rounded-lg', 'w-full');
                
                if (imageUrl) {
                    const imageContainer = document.createElement('div');
                    imageContainer.classList.add('illustration-container');
                    const img = new Image();
                    img.crossOrigin = "anonymous";
                    img.src = imageUrl;
                    img.alt = "Generated illustration of the scene";
                    img.className = 'w-full h-full';
                    imageContainer.appendChild(img);
                    paragraphContent.insertBefore(imageContainer, paragraphContent.firstChild);
                }

                const contentTag = document.createElement('p');
                contentTag.textContent = text;
                paragraphContent.appendChild(contentTag);

                const controlsContainer = document.createElement('div');
                controlsContainer.classList.add('flex-shrink-0', 'py-4', 'flex', 'flex-col', 'gap-2');

                if (role === 'user') {
                    wrapper.classList.add('justify-start');
                    paragraphContent.classList.add('user-paragraph', 'rounded-bl-none');
                    const editBtn = createControlButton('Edit', () => enterEditMode(index, text));
                    controlsContainer.appendChild(editBtn);
                    wrapper.appendChild(paragraphContent);
                    wrapper.appendChild(controlsContainer);
                } else { // Handles 'model' and 'insight'
                    wrapper.classList.add('justify-end');
                    paragraphContent.classList.add('rounded-br-none');
                    
                    if (role === 'insight') { // Original insight is kept for story history
                        paragraphContent.classList.add('insight-paragraph');
                        const editBtn = createControlButton('Edit', () => enterEditMode(index, text));
                        controlsContainer.appendChild(editBtn);
                    } else { // 'model'
                        paragraphContent.classList.add('ai-paragraph');
                        const regenBtn = createControlButton('Regen', () => handleRegenerate(index));
                        controlsContainer.appendChild(regenBtn);
                    }

                    const illustrateBtn = createControlButton('Illustrate', () => handleIllustration(index));
                    controlsContainer.appendChild(illustrateBtn);
                    wrapper.appendChild(controlsContainer);
                    wrapper.appendChild(paragraphContent);
                }
                storyContainer.appendChild(wrapper);
            }
            
            function createControlButton(text, onClick) {
                const button = document.createElement('button');
                button.textContent = text;
                button.classList.add('bg-gray-600', 'hover:bg-gray-500', 'text-white', 'text-xs', 'py-1', 'px-2', 'rounded-md', 'transition-colors');
                button.addEventListener('click', onClick);
                return button;
            }

            function displaySystemMessage(text, type = 'system-message') {
                // Remove existing system/error messages to prevent clutter
                storyContainer.querySelectorAll('.system-message-paragraph, .error-paragraph').forEach(el => el.remove());
                const messageWrapper = document.createElement('div');
                messageWrapper.classList.add('story-paragraph-wrapper', type === 'error' ? 'error-paragraph' : 'system-message-paragraph');
                messageWrapper.innerHTML = text.replace(/\n/g, '<br>');
                storyContainer.appendChild(messageWrapper);
                storyContainer.scrollTop = storyContainer.scrollHeight;
            }

            // --- Edit, Regenerate, Illustrate ---

            function enterEditMode(index, text) {
                if(isAITurn) return;
                isEditing = true;
                editingParagraphIndex = index;
                promptInput.value = text;
                btnText.textContent = 'Update';
                promptInput.focus();
                updateButtonStates();
            }

            async function handleRegenerate(index) {
                if (isAITurn) return;
                setLoading(true);
                
                // Find the user prompt that came before this AI response.
                const historyForRegen = storyHistory.slice(0, index);
                
                try {
                    // Pass the system instruction string separately
                    const newAiResponse = await getAIResponse(historyForRegen, getSystemInstructionString());
                    storyHistory[index].parts[0].text = newAiResponse;
                    storyHistory.splice(index + 1);
                    pushToHistory();
                } catch (error) {
                    console.error("Error regenerating:", error);
                    displaySystemMessage(error.message, 'error');
                } finally {
                    setLoading(false);
                    updateUIFromHistory();
                }
            }
            
            async function handleIllustration(index) {
                 if (isAITurn) return;
                 setLoading(true);
                 
                 const sceneText = storyHistory[index].parts[0].text;
                 const paragraphWrapper = storyContainer.children[index];
                 const paragraphContent = paragraphWrapper.querySelector('.flex-grow');

                 let imageContainer = paragraphContent.querySelector('.illustration-container');
                 if (!imageContainer) {
                     imageContainer = document.createElement('div');
                     imageContainer.classList.add('illustration-container');
                     paragraphContent.insertBefore(imageContainer, paragraphContent.firstChild);
                 }
                 
                 imageContainer.innerHTML = `<div class="loading-placeholder flex items-center justify-center bg-gray-700 text-center p-4"><svg class="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></div>`;

                 try {
                    const style = imageStyles[currentImageStyleIndex];
                    const imagePrompt = style.prefix.replace('{placeholder}', sceneText);
                    const imageUrl = await generateImage(imagePrompt);
                    
                    const img = new Image();
                    img.crossOrigin = "anonymous";
                    img.src = imageUrl;
                    img.alt = "Generated illustration of the scene";
                    imageContainer.innerHTML = '';
                    imageContainer.appendChild(img);

                    storyHistory[index].imageUrl = imageUrl;
                    pushToHistory();
                 } catch(error) {
                    console.error("Error generating image:", error);
                    if (error.message && error.message.includes("billed an account")) {
                        imageContainer.innerHTML = `<p class="text-red-400 text-center">Image generation failed.<br>This feature requires a billed Google Cloud account.</p>`;
                    } else {
                        imageContainer.innerHTML = `<p class="text-red-400 text-center">Image generation failed.</p>`;
                    }
                 } finally {
                    setLoading(false);
                 }
            }
            
            // --- Saving & Export ---

            function saveAsTxt(textContent, filename) {
                const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            function saveStoryAsHtml() {
                const personaName = personas[currentPersonaIndex].name;
                const toneName = tones[currentToneIndex].name;

                let storyHtml = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Woven Story</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            background-color: #111827; /* bg-gray-900 */
            color: #f9fafb; /* text-gray-50 */
            padding: 2rem;
            line-height: 1.6;
        }
        .container {
            max-width: 800px;
            margin: auto;
        }
        h1, h2 {
            color: #e5e7eb; /* text-gray-200 */
            border-bottom: 1px solid #374151; /* border-gray-700 */
            padding-bottom: 0.5rem;
        }
        h1 { font-size: 2.25rem; }
        h2 { font-size: 1.5rem; margin-top: 2rem; }
        .meta-info {
            background-color: #1f2937; /* bg-gray-800 */
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 2rem;
            font-size: 0.9rem;
            color: #d1d5db; /* text-gray-300 */
        }
        .story-part {
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 0.75rem;
            max-width: 90%;
            display: flex;
            flex-direction: column;
        }
        .story-part p {
            margin: 0;
            white-space: pre-wrap; /* Preserve line breaks */
        }
        .story-part img {
            max-width: 100%;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            object-fit: contain;
            align-self: center;
        }
        .user-paragraph {
            background-color: #374151; /* bg-gray-700 */
            margin-right: auto;
            border-bottom-left-radius: 0;
        }
        .ai-paragraph, .insight-paragraph {
            margin-left: auto;
            align-items: flex-end;
            text-align: left;
            border-bottom-right-radius: 0;
        }
        .ai-paragraph {
             background-color: #1e293b; /* bg-gray-800 */
        }
        .insight-paragraph {
            background-color: #134e4a; /* bg-teal-900 */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Your AI-Woven Story</h1>
        <div class="meta-info">
            <strong>AI Persona:</strong> ${personaName}<br>
            <strong>Story Tone:</strong> ${toneName}
        </div>
        <h2>The Story</h2>
`;

                storyHistory.forEach(part => {
                    const { role, parts, imageUrl } = part;
                    const text = parts[0].text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    let roleClass = '';
                    if (role === 'user') roleClass = 'user-paragraph';
                    if (role === 'model') roleClass = 'ai-paragraph';
                    if (role === 'insight') roleClass = 'insight-paragraph';

                    storyHtml += `<div class="story-part ${roleClass}">`;
                    if (imageUrl) {
                        storyHtml += `<img src="${imageUrl}" alt="Story illustration">`;
                    }
                    storyHtml += `<p>${text}</p></div>`;
                });

                storyHtml += `
    </div>
</body>
</html>`;

                const blob = new Blob([storyHtml], { type: 'text/html;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'ai-woven-story.html';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            async function saveContentAsPng(elementToSave, filename, isLamination = false) {
                setLoading(true);
                const filter = (node) => {
                    // Filter out UI controls that shouldn't be part of the final image
                    if (node.classList && node.classList.contains('flex-shrink-0')) {
                        return false;
                    }
                    // For content creation, we might have specific elements we don't want to include
                    if (node.id === 'lamination-controls') return false; // Controls for text editing
                    return true;
                };

                const options = {
                    quality: 0.98,
                    backgroundColor: isLamination ? null : '#1f2937', // Transparent background for lamination/content
                    filter: filter,
                    pixelRatio: 2,
                };

                const textOverlay = elementToSave.querySelector('.resizable-text-box');
                if (textOverlay) {
                    textOverlay.classList.add('hide-borders');
                }

                try {
                    const dataUrl = await htmlToImage.toPng(elementToSave, options);
                    const a = document.createElement('a');
                    a.href = dataUrl;
                    a.download = filename;
                    a.click();
                } catch (error) {
                    console.error('Error saving content as PNG:', error);
                    displaySystemMessage('Could not save image. It might be too large or complex.', 'error');
                } finally {
                    if (textOverlay) {
                        textOverlay.classList.remove('hide-borders');
                    }
                    setLoading(false);
                }
            }


             async function saveLaminationSheet(element, filename) {
                setLoading(true);
                const textOverlay = element.querySelector('#lamination-text-overlay');
                 const options = {
                    quality: 0.98,
                    backgroundColor: '#00000000', // Transparent for sheet context
                    pixelRatio: 2
                };

                if (textOverlay) {
                    textOverlay.classList.add('hide-borders');
                }

                try {
                    const dataUrl = await htmlToImage.toPng(element, options);
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const DPI = 150; 
                    canvas.width = 8.5 * DPI;
                    canvas.height = 11 * DPI;

                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const singleImage = new Image();
                    singleImage.crossOrigin = "anonymous";
                    const imageLoadPromise = new Promise((resolve, reject) => {
                        singleImage.onload = resolve;
                        singleImage.onerror = reject;
                        singleImage.src = dataUrl;
                    });
                    
                    await imageLoadPromise;

                    const margin = 0.5 * DPI;
                    const sheetW = canvas.width - 2 * margin;
                    const sheetH = canvas.height - 2 * margin;
                    const colWidth = sheetW / 2;
                    const rowHeight = sheetH / 2;
                    const padding = 0.125 * DPI;

                    const aspect = singleImage.width / singleImage.height;
                    let w, h;
                    if( (colWidth - padding) / (rowHeight - padding) > aspect) {
                        h = rowHeight - padding;
                        w = h * aspect;
                    } else {
                        w = colWidth - padding;
                        h = w / aspect;
                    }

                    const positions = [
                        { x: margin + (colWidth - w) / 2, y: margin + (rowHeight - h) / 2 },
                        { x: margin + colWidth + (colWidth - w) / 2, y: margin + (rowHeight - h) / 2 },
                        { x: margin + (colWidth - w) / 2, y: margin + rowHeight + (rowHeight - h) / 2 },
                        { x: margin + colWidth + (colWidth - w) / 2, y: margin + rowHeight + (rowHeight - h) / 2 }
                    ];

                    positions.forEach(pos => ctx.drawImage(singleImage, pos.x, pos.y, w, h));

                    const finalImageDataUrl = canvas.toDataURL('image/png');
                    const a = document.createElement('a');
                    a.href = finalImageDataUrl;
                    a.download = filename;
                    a.click();

                } catch (error) {
                    console.error('Lamination sheet saving error:', error);
                    displaySystemMessage('Could not save lamination sheet.', 'error');
                } finally {
                    if (textOverlay) {
                        textOverlay.classList.remove('hide-borders');
                    }
                    setLoading(false);
                }
            }


            // --- History & State Management ---

            function pushToHistory() {
                historyStack = historyStack.slice(0, historyPointer + 1);
                historyStack.push(JSON.parse(JSON.stringify(storyHistory)));
                historyPointer++;
                updateButtonStates();
            }

            function handleUndo() {
                if (historyPointer > 0) {
                    historyPointer--;
                    storyHistory = JSON.parse(JSON.stringify(historyStack[historyPointer]));
                    updateUIFromHistory();
                }
            }

            function handleRedo() {
                if (historyPointer < historyStack.length - 1) {
                    historyPointer++;
                    storyHistory = JSON.parse(JSON.stringify(historyStack[historyPointer]));
                    updateUIFromHistory();
                }
            }

            function getUserPromptCount() {
                return storyHistory.filter(p => p.role === 'user').length;
            }

            function updateButtonStates() {
                const promptCount = getUserPromptCount();
                const isStoryComplete = promptCount >= MAX_PROMPTS && currentSentenceLength !== 0;
                const canSaveStory = storyHistory.length > 0;
                
                const isBusy = isAITurn;
                
                continueBtn.disabled = isBusy || isStoryComplete || isEditing;
                createContentBtn.disabled = isBusy || isEditing; // Enable/disable Create Content
                
                if(isEditing) {
                    btnText.textContent = 'Update';
                } else {
                     btnText.textContent = 'Add to Story';
                }

                if (isStoryComplete && !isBusy) {
                    promptInput.placeholder = "Max prompts reached! You can save your story now.";
                    promptInput.disabled = true;
                } else {
                    const countText = currentSentenceLength === 0 ? '' : ` of ${MAX_PROMPTS}`;
                    promptInput.placeholder = `Add prompt ${promptCount + 1}${countText}...`;
                    promptInput.disabled = isBusy;
                }

                undoBtn.disabled = isBusy || historyPointer <= 0;
                redoBtn.disabled = isBusy || historyPointer >= historyStack.length - 1;
                
                saveStoryBtn.disabled = isBusy || !canSaveStory;
                saveWeaverBtn.disabled = isBusy || storyHistory.length < 1;
                savePromptsBtn.disabled = isBusy || promptCount < 1;
                saveLaminationBtn.disabled = isBusy || !isLaminationMode || !document.getElementById('lamination-image-container'); // Only enable if in lamination mode and lamination exists
                saveLastContentBtn.disabled = isBusy || !isLaminationMode || !lastGeneratedContentElement; // Only enable if in content mode and content exists
            }
            
            function setLoading(isLoading) {
                isAITurn = isLoading;
                loadingSpinner.classList.toggle('hidden', !isLoading);
                // Disable/enable main action buttons directly while busy
                continueBtn.disabled = isLoading;
                createContentBtn.disabled = isLoading;
                createLaminationBtn.disabled = isLoading;
                // Update general button states based on all conditions
                updateButtonStates();
            }

            // Modified getAIResponse to handle system instructions
            async function getAIResponse(chatHistory, systemInstruction) {
                const apiKey = "AIzaSyA29N25PG96j0NURl1m-Hn8ydX9P_X97kY"; 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                
                // Create a copy of the chat history to modify for the API call
                const messagesForAPI = chatHistory.map(({role, parts}) => ({role, parts}));

                // Prepend system instruction to the first user message
                // Find the first user message
                const firstUserMessageIndex = messagesForAPI.findIndex(msg => msg.role === 'user');
                if (firstUserMessageIndex !== -1) {
                    // Prepend the system instruction to the text of the first user message
                    messagesForAPI[firstUserMessageIndex].parts[0].text = 
                        `${systemInstruction}\n\n${messagesForAPI[firstUserMessageIndex].parts[0].text}`;
                } else {
                    // If there's no user message yet (e.g., first turn for content generation without initial prompt)
                    // prepend the system instruction as a new user message.
                    messagesForAPI.unshift({ role: 'user', parts: [{ text: systemInstruction }] });
                }

                const payload = { contents: messagesForAPI };
                
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error("AI response API error:", errorText);
                    const errorData = JSON.parse(errorText || "{}");
                    throw new Error(errorData?.error?.message || `API request failed with status ${response.status}`);
                }

                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    console.error("Unexpected AI response format:", result);
                    throw new Error(`Unexpected API response format.`);
                }
            }
            
             async function generateImage(prompt) {
                const apiKey = "AIzaSyA29N25PG96j0NURl1m-Hn8ydX9P_X97kY";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;
                
                const payload = {
                    instances: [{ "prompt": prompt }],
                    parameters: { "sampleCount": 1 }
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error("Image generation API error:", errorText);
                    throw new Error(`Image generation failed with status: ${response.status}`);
                }

                const result = await response.json();
                
                if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                    return `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                } else {
                    console.error("Unexpected image generation response:", result);
                    throw new Error('Could not retrieve image from API response.');
                }
            }
            
            // --- Event Listeners ---
            continueBtn.addEventListener('click', handleContinueStory);
            createContentBtn.addEventListener('click', handleCreateContent); // Updated listener
            createLaminationBtn.addEventListener('click', () => handleCreateLamination());
            promptInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    // If in lamination mode, hitting enter might trigger content update
                    if (isLaminationMode && currentLaminationText) { // Assuming currentLaminationText means we're editing a lamination
                        // This logic needs to be tied to re-rendering content,
                        // for now, it's safer to only trigger 'Add to Story'
                         handleContinueStory();
                    } else if (!isLaminationMode) {
                        handleContinueStory();
                    }
                }
            });
            
            resetStoryBtn.addEventListener('click', resetApp);
            
            saveStoryBtn.addEventListener('click', () => saveStoryAsHtml());

            saveLastContentBtn.addEventListener('click', () => { // Updated listener
                if (lastGeneratedContentElement) {
                    // Pass true for isLamination because content creation shares properties with lamination saving
                    saveContentAsPng(lastGeneratedContentElement, 'my-social-content.png', true);
                } else {
                    displaySystemMessage('No content to save. Create some content first!', 'error');
                }
            });


            saveWeaverBtn.addEventListener('click', () => {
                const weaverText = storyHistory
                    .map(p => {
                        let author = 'Unknown';
                        if(p.role === 'user') author = 'You';
                        else if (p.role === 'model') author = 'AI Story Weaver';
                        else if (p.role === 'insight') author = 'Insight'; // Kept for historical "insight" entries
                        return `[${author}]:\n${p.parts[0].text}`
                    })
                    .join('\n\n');
                saveAsTxt(weaverText, 'Weaver-Chat.txt');
            });

             savePromptsBtn.addEventListener('click', () => {
                const promptsText = storyHistory
                    .filter(p => p.role === 'user')
                    .map((p, i) => `Prompt ${i + 1}:\n${p.parts[0].text}`)
                    .join('\n\n---\n\n');
                saveAsTxt(promptsText, 'My-Prompts.txt');
            });

            saveLaminationBtn.addEventListener('click', () => {
                laminationSaveModal.classList.remove('hidden');
            });
            closeSaveModalBtn.addEventListener('click', () => {
                 laminationSaveModal.classList.add('hidden');
            });
            save4UpBtn.addEventListener('click', () => {
                const laminationContainer = document.getElementById('lamination-image-container');
                if (laminationContainer) {
                    saveLaminationSheet(laminationContainer, 'lamination-sheet.png');
                } else {
                    displaySystemMessage('No lamination to save as sheet.', 'error');
                }
                laminationSaveModal.classList.add('hidden');
            });
            saveFullPngBtn.addEventListener('click', () => {
                const laminationContainer = document.getElementById('lamination-image-container');
                if (laminationContainer) {
                    saveContentAsPng(laminationContainer, 'lamination-full.png', true);
                } else {
                    displaySystemMessage('No lamination to save as full PNG.', 'error');
                }
                laminationSaveModal.classList.add('hidden');
            });

            // Content format modal listeners
            closeContentFormatModalBtn.addEventListener('click', () => {
                contentFormatModal.classList.add('hidden');
            });
            formatQuoteCardBtn.addEventListener('click', () => generateContent('quote-card'));
            formatKeyTakeawaysBtn.addEventListener('click', () => generateContent('key-takeaways'));
            formatInspirationalBtn.addEventListener('click', () => generateContent('inspirational'));


            undoBtn.addEventListener('click', handleUndo);
            redoBtn.addEventListener('click', handleRedo);
            helpIcon.addEventListener('click', () => { instructionsModal.classList.remove('hidden'); });
            closeInstructionsModalBtn.addEventListener('click', () => { instructionsModal.classList.add('hidden'); });
            instructionsModal.addEventListener('click', (e) => {
                if (e.target === instructionsModal) {
                    instructionsModal.classList.add('hidden');
                }
            });


            personaSelect.addEventListener('change', (e) => { currentPersonaIndex = parseInt(e.target.value); resetApp() });
            toneSelect.addEventListener('change', (e) => { currentToneIndex = parseInt(e.target.value); resetApp() });
            imageStyleSelect.addEventListener('change', (e) => { currentImageStyleIndex = parseInt(e.target.value); });
            sentenceLengthSelect.addEventListener('change', (e) => { currentSentenceLength = parseInt(e.target.value); resetApp(); });


            // --- Initialization ---
            initializeApp();
        });
    </script>
</body>
</html>
