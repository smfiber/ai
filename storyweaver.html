<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Story Weaver</title>
    <!-- Google Fonts - Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Main font styling for the app */
        body {
            font-family: 'Inter', sans-serif;
            font-size: 16px;
            line-height: 1.6;
            letter-spacing: 0.01em;
        }

        /* Styling for the paragraphs to distinguish authors and add animations */
        .story-paragraph {
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 0.5s ease-out forwards;
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .user-paragraph {
            background-image: linear-gradient(to right, #374151, #2f3743);
            align-self: flex-start;
            border-radius: 1.5rem;
            border-bottom-left-radius: 0;
        }

        .ai-paragraph {
            background-image: linear-gradient(to left, #1e293b, #1a222f);
            align-self: flex-end;
            border-radius: 1.5rem;
            border-bottom-right-radius: 0;
        }
        
        .error-paragraph, .system-message-paragraph {
             align-self: center;
             text-align: center;
             padding: 1rem;
             border-radius: 0.5rem;
             font-weight: bold;
             max-width: 80%;
        }

        .error-paragraph {
             background-color: #dc2626; /* red-600 */
             color: #fee2e2; /* red-100 */
        }

        .system-message-paragraph {
            background-color: #374151; /* gray-700 */
            color: #a78bfa; /* violet-400 */
            white-space: pre-wrap; /* Preserve whitespace for formatted text like titles */
        }

        /* Custom scrollbar for a cleaner look */
        #story-container::-webkit-scrollbar {
            width: 8px;
        }
        #story-container::-webkit-scrollbar-track {
            background: #1f2937; /* gray-800 */
        }
        #story-container::-webkit-scrollbar-thumb {
            background: #4b5563; /* gray-600 */
            border-radius: 4px;
        }
        #story-container::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* gray-500 */
        }
    </style>
</head>
<body class="bg-gray-900 text-white h-full flex items-center justify-center p-4 antialiased">
    <div id="app-container" class="w-full max-w-4xl h-[95vh] flex flex-col bg-gray-800 rounded-2xl shadow-2xl p-4 sm:p-6">
        <!-- Header Section -->
        <header class="flex flex-col sm:flex-row justify-between items-start w-full mb-4 pb-4 border-b border-gray-700">
            <div class="text-center sm:text-left flex-grow">
                <h1 class="text-3xl font-bold text-white">AI Story Weaver</h1>
                <p class="text-sm text-gray-400 mt-1">Co-author rich narratives with an AI. Choose your guide, shape the plot, and refine your tale.</p>
                <p class="text-xs text-gray-500 mt-2">Version: <span id="version-number" class="font-mono bg-gray-700 px-2 py-1 rounded">1.44</span></p>
            </div>
            <!-- Control Panel: Persona, Tone, and Action Buttons -->
            <div class="flex flex-col gap-4 mt-4 sm:mt-0 sm:ml-4 flex-shrink-0">
                <!-- Persona and Tone Selections -->
                <div class="flex flex-col sm:flex-row gap-4">
                    <div class="flex-1 min-w-[150px]">
                        <label for="persona-select" class="block mb-1 text-gray-400 text-sm">Story Weaver:</label>
                        <select id="persona-select" class="w-full p-2 bg-gray-700 border border-gray-600 rounded-lg text-white text-base focus:ring-indigo-500 focus:border-indigo-500"></select>
                    </div>
                    <div class="flex-1 min-w-[150px]">
                        <label for="tone-select" class="block mb-1 text-gray-400 text-sm">Tone:</label>
                        <select id="tone-select" class="w-full p-2 bg-gray-700 border border-gray-600 rounded-lg text-white text-base focus:ring-indigo-500 focus:border-indigo-500"></select>
                    </div>
                </div>
                <!-- Action Buttons -->
                <div class="flex flex-wrap justify-center sm:justify-end gap-2 pt-2 border-t border-gray-700">
                    <button id="undo-btn" class="bg-gray-700 hover:bg-gray-600 text-white text-xs py-1 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Undo</button>
                    <button id="redo-btn" class="bg-gray-700 hover:bg-gray-600 text-white text-xs py-1 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Redo</button>
                    <button id="save-story-btn" class="bg-indigo-600 hover:bg-indigo-500 text-white text-xs py-1 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Suggest Title & Save</button>
                    <button id="save-weaver-btn" class="bg-gray-700 hover:bg-gray-600 text-white text-xs py-1 px-3 rounded-lg transition-colors">Save Weaver Chat</button>
                    <button id="save-prompts-btn" class="bg-gray-700 hover:bg-gray-600 text-white text-xs py-1 px-3 rounded-lg transition-colors">Save My Prompts</button>
                    <button id="save-titles-btn" class="bg-gray-700 hover:bg-gray-600 text-white text-xs py-1 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Save Titles</button>
                    <button id="reset-story-btn" class="bg-red-700 hover:bg-red-600 text-white text-xs py-1 px-3 rounded-lg transition-colors">Reset Story</button>
                </div>
            </div>
        </header>

        <!-- Story Display Area -->
        <main id="story-container" class="flex-grow w-full min-h-0 overflow-y-auto p-4 space-y-6 flex flex-col"></main>

        <!-- User Input Area -->
        <footer class="mt-4 pt-4 border-t border-gray-700">
            <div class="relative">
                <textarea id="prompt-input" class="w-full bg-gray-700 text-white rounded-lg p-3 pr-40 focus:ring-2 focus:ring-indigo-500 focus:outline-none transition resize-none" rows="3" placeholder="Write your part of the story here..."></textarea>
                <button id="continue-btn" class="absolute right-3 top-1/2 -translate-y-1/2 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200 shadow-md hover:shadow-lg active:scale-95 flex items-center gap-2 disabled:bg-gray-500 disabled:cursor-not-allowed">
                    <span id="btn-text">Continue Story</span>
                    <svg id="loading-spinner" class="animate-spin h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </button>
            </div>
        </footer>
    </div>

    <!-- Compiled Story Modal -->
    <div id="compiled-story-modal" class="hidden fixed inset-0 bg-black/75 flex items-center justify-center p-4 z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-3xl h-[95vh] flex flex-col">
            <h2 id="modal-title" class="text-xl font-bold mb-4 text-white text-center"></h2>
            <textarea id="compiled-story-textarea" class="flex-grow w-full h-full bg-gray-700 text-white rounded-lg p-3 resize-none focus:ring-2 focus:ring-indigo-500 focus:outline-none transition mb-4"></textarea>
            <div class="flex justify-end gap-3">
                <button id="save-edited-story-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Save Edited Story</button>
                <button id="close-compiled-story-modal-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition-colors">Close</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Element References ---
        const storyContainer = document.getElementById('story-container');
        const promptInput = document.getElementById('prompt-input');
        const continueBtn = document.getElementById('continue-btn');
        const btnText = document.getElementById('btn-text');
        const loadingSpinner = document.getElementById('loading-spinner');
        const saveWeaverBtn = document.getElementById('save-weaver-btn');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const personaSelect = document.getElementById('persona-select');
        const toneSelect = document.getElementById('tone-select');
        const resetStoryBtn = document.getElementById('reset-story-btn');
        const saveStoryBtn = document.getElementById('save-story-btn');
        const savePromptsBtn = document.getElementById('save-prompts-btn');
        const saveTitlesBtn = document.getElementById('save-titles-btn');
        
        // Modal DOM references
        const compiledStoryModal = document.getElementById('compiled-story-modal');
        const compiledStoryTextarea = document.getElementById('compiled-story-textarea');
        const saveEditedStoryBtn = document.getElementById('save-edited-story-btn');
        const closeCompiledStoryModalBtn = document.getElementById('close-compiled-story-modal-btn');
        const modalTitle = document.getElementById('modal-title');


        // --- Application State ---
        let isAITurn = false;
        let isEditing = false;
        let isRegenerating = false;
        let isSuggestingTitle = false;
        let isModalOpen = false;
        let editingParagraphIndex = null;
        let regeneratingAIIndex = null;
        let currentPersonaIndex = 0;
        let currentToneIndex = 0;
        let lastSuggestedTitles = '';

        const MIN_PARAGRAPHS_FOR_SAVE_STORY = 4; // User/AI turns

        // --- Data: Personas and Tones ---
        const personas = [
            { name: "Zen Master (Wisdom)", systemPrompt: "You are the Zen Master...", welcomeMessage: "Welcome, seeker. I am the Zen Master..." },
            { name: "Karma Weaver (Dharma)", systemPrompt: "You are the Karma Weaver...", welcomeMessage: "The threads of destiny await..." },
            { name: "Yoga Sutra Guide (Unity)", systemPrompt: "You are the Yoga Sutra Guide...", welcomeMessage: "Breathe. I am your Yoga Sutra Guide..." },
            { name: "Taoist Sage (Flow)", systemPrompt: "You are the Taoist Sage...", welcomeMessage: "The Way is open. I am the Taoist Sage..." },
            { name: "Bodhi Tree Chronicler (Awakening)", systemPrompt: "You are the Bodhi Tree Chronicler...", welcomeMessage: "Beneath the canopy of thought, I await..." },
        ];
        const tones = [
            { name: "Neutral", description: "a neutral and objective" },
            { name: "Humorous", description: "a funny and lighthearted" },
            { name: "Romantic", description: "a romantic and tender" },
            { name: "Mysterious", description: "a mysterious and suspenseful" },
            { name: "Poetic", description: "a poetic and lyrical" }
        ];

        // --- Story and History Management ---
        const initialSystemPrompt = { role: "user", parts: [{ text: "" }] };
        let storyHistory = [];
        let historyStack = [];
        let historyPointer = -1;

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            populatePersonaSelect();
            populateToneSelect();
            applyCurrentPersonaAndTone();
        });
        
        // --- Core Application Logic ---

        /**
         * Populates the persona and tone dropdowns on load.
         */
        function populatePersonaSelect() {
            personas.forEach((persona, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = persona.name;
                personaSelect.appendChild(option);
            });
        }
        function populateToneSelect() {
            tones.forEach((tone, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = tone.name;
                toneSelect.appendChild(option);
            });
        }

        /**
         * Sets the system prompt and resets the story based on dropdown selections.
         * This is the main initialization and reset function.
         */
        function applyCurrentPersonaAndTone() {
            const selectedPersona = personas[currentPersonaIndex];
            const selectedTone = tones[currentToneIndex];

            const basePrompt = "Crucially, your response should seamlessly continue the story in the same narrative person and style as the preceding text, avoiding direct questions or conversational fillers. Limit your response to 2-3 sentences.";
            initialSystemPrompt.parts[0].text = `${selectedPersona.systemPrompt} Always maintain ${selectedTone.description} tone throughout the story. ${basePrompt}`;

            const dynamicWelcomeMessage = `Greetings from ${selectedPersona.name}. Let us begin our story with ${selectedTone.description} tone. Please write the first sentence or paragraph below.`;
            storyHistory = [
                JSON.parse(JSON.stringify(initialSystemPrompt)),
                { role: "model", parts: [{ text: dynamicWelcomeMessage }] }
            ];

            historyStack = [];
            historyPointer = -1;
            pushToHistory(); 
            updateUIFromHistory();
            promptInput.value = '';
            exitEditMode();
            setLoading(false);
        }

        /**
         * Handles the primary user action: submitting text to continue the story or update a paragraph.
         */
        async function handleUserTurn() {
            const userText = promptInput.value.trim();
            if (!userText || isAITurn || isRegenerating || isSuggestingTitle) return;

            if (isEditing) {
                // If in edit mode, update the existing paragraph
                storyHistory[editingParagraphIndex].parts[0].text = userText;
                // Invalidate subsequent AI responses by truncating the history
                storyHistory = storyHistory.slice(0, editingParagraphIndex + 1);
                exitEditMode();
                pushToHistory();
                updateUIFromHistory();
            } else {
                // Otherwise, add a new user paragraph
                storyHistory.push({ role: 'user', parts: [{ text: userText }] });
                promptInput.value = '';
                setLoading(true);

                try {
                    const aiResponseText = await getAIResponse(storyHistory);
                    storyHistory.push({ role: 'model', parts: [{ text: aiResponseText }] });
                    pushToHistory();
                } catch (error) {
                    console.error("Error getting AI response:", error);
                    addParagraphToUI(`Error: ${error.message}`, 'error');
                    storyHistory.pop(); // Remove the user's turn that led to the error
                } finally {
                    setLoading(false);
                    updateUIFromHistory();
                }
            }
        }

        // --- UI Update and Control Functions ---

        /**
         * Renders the entire story history to the UI.
         */
        function updateUIFromHistory() {
            storyContainer.innerHTML = ''; 

            storyHistory.forEach((part, i) => {
                // Skip rendering the system prompt
                if (i === 0) return;
                addParagraphToUI(part.parts[0].text, part.role, i);
            });

            storyContainer.scrollTop = storyContainer.scrollHeight;
            updateUndoRedoButtons();
            updateSaveButtons();
        }
        
        /**
         * Adds a single paragraph to the UI. Can be a user, model, system, or error message.
         * @param {string} text - The content of the paragraph.
         * @param {string} role - 'user', 'model', 'system-message', or 'error'.
         * @param {number} [index=-1] - The index in storyHistory for attaching controls.
         */
        function addParagraphToUI(text, role, index = -1) {
            const paragraphWrapper = document.createElement('div');
            paragraphWrapper.classList.add('story-paragraph', 'p-4', 'max-w-xl', 'relative', 'group');

            const contentTag = document.createElement('p');
            contentTag.textContent = text;
            
            const authorTag = document.createElement('p');
            authorTag.classList.add('font-bold', 'mb-1', 'text-sm');

            const contentAndAuthorWrapper = document.createElement('div');
            contentAndAuthorWrapper.classList.add('flex', 'flex-col', 'flex-grow');

            if (role === 'user') {
                paragraphWrapper.classList.add('user-paragraph');
                authorTag.classList.add('text-amber-300');
                authorTag.textContent = 'You';
                contentAndAuthorWrapper.appendChild(authorTag);
                contentAndAuthorWrapper.appendChild(contentTag);
                paragraphWrapper.appendChild(contentAndAuthorWrapper);
                // Add edit button
                const editBtn = createControlButton('Edit', () => enterEditMode(index, text));
                paragraphWrapper.appendChild(editBtn);
            } else if (role === 'model') {
                const welcomeMessages = personas.map(p => p.welcomeMessage);
                const isWelcome = welcomeMessages.includes(text);

                paragraphWrapper.classList.add('ai-paragraph');
                authorTag.classList.add('text-indigo-400');
                authorTag.textContent = 'Story Weaver';
                contentAndAuthorWrapper.appendChild(authorTag);
                contentAndAuthorWrapper.appendChild(contentTag);
                paragraphWrapper.appendChild(contentAndAuthorWrapper);
                
                // Don't add controls to the initial welcome message
                if (!isWelcome) {
                    const tryAgainBtn = createControlButton('Try again', () => handleRegenerateAIResponse(index));
                    paragraphWrapper.appendChild(tryAgainBtn);
                }
            } else { // System messages and errors
                paragraphWrapper.classList.add(role === 'error' ? 'error-paragraph' : 'system-message-paragraph');
                contentTag.textContent = text;
                paragraphWrapper.appendChild(contentTag);
            }
            
            storyContainer.appendChild(paragraphWrapper);
        }

        /**
         * Factory function to create control buttons for paragraphs.
         */
        function createControlButton(text, onClick) {
            const button = document.createElement('button');
            button.textContent = text;
            button.classList.add('absolute', 'top-2', 'right-2', 'bg-gray-700', 'hover:bg-gray-600', 'text-white', 'text-xs', 'py-1', 'px-2', 'rounded-md', 'transition-colors', 'opacity-0', 'group-hover:opacity-100');
            button.addEventListener('click', onClick);
            return button;
        }

        function enterEditMode(index, text) {
            if (isAITurn || isModalOpen) return;
            isEditing = true;
            editingParagraphIndex = index;
            promptInput.value = text;
            btnText.textContent = 'Update Story';
            promptInput.focus();
            promptInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
            // Visually indicate which paragraph is being edited
            storyContainer.children[index-1]?.classList.add('ring-2', 'ring-amber-400');
        }

        function exitEditMode() {
            isEditing = false;
            editingParagraphIndex = null;
            btnText.textContent = 'Continue Story';
            document.querySelectorAll('.ring-2').forEach(el => el.classList.remove('ring-2', 'ring-amber-400'));
        }

        function setLoading(isLoading) {
            isAITurn = isLoading;
            continueBtn.disabled = isLoading;
            loadingSpinner.classList.toggle('hidden', !isLoading);
            btnText.classList.toggle('hidden', isLoading);
        }

        function updateUndoRedoButtons() {
            undoBtn.disabled = historyPointer <= 0;
            redoBtn.disabled = historyPointer >= historyStack.length - 1;
        }

        function updateSaveButtons() {
            const hasContent = storyHistory.length > 2; // System prompt + welcome
            const storyIsLongEnough = (storyHistory.length - 2) >= MIN_PARAGRAPHS_FOR_SAVE_STORY;

            saveWeaverBtn.disabled = !hasContent;
            savePromptsBtn.disabled = !hasContent;
            saveStoryBtn.disabled = !storyIsLongEnough;
            saveTitlesBtn.disabled = !lastSuggestedTitles;
        }

        // --- Action Handlers (Buttons, etc.) ---

        function handleUndo() {
            if (historyPointer > 0) {
                historyPointer--;
                storyHistory = JSON.parse(JSON.stringify(historyStack[historyPointer]));
                updateUIFromHistory();
            }
        }

        function handleRedo() {
            if (historyPointer < historyStack.length - 1) {
                historyPointer++;
                storyHistory = JSON.parse(JSON.stringify(historyStack[historyPointer]));
                updateUIFromHistory();
            }
        }
        
        personaSelect.addEventListener('change', (e) => {
            currentPersonaIndex = parseInt(e.target.value);
            applyCurrentPersonaAndTone();
        });
        
        toneSelect.addEventListener('change', (e) => {
            currentToneIndex = parseInt(e.target.value);
            applyCurrentPersonaAndTone();
        });
        
        resetStoryBtn.addEventListener('click', () => applyCurrentPersonaAndTone());

        async function handleRegenerateAIResponse(index) {
            if (isAITurn || isEditing) return;

            setLoading(true);
            isRegenerating = true;
            
            try {
                // Truncate history to the point before the AI response to be regenerated
                const historyForRegen = storyHistory.slice(0, index);
                const newAiResponseText = await getAIResponse(historyForRegen);
                
                // Replace the old response with the new one
                storyHistory[index] = { role: "model", parts: [{ text: newAiResponseText }] };
                
                // If there were user inputs after this, they are now based on an old context.
                // For simplicity, we'll truncate history here. A more complex implementation
                // could try to re-run subsequent user prompts.
                storyHistory = storyHistory.slice(0, index + 1);

                pushToHistory();
            } catch (error) {
                console.error("Error regenerating AI response:", error);
                addParagraphToUI(`Failed to regenerate: ${error.message}`, 'error');
            } finally {
                setLoading(false);
                isRegenerating = false;
                updateUIFromHistory();
            }
        }
        
        // --- API Communication ---

        async function getAIResponse(historyPayload) {
            // IMPORTANT: Replace with your actual API key or use a secure method to provide it.
            // Leaving API keys in client-side code is a security risk.
            const apiKey = ""; // Your API Key for gemini-2.0-flash
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            const payload = { contents: historyPayload };

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                 const errorData = await response.json().catch(() => ({ error: { message: 'An unknown API error occurred.' } }));
                 throw new Error(errorData.error.message || `API Error: ${response.status}`);
            }

            const result = await response.json();
            if (result.candidates && result.candidates[0]?.content?.parts[0]?.text) {
                return result.candidates[0].content.parts[0].text;
            } else {
                throw new Error('Invalid response structure from API.');
            }
        }

        async function getAIResponseForTitle(titlePrompt) {
            const tempHistoryForTitle = [{ role: "user", parts: [{ text: titlePrompt }] }];
            return await getAIResponse(tempHistoryForTitle);
        }

        // --- History Management ---

        function pushToHistory() {
            historyStack = historyStack.slice(0, historyPointer + 1);
            historyStack.push(JSON.parse(JSON.stringify(storyHistory)));
            historyPointer++;
            updateUndoRedoButtons();
        }

        // --- File Saving & Modal Logic ---

        function saveTextToFile(content, filename) {
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function saveWeaverChatHistory() {
            let chatText = `AI Story Weaver Chat\nPersona: ${personas[currentPersonaIndex].name}\nTone: ${tones[currentToneIndex].name}\n\n---\n\n`;
            storyHistory.forEach((part, i) => {
                if (i === 0) return; // Skip system prompt
                const author = part.role === 'user' ? 'You' : 'Story Weaver';
                chatText += `[${author}]:\n${part.parts[0].text}\n\n`;
            });
            saveTextToFile(chatText, 'AI_Story_Weaver_Chat.txt');
        }

        function saveUserPrompts() {
            let promptsText = 'My Story Prompts\n\n---\n\n';
            storyHistory.forEach(part => {
                if (part.role === 'user' && part.parts[0].text !== initialSystemPrompt.parts[0].text) {
                    promptsText += `${part.parts[0].text}\n\n---\n\n`;
                }
            });
            saveTextToFile(promptsText, 'My_Story_Prompts.txt');
        }
        
        async function handleSaveStory() {
            if (isAITurn || isEditing || isRegenerating || isModalOpen) return;
            
            setLoading(true);
            isSuggestingTitle = true;

            let compiledStoryText = '';
            storyHistory.forEach((part, i) => {
                if (i > 1) { // Skip system prompt and welcome message
                   compiledStoryText += part.parts[0].text + '\n\n';
                }
            });
            
            const titlePrompt = `Based on the following story, suggest 5 creative and fitting titles. List them clearly:\n\n"${compiledStoryText}"`;
            
            try {
                const titlesResponse = await getAIResponseForTitle(titlePrompt);
                lastSuggestedTitles = titlesResponse.split('\n').filter(line => line.trim()).join('\n');
                updateSaveButtons();
                addParagraphToUI("Suggested Titles:\n" + lastSuggestedTitles, 'system-message');
                showCompiledStoryModal(compiledStoryText.trim(), "Your Compiled Story");
            } catch (error) {
                console.error("Error suggesting titles:", error);
                addParagraphToUI(`Failed to suggest titles: ${error.message}`, 'error');
            } finally {
                setLoading(false);
                isSuggestingTitle = false;
            }
        }

        function saveSuggestedTitles() {
            if (!lastSuggestedTitles) return;
            saveTextToFile(lastSuggestedTitles, 'Suggested_Story_Titles.txt');
        }

        function showCompiledStoryModal(storyText, title) {
            modalTitle.textContent = title;
            compiledStoryTextarea.value = storyText;
            compiledStoryModal.classList.remove('hidden');
            isModalOpen = true;
        }

        function hideCompiledStoryModal() {
            compiledStoryModal.classList.add('hidden');
            isModalOpen = false;
        }

        function saveCompiledStory() {
            const editedText = compiledStoryTextarea.value;
            saveTextToFile(editedText, 'AI_Story_Weaver_Compiled_Story.txt');
        }
        
        // --- Event Listeners ---
        continueBtn.addEventListener('click', handleUserTurn);
        promptInput.addEventListener('keydown', (e) => {
            // Use Ctrl+Enter or Cmd+Enter for submission
            if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                handleUserTurn();
            }
        });

        saveWeaverBtn.addEventListener('click', saveWeaverChatHistory);
        savePromptsBtn.addEventListener('click', saveUserPrompts);
        saveTitlesBtn.addEventListener('click', saveSuggestedTitles);
        saveStoryBtn.addEventListener('click', handleSaveStory);

        undoBtn.addEventListener('click', handleUndo);
        redoBtn.addEventListener('click', handleRedo);

        saveEditedStoryBtn.addEventListener('click', saveCompiledStory);
        closeCompiledStoryModalBtn.addEventListener('click', hideCompiledStoryModal);

    </script>
</body>
</html>
