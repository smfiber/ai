<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Story Weaver</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- html-to-image library for PNG export (for illustrations) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html-to-image/1.11.11/html-to-image.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .story-paragraph-wrapper { opacity: 0; transform: translateY(20px); animation: fadeIn 0.5s ease-out forwards; }
        @keyframes fadeIn { to { opacity: 1; transform: translateY(0); } }
        .user-paragraph { background-image: linear-gradient(to right, #374151, #2f3743); }
        .ai-paragraph { background-image: linear-gradient(to left, #1e293b, #1a222f); }
        .insight-paragraph { background-image: linear-gradient(to left, #0f766e, #134e4a); color: #f0fdfa; }
        .error-paragraph, .system-message-paragraph { align-self: center; text-align: center; padding: 1rem; border-radius: 0.5rem; font-weight: bold; max-width: 80%; }
        .error-paragraph { background-color: #dc2626; color: #fee2e2; }
        .system-message-paragraph { background-color: #374151; color: #a78bfa; white-space: pre-wrap; }
        #story-container::-webkit-scrollbar, textarea::-webkit-scrollbar, #instructions-modal-content::-webkit-scrollbar { width: 8px; }
        #story-container::-webkit-scrollbar-track, textarea::-webkit-scrollbar-track, #instructions-modal-content::-webkit-scrollbar-track { background: #1f2937; }
        #story-container::-webkit-scrollbar-thumb, textarea::-webkit-scrollbar-thumb, #instructions-modal-content::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        #story-container::-webkit-scrollbar-thumb:hover, textarea::-webkit-scrollbar-thumb:hover, #instructions-modal-content::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        .illustration-container { margin-bottom: 1rem; position: relative; width: 100%; padding-top: 56.25%; /* 16:9 Aspect Ratio */ border-radius: 0.5rem; overflow: hidden; }
        .illustration-container img, .illustration-container .loading-placeholder { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body class="bg-gray-900 text-white h-full flex items-center justify-center p-4 antialiased">
    <div id="app-container" class="w-full max-w-5xl h-[95vh] flex flex-col bg-gray-800 rounded-2xl shadow-2xl p-4 sm:p-6">
        <!-- Header Section -->
        <header class="flex flex-col sm:flex-row justify-between items-start w-full mb-4 pb-4 border-b border-gray-700">
            <div class="flex-shrink-0 mr-6">
                <h1 class="text-xl font-bold text-white flex items-baseline gap-2">
                    AI Story Weaver
                    <!-- NOTE TO DEVS: Remember to increment the version number for each revision. -->
                    <span id="version-number" class="text-xs font-mono bg-gray-700 px-2 py-1 rounded">1.98</span>
                    <button id="help-icon" title="How to Use">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-question-circle text-gray-400 hover:text-white" viewBox="0 0 16 16">
                            <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                            <path d="M5.255 5.786a.237.237 0 0 0 .241.247h.825c.138 0 .248-.113.266-.25.09-.656.54-1.134 1.342-1.134.686 0 1.314.343 1.314 1.168 0 .635-.374.927-.965 1.371-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486.609-.463 1.244-.977 1.244-2.056 0-1.511-1.276-2.241-2.673-2.241-1.267 0-2.655.59-2.75 2.286zm1.557 5.763c0 .533.425.927 1.01.927.609 0 1.028-.394 1.028-.927 0-.552-.42-.94-1.029-.94-.584 0-1.009.388-1.009.94z"/>
                        </svg>
                    </button>
                </h1>
                <p class="text-xs text-gray-400 mt-1 max-w-xs">Collaboratively write stories with an AI partner. Guide the narrative, add your own insights, and illustrate your scenes.</p>
            </div>
            
            <div class="flex-grow flex flex-col items-end gap-2 mt-4 sm:mt-0">
                <div class="flex flex-col sm:flex-row gap-4 w-full justify-end">
                    <div class="flex-1 min-w-[150px] max-w-xs">
                        <label for="persona-select" class="block mb-1 text-gray-400 text-sm">AI Persona:</label>
                        <select id="persona-select" class="w-full p-2 bg-gray-700 border border-gray-600 rounded-lg text-white text-base focus:ring-indigo-500 focus:border-indigo-500"></select>
                    </div>
                    <div class="flex-1 min-w-[150px] max-w-xs">
                        <label for="tone-select" class="block mb-1 text-gray-400 text-sm">Story Tone:</label>
                        <select id="tone-select" class="w-full p-2 bg-gray-700 border border-gray-600 rounded-lg text-white text-base focus:ring-indigo-500 focus:border-indigo-500"></select>
                    </div>
                     <div class="flex-1 min-w-[150px] max-w-xs">
                        <label for="image-style-select" class="block mb-1 text-gray-400 text-sm">Image Style:</label>
                        <select id="image-style-select" class="w-full p-2 bg-gray-700 border border-gray-600 rounded-lg text-white text-base focus:ring-indigo-500 focus:border-indigo-500"></select>
                    </div>
                     <div class="flex-1 min-w-[120px] max-w-xs">
                        <label for="sentence-length-select" class="block mb-1 text-gray-400 text-sm">Sentences:</label>
                        <select id="sentence-length-select" class="w-full p-2 bg-gray-700 border border-gray-600 rounded-lg text-white text-base focus:ring-indigo-500 focus:border-indigo-500"></select>
                    </div>
                </div>
                <div class="flex flex-col items-end gap-2 mt-2">
                    <!-- Row 1: Save buttons -->
                    <div class="flex flex-wrap justify-end gap-2">
                        <button id="save-story-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white text-xs py-1 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Save Story (HTML)</button>
                        <button id="save-weaver-btn" class="bg-gray-700 hover:bg-gray-600 text-white text-xs py-1 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Save Weaver</button>
                        <button id="save-prompts-btn" class="bg-gray-700 hover:bg-gray-600 text-white text-xs py-1 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Save Prompts</button>
                    </div>
                    <!-- Row 2: Action buttons -->
                    <div class="flex flex-wrap justify-end gap-2">
                         <button id="undo-btn" class="bg-gray-700 hover:bg-gray-600 text-white text-xs py-1 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Undo</button>
                         <button id="redo-btn" class="bg-gray-700 hover:bg-gray-600 text-white text-xs py-1 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Redo</button>
                         <button id="reset-story-btn" class="bg-red-700 hover:bg-red-600 text-white text-xs py-1 px-3 rounded-lg transition-colors">New Story</button>
                    </div>
                </div>
            </div>
        </header>

        <!-- Story Display Area -->
        <main id="story-container" class="flex-grow w-full min-h-0 overflow-y-auto p-4 space-y-6 flex flex-col"></main>
        
        <!-- User Input Area -->
        <footer class="mt-4 pt-4 border-t border-gray-700">
            <textarea id="prompt-input" class="w-full bg-gray-700 text-white rounded-lg p-3 focus:ring-2 focus:ring-indigo-500 focus:outline-none transition resize-none" rows="3" placeholder="Add the next part of the story..."></textarea>
            <div class="flex justify-end items-center mt-2 gap-4">
                <button id="continue-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200 shadow-md hover:shadow-lg active:scale-95 flex items-center gap-2 disabled:bg-gray-500 disabled:cursor-not-allowed">
                    <span id="btn-text">Add to Story</span>
                    <svg id="loading-spinner" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </button>
            </div>
        </footer>
    </div>
    
    <!-- Instructions Modal -->
    <div id="instructions-modal" class="hidden fixed inset-0 bg-black/75 flex items-center justify-center p-4 z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-3xl h-[80vh] flex flex-col">
            <!-- NOTE TO DEVS: Remember to update this modal's content with any feature changes. -->
            <h2 class="text-2xl font-bold mb-4 text-white text-center">How to Use AI Story Weaver</h2>
            <div id="instructions-modal-content" class="flex-grow overflow-y-auto pr-4 text-gray-300 space-y-4">
                <div class="prose prose-invert">
                    <h3 class="font-semibold text-white">Core Controls</h3>
                    <ul class="list-disc pl-5 space-y-1">
                        <li><strong>Add to Story:</strong> Submits your text as a prompt for the AI to continue the narrative. This is the main way to build your story turn-by-turn.</li>
                    </ul>
                    <h3 class="font-semibold text-white mt-4">Creative Direction</h3>
                    <ul class="list-disc pl-5 space-y-1">
                        <li><strong>AI Persona:</strong> Choose the AI's personality. This sets the overall narrative style and voice. Changing this will start a new story.</li>
                        <li><strong>Story Tone:</strong> Select the emotional mood of the AI's writing. Changing this will also start a new story.</li>
                        <li><strong>Image Style:</strong> Pick an artistic style for the illustrations you generate.</li>
                        <li><strong>Sentences:</strong> Control the length of the AI's response (1-5 sentences, or Unlimited for a longer response).</li>
                    </ul>
                     <h3 class="font-semibold text-white mt-4">Editing & Refining</h3>
                    <ul class="list-disc pl-5 space-y-1">
                        <li><strong>Edit:</strong> Appears next to your prompts. Click to modify your text.</li>
                        <li><strong>Regen:</strong> Appears next to AI-generated paragraphs. Click to ask the AI for a different response based on the same preceding text.</li>
                        <li><strong>Illustrate:</strong> Appears next to AI-generated paragraphs. Click to generate an image based on the text of that paragraph. You can re-click to get a new image.</li>
                         <li><strong>Undo/Redo:</strong> Step backward or forward through your story's history.</li>
                    </ul>
                     <h3 class="font-semibold text-white mt-4">Saving Your Work</h3>
                    <ul class="list-disc pl-5 space-y-1">
                        <li><strong>Save Story (HTML):</strong> Saves the full story, including dialogue and images, as a self-contained HTML file with a generated title.</li>
                        <li><strong>Save Weaver:</strong> Saves the complete back-and-forth dialogue between you and the AI as a .txt file.</li>
                        <li><strong>Save Prompts:</strong> Saves only your prompts as a .txt file.</li>
                    </ul>
                </div>
            </div>
            <div class="flex justify-end mt-6">
                <button id="close-instructions-modal-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Close</button>
            </div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Element References ---
            const storyContainer = document.getElementById('story-container');
            const promptInput = document.getElementById('prompt-input');
            const continueBtn = document.getElementById('continue-btn');
            const btnText = document.getElementById('btn-text');
            const loadingSpinner = document.getElementById('loading-spinner');
            const personaSelect = document.getElementById('persona-select');
            const toneSelect = document.getElementById('tone-select');
            const imageStyleSelect = document.getElementById('image-style-select');
            const sentenceLengthSelect = document.getElementById('sentence-length-select');
            const resetStoryBtn = document.getElementById('reset-story-btn');
            const saveStoryBtn = document.getElementById('save-story-btn');
            const saveWeaverBtn = document.getElementById('save-weaver-btn');
            const savePromptsBtn = document.getElementById('save-prompts-btn');
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const helpIcon = document.getElementById('help-icon');
            const instructionsModal = document.getElementById('instructions-modal');
            const closeInstructionsModalBtn = document.getElementById('close-instructions-modal-btn');

            // --- Application State ---
            const MAX_PROMPTS = 10;
            let isAITurn = false;
            let isEditing = false;
            let editingParagraphIndex = null;
            let currentPersonaIndex = 0;
            let currentToneIndex = 0;
            let currentImageStyleIndex = 0;
            let currentSentenceLength = 2;

            let storyHistory = [];
            let historyStack = [];
            let historyPointer = -1;

            // --- Persona, Tone, Style & Length Data (Sorted) ---
             const personas = [
                { name: "The Hero/Heroine", systemPrompt: "You are The Hero/Heroine. Generate narrative from the perspective of a protagonist on a journey, facing challenges, and achieving a goal." },
                { name: "The Mentor/Sage", systemPrompt: "You are The Mentor/Sage. Generate narrative as a wise guide who offers advice, training, or magical aid to the hero." },
                { name: "The Villain/Antagonist", systemPrompt: "You are The Villain/Antagonist. Generate narrative as the opposing force, creating conflict and obstacles for the hero." },
                { name: "The Trickster", systemPrompt: "You are The Trickster. Generate narrative as a mischievous character who causes disruption, often for their own amusement or to teach a lesson." },
                { name: "The Innocent", systemPrompt: "You are The Innocent. Generate narrative as a pure, optimistic character who often serves as a moral compass or a source of wonder." },
                { name: "The Explorer", systemPrompt: "You are The Explorer. Generate narrative as a character driven by curiosity and a desire for discovery, often embarking on literal or metaphorical journeys." },
                { name: "The Lover", systemPrompt: "You are The Lover. Generate narrative focusing on themes of romance, intimacy, passion, and emotional connection." },
                { name: "The Rebel/Outlaw", systemPrompt: "You are The Rebel/Outlaw. Generate narrative as a character who challenges societal norms, authority, or established systems." },
                { name: "The Everyman/Everywoman", systemPrompt: "You are The Everyman/Everywoman. Generate narrative as a relatable, ordinary character whose struggles and triumphs reflect common human experiences." },
                { name: "The Caregiver", systemPrompt: "You are The Caregiver. Generate narrative as a nurturing, protective, and compassionate character, often putting others' needs before their own." },
                { name: "The Lore Master/World-Builder", systemPrompt: "You are The Lore Master/World-Builder. Your role is to help users develop intricate world details, histories, and background lore for their stories." },
                { name: "The Idea Generator/Creative Muse", systemPrompt: "You are The Idea Generator/Creative Muse. Focus on brainstorming plot twists, character concepts, unique settings, or overcoming writer's block." },
                { name: "The Genre Specialist", systemPrompt: "You are The Genre Specialist. Generate stories adhering strictly to the conventions of a specific genre (e.g., 'Hard Sci-Fi,' 'Cozy Mystery,' 'Gritty Noir')." },
                { name: "The Dialogue Writer", systemPrompt: "You are The Dialogue Writer. Specialize in generating realistic, character-driven dialogue for specific personas or scenes." },
                { name: "The Emotional Instigator", systemPrompt: "You are The Emotional Instigator. Explore complex emotions, psychological states, and character motivations, often for dramatic effect." },
                { name: "The Ethical Dilemma Presenter", systemPrompt: "You are The Ethical Dilemma Presenter. Craft narratives that explore moral ambiguities, difficult choices, and their consequences." },
                { name: "The Data-Driven Storyteller", systemPrompt: "You are The Data-Driven Storyteller. Weave factual information, statistics, or historical events into a compelling story." },
                { name: "The Interactive Story Guide", systemPrompt: "You are The Interactive Story Guide. Facilitate choose-your-own-adventure style narratives, adapting the story based on user choices." },
                { name: "The Archetype Bender/Deconstructor", systemPrompt: "You are The Archetype Bender/Deconstructor. Intentionally subvert or combine traditional archetypes in novel ways for unique storytelling." },
                { name: "The Style Mimic", systemPrompt: "You are The Style Mimic. Generate stories in the style of a specific author, literary movement, or historical period." }
            ].sort((a, b) => a.name.localeCompare(b.name));

            const tones = [
                { name: "Informative/Explanatory", description: "an informative and explanatory" },
                { name: "Neutral/Objective", description: "a neutral and objective" },
                { name: "Formal", description: "a formal" },
                { name: "Enthusiastic/Optimistic", description: "an enthusiastic and optimistic" },
                { name: "Descriptive/Evocative", description: "a descriptive and evocative" },
                { name: "Mysterious/Suspenseful", description: "a mysterious and suspenseful" },
                { name: "Whimsical/Fantastical", description: "a whimsical and fantastical" },
                { name: "Melancholic/Somber", description: "a melancholic and somber" },
                { name: "Humorous/Playful", description: "a humorous and playful" },
                { name: "Dramatic/Intense", description: "a dramatic and intense" },
                { name: "Sarcastic/Ironic", description: "a sarcastic and ironic" },
                { name: "Cynical/Skeptical", description: "a cynical and skeptical" },
                { name: "Nostalgic", description: "a nostalgic" },
                { name: "Urgent/Pressing", description: "an urgent and pressing" },
                { name: "Philosophical/Reflective", description: "a philosophical and reflective" },
                { name: "Gritty/Realistic", description: "a gritty and realistic" },
                { name: "Empathetic/Compassionate", description: "an empathetic and compassionate" },
                { name: "Authoritative/Confident", description: "an authoritative and confident" },
                { name: "Playful/Flirty", description: "a playful and flirty" },
                { name: "Foreboding/Ominous", description: "a foreboding and ominous" }
            ].sort((a, b) => a.name.localeCompare(b.name));

             const imageStyles = [
                { name: "3D Model", prefix: "A professional 3D model of {placeholder}, rendered in a cinematic style with dynamic lighting, suitable for a portfolio, 8k, octane render." },
                { name: "Anime", prefix: "A vibrant, high-quality anime screenshot of {placeholder}, cinematic lighting, detailed, by Studio Ghibli and Makoto Shinkai." },
                { name: "Art Deco", prefix: "An elegant art deco illustration of {placeholder}, featuring geometric patterns, bold lines, and a luxurious feel, 1920s style." },
                { name: "Blueprint", prefix: "A detailed blueprint diagram of {placeholder}, with annotations, measurements, and technical specifications on a blue background." },
                { name: "Charcoal Sketch", prefix: "A dramatic charcoal sketch of {placeholder} on textured paper, with deep blacks, high contrast, and expressive strokes." },
                { name: "Cubism", prefix: "A cubist painting of {placeholder}, fragmented and abstracted, showing the subject from multiple viewpoints, in the style of Picasso." },
                { name: "Cyberpunk", prefix: "A neon-drenched cyberpunk city scene featuring {placeholder}, with towering skyscrapers, holographic ads, and a Blade Runner aesthetic." },
                { name: "Fantasy Art", prefix: "An epic fantasy art painting of {placeholder}, with dramatic lighting, mystical elements, and a high level of detail, in the style of Frank Frazetta." },
                { name: "Gothic Art", prefix: "A dark and moody gothic art piece depicting {placeholder}, with dramatic shadows, intricate details, and a sense of sublime horror." },
                { name: "Highly Detailed", prefix: "An extremely detailed, intricate illustration of {placeholder}, hyper-realistic, 8k resolution, sharp focus." },
                { name: "Impressionism", prefix: "An impressionist painting of {placeholder}, with visible brush strokes, soft focus, and an emphasis on light and its changing qualities, in the style of Monet." },
                { name: "Infographic", prefix: "Create a clean, professional infographic about '{placeholder}'. CRITICAL: ALL TEXT MUST BE SPELLED CORRECTLY. Double-check all spelling. Use clear, legible fonts, icons, and charts to present the information." },
                { name: "Minimalist", prefix: "A minimalist, simple line drawing of {placeholder}, clean and elegant, with plenty of negative space." },
                { name: "Oil Painting", prefix: "A classic oil painting of {placeholder}, with rich colors, deep shadows, and visible canvas texture, in the style of Rembrandt." },
                { name: "Photorealistic", prefix: "A photorealistic, cinematic, 4k, high-resolution photograph of {placeholder}, sharp focus, professional quality." },
                { name: "Pixel Art", prefix: "A detailed 16-bit pixel art scene of {placeholder}, vibrant colors, in the style of a classic SNES RPG." },
                { name: "Pop Art", prefix: "A pop art image of {placeholder}, with bold colors, thick outlines, and a comic book feel, in the style of Andy Warhol." },
                { name: "Rococo", prefix: "An ornate Rococo painting of {placeholder}, with soft colors, curving lines, and themes of love and nature." },
                { name: "Steampunk", prefix: "A detailed steampunk illustration of {placeholder}, featuring gears, cogs, steam pipes, and Victorian-era technology." },
                { name: "Surreal", prefix: "A surrealist painting of {placeholder}, dreamlike and bizarre, with unexpected juxtapositions, in the style of Salvador Dali." },
                { name: "Synthwave", prefix: "A synthwave art piece of {placeholder}, with neon grids, a retro-futuristic aesthetic, and a 1980s color palette of pink and blue." },
                { name: "Tribal Art", prefix: "A tribal art depiction of {placeholder}, using traditional patterns, earthy colors, and symbolic imagery." },
                { name: "Vintage Photo", prefix: "A vintage, sepia-toned photograph of {placeholder} from the 1940s, with a soft focus and film grain." },
                { name: "Watercolor", prefix: "A beautiful watercolor painting of {placeholder}, with soft, translucent colors, and a gentle, blended look." }
            ].sort((a, b) => a.name.localeCompare(b.name));
            
            const sentenceLengths = [1, 2, 3, 4, 5, 0]; // 0 represents "Unlimited"

            // --- Core Functions ---

            function initializeApp() {
                populatePersonaSelect();
                populateToneSelect();
                populateImageStyleSelect();
                populateSentenceLengthSelect();
                
                currentPersonaIndex = personas.findIndex(p => p.name === "The Hero/Heroine");
                currentToneIndex = tones.findIndex(t => t.name === "Descriptive/Evocative");
                personaSelect.value = currentPersonaIndex;
                toneSelect.value = currentToneIndex;
                sentenceLengthSelect.value = 2;

                resetApp();
            }

            function resetApp() {
                storyContainer.innerHTML = '';
                storyHistory = [ ];
                historyStack = [ JSON.parse(JSON.stringify(storyHistory)) ];
                historyPointer = 0;
                isEditing = false;
                editingParagraphIndex = null;
                
                updateUIFromHistory();
                displaySystemMessage("Provide a prompt to begin your story.", 'system-message');
                promptInput.focus();
            }
            
            function getSystemInstructionString() {
                const selectedPersona = personas[currentPersonaIndex];
                const selectedTone = tones[currentToneIndex];
                let lengthConstraint = `Limit your response to exactly ${currentSentenceLength} sentence(s).`;
                if(currentSentenceLength == 0) {
                     lengthConstraint = "There is no limit to the length of your response.";
                }
                return `${selectedPersona.systemPrompt} Continue the story based on the user's prompt. The story should have ${selectedTone.description} tone. ${lengthConstraint}`;
            }

            function populateSelect(selectElement, dataArray) {
                selectElement.innerHTML = '';
                dataArray.forEach((item, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = item.name || item;
                    if(item === 0) option.textContent = "Unlimited";
                    selectElement.appendChild(option);
                });
            }

            function populatePersonaSelect() { populateSelect(personaSelect, personas); }
            function populateToneSelect() { populateSelect(toneSelect, tones); }
            function populateImageStyleSelect() { populateSelect(imageStyleSelect, imageStyles); }
            function populateSentenceLengthSelect() { populateSelect(sentenceLengthSelect, sentenceLengths); }

            async function handleContinueStory() {
                const userPrompt = promptInput.value.trim();
                if (!userPrompt || isAITurn || (getUserPromptCount() >= MAX_PROMPTS && currentSentenceLength !== 0)) return;

                setLoading(true);

                if (isEditing) {
                    storyHistory[editingParagraphIndex].parts[0].text = userPrompt;
                    storyHistory.splice(editingParagraphIndex + 1);
                } else {
                    storyHistory.push({ role: 'user', parts: [{ text: userPrompt }] });
                }
                
                promptInput.value = '';
                isEditing = false;
                editingParagraphIndex = null;
                updateUIFromHistory();

                try {
                    const aiResponseText = await getAIResponse(storyHistory, getSystemInstructionString());
                    storyHistory.push({ role: 'model', parts: [{ text: aiResponseText }] });
                    pushToHistory();
                } catch (error) {
                    console.error("Error continuing story:", error);
                     if (error.message.includes("overloaded")) {
                        displaySystemMessage("The AI model is currently busy. Please try again in a moment.", 'error');
                    } else {
                        displaySystemMessage(error.message, 'error');
                    }
                    storyHistory.pop();
                } finally {
                    setLoading(false);
                    updateUIFromHistory();
                }
            }

            // --- UI & Display ---

            function updateUIFromHistory() {
                storyContainer.innerHTML = '';
                storyHistory.forEach((part, i) => {
                    addParagraphToUI(part, i);
                });
                storyContainer.scrollTop = storyContainer.scrollHeight;
                updateButtonStates();
                if (!promptInput.disabled) {
                    promptInput.focus();
                }
            }
            
            function addParagraphToUI(part, index) {
                const { role, parts, imageUrl } = part;
                const text = parts[0].text;

                const wrapper = document.createElement('div');
                wrapper.classList.add('story-paragraph-wrapper', 'flex', 'items-start', 'gap-4');
                wrapper.dataset.role = role; 
                
                const paragraphContent = document.createElement('div');
                paragraphContent.classList.add('flex-grow', 'p-4', 'rounded-lg', 'w-full');
                
                if (imageUrl) {
                    const imageContainer = document.createElement('div');
                    imageContainer.classList.add('illustration-container');
                    const img = new Image();
                    img.crossOrigin = "anonymous";
                    img.src = imageUrl;
                    img.alt = "Generated illustration of the scene";
                    img.className = 'w-full h-full';
                    imageContainer.appendChild(img);
                    paragraphContent.insertBefore(imageContainer, paragraphContent.firstChild);
                }

                const contentTag = document.createElement('p');
                contentTag.textContent = text;
                paragraphContent.appendChild(contentTag);

                const controlsContainer = document.createElement('div');
                controlsContainer.classList.add('flex-shrink-0', 'py-4', 'flex', 'flex-col', 'gap-2');

                if (role === 'user') {
                    wrapper.classList.add('justify-start');
                    paragraphContent.classList.add('user-paragraph', 'rounded-bl-none');
                    const editBtn = createControlButton('Edit', () => enterEditMode(index, text));
                    controlsContainer.appendChild(editBtn);
                    wrapper.appendChild(paragraphContent);
                    wrapper.appendChild(controlsContainer);
                } else {
                    wrapper.classList.add('justify-end');
                    paragraphContent.classList.add('ai-paragraph', 'rounded-br-none');
                    
                    const regenBtn = createControlButton('Regen', () => handleRegenerate(index));
                    controlsContainer.appendChild(regenBtn);

                    const illustrateBtn = createControlButton('Illustrate', () => handleIllustration(index));
                    controlsContainer.appendChild(illustrateBtn);
                    wrapper.appendChild(controlsContainer);
                    wrapper.appendChild(paragraphContent);
                }
                storyContainer.appendChild(wrapper);
            }
            
            function createControlButton(text, onClick) {
                const button = document.createElement('button');
                button.textContent = text;
                button.classList.add('bg-gray-600', 'hover:bg-gray-500', 'text-white', 'text-xs', 'py-1', 'px-2', 'rounded-md', 'transition-colors');
                button.addEventListener('click', onClick);
                return button;
            }

            function displaySystemMessage(text, type = 'system-message') {
                storyContainer.querySelectorAll('.system-message-paragraph, .error-paragraph').forEach(el => el.remove());
                const messageWrapper = document.createElement('div');
                messageWrapper.classList.add('story-paragraph-wrapper', type === 'error' ? 'error-paragraph' : 'system-message-paragraph');
                messageWrapper.innerHTML = text.replace(/\n/g, '<br>');
                storyContainer.appendChild(messageWrapper);
                storyContainer.scrollTop = storyContainer.scrollHeight;
            }

            // --- Edit, Regenerate, Illustrate ---

            function enterEditMode(index, text) {
                if(isAITurn) return;
                isEditing = true;
                editingParagraphIndex = index;
                promptInput.value = text;
                btnText.textContent = 'Update';
                promptInput.focus();
                updateButtonStates();
            }

            async function handleRegenerate(index) {
                if (isAITurn) return;
                setLoading(true);
                
                const historyForRegen = storyHistory.slice(0, index);
                
                try {
                    const newAiResponse = await getAIResponse(historyForRegen, getSystemInstructionString());
                    storyHistory[index].parts[0].text = newAiResponse;
                    storyHistory.splice(index + 1);
                    pushToHistory();
                } catch (error) {
                    console.error("Error regenerating:", error);
                    displaySystemMessage(error.message, 'error');
                } finally {
                    setLoading(false);
                    updateUIFromHistory();
                }
            }
            
            async function handleIllustration(index) {
                 if (isAITurn) return;
                 setLoading(true);
                 
                 const sceneText = storyHistory[index].parts[0].text;
                 const paragraphWrapper = storyContainer.children[index];
                 const paragraphContent = paragraphWrapper.querySelector('.flex-grow');

                 let imageContainer = paragraphContent.querySelector('.illustration-container');
                 if (!imageContainer) {
                     imageContainer = document.createElement('div');
                     imageContainer.classList.add('illustration-container');
                     paragraphContent.insertBefore(imageContainer, paragraphContent.firstChild);
                 }
                 
                 imageContainer.innerHTML = `<div class="loading-placeholder flex items-center justify-center bg-gray-700 text-center p-4"><svg class="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></div>`;

                 try {
                    const style = imageStyles[currentImageStyleIndex];
                    const imagePrompt = style.prefix.replace('{placeholder}', sceneText);
                    const imageUrl = await generateImage(imagePrompt);
                    
                    const img = new Image();
                    img.crossOrigin = "anonymous";
                    img.src = imageUrl;
                    img.alt = "Generated illustration of the scene";
                    imageContainer.innerHTML = '';
                    imageContainer.appendChild(img);

                    storyHistory[index].imageUrl = imageUrl;
                    pushToHistory();
                 } catch(error) {
                    console.error("Error generating image:", error);
                    imageContainer.innerHTML = `<p class="text-red-400 text-center p-2">Image generation failed.</p>`;
                 } finally {
                    setLoading(false);
                 }
            }
            
            // --- Saving & Export ---

            function saveAsTxt(textContent, filename) {
                const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            async function saveStoryAsHtml() {
                setLoading(true);
                displaySystemMessage("Generating story title...", "system-message");
                let storyTitle = "My AI-Woven Story";
                try {
                    const titlePrompt = "Based on the following story, provide a short, creative title. Respond with only the title text, without any quotation marks or labels.";
                    storyTitle = await getAIResponse(storyHistory, titlePrompt);
                } catch (error) {
                    console.error("Could not generate a title, using default.", error);
                }

                setLoading(false);
                displaySystemMessage("Saving story...", "system-message");
                
                const personaName = personas[currentPersonaIndex].name;
                const toneName = tones[currentToneIndex].name;

                let storyHtml = `
<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>${storyTitle}</title><style>body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";background-color:#111827;color:#f9fafb;padding:2rem;line-height:1.6}.container{max-width:800px;margin:auto}h1,h2{color:#e5e7eb;border-bottom:1px solid #374151;padding-bottom:.5rem}h1{font-size:2.25rem}h2{font-size:1.5rem;margin-top:2rem}.meta-info{background-color:#1f2937;padding:1rem;border-radius:.5rem;margin-bottom:2rem;font-size:.9rem;color:#d1d5db}.story-part{padding:1rem;margin-bottom:1rem;border-radius:.75rem;max-width:90%;display:flex;flex-direction:column}.story-part p{margin:0;white-space:pre-wrap}.story-part img{max-width:100%;border-radius:.5rem;margin-bottom:1rem;object-fit:contain;align-self:center}.user-paragraph{background-color:#374151;margin-right:auto;border-bottom-left-radius:0}.ai-paragraph{background-color:#1e293b;margin-left:auto;align-items:flex-end;text-align:left;border-bottom-right-radius:0}</style></head><body><div class="container"><h1>${storyTitle}</h1><div class="meta-info"><strong>AI Persona:</strong> ${personaName}<br><strong>Story Tone:</strong> ${toneName}</div><h2>The Story</h2>`;

                storyHistory.forEach((part) => {
                    const { role, parts, imageUrl } = part;
                    const text = parts[0].text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    let roleClass = role === 'user' ? 'user-paragraph' : 'ai-paragraph';
                    storyHtml += `<div class="story-part ${roleClass}">`;
                    if (imageUrl) {
                        storyHtml += `<img src="${imageUrl}" alt="Story illustration">`;
                    }
                    storyHtml += `<p>${text}</p></div>`;
                });

                storyHtml += `</div></body></html>`;

                const blob = new Blob([storyHtml], { type: 'text/html;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${storyTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.html`;
                a.click();
                URL.revokeObjectURL(url);
            }

            // --- History & State Management ---

            function pushToHistory() {
                historyStack = historyStack.slice(0, historyPointer + 1);
                historyStack.push(JSON.parse(JSON.stringify(storyHistory)));
                historyPointer++;
                updateButtonStates();
            }

            function handleUndo() {
                if (historyPointer > 0) {
                    historyPointer--;
                    storyHistory = JSON.parse(JSON.stringify(historyStack[historyPointer]));
                    updateUIFromHistory();
                }
            }

            function handleRedo() {
                if (historyPointer < historyStack.length - 1) {
                    historyPointer++;
                    storyHistory = JSON.parse(JSON.stringify(historyStack[historyPointer]));
                    updateUIFromHistory();
                }
            }

            function getUserPromptCount() {
                return storyHistory.filter(p => p.role === 'user').length;
            }

            function updateButtonStates() {
                const promptCount = getUserPromptCount();
                const isStoryComplete = promptCount >= MAX_PROMPTS && currentSentenceLength !== 0;
                const canSaveStory = storyHistory.length > 0;
                
                const isBusy = isAITurn;
                
                continueBtn.disabled = isBusy || isStoryComplete || isEditing;
                
                if(isEditing) {
                    btnText.textContent = 'Update';
                } else {
                     btnText.textContent = 'Add to Story';
                }

                if (isStoryComplete && !isBusy) {
                    promptInput.placeholder = "Max prompts reached! You can save your story now.";
                    promptInput.disabled = true;
                } else {
                    const countText = currentSentenceLength === 0 ? '' : ` of ${MAX_PROMPTS}`;
                    promptInput.placeholder = `Add prompt ${promptCount + 1}${countText}...`;
                    promptInput.disabled = isBusy;
                }

                undoBtn.disabled = isBusy || historyPointer <= 0;
                redoBtn.disabled = isBusy || historyPointer >= historyStack.length - 1;
                
                saveStoryBtn.disabled = isBusy || !canSaveStory;
                saveWeaverBtn.disabled = isBusy || storyHistory.length < 1;
                savePromptsBtn.disabled = isBusy || promptCount < 1;
            }
            
            function setLoading(isLoading) {
                isAITurn = isLoading;
                loadingSpinner.classList.toggle('hidden', !isLoading);
                continueBtn.disabled = isLoading;
                updateButtonStates();
            }

            // --- API Calls ---
            
            async function getAIResponse(chatHistory, systemInstruction) {
                const apiKey = "AIzaSyA29N25PG96j0NURl1m-Hn8ydX9P_X97kY"; 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                
                const messagesForAPI = chatHistory.map(({role, parts}) => ({role, parts}));

                // Use a different approach for the title generation to not modify the history
                if (systemInstruction.includes("provide a short, creative title")) {
                    const titleGenerationPayload = {
                        contents: [...messagesForAPI, {role: 'user', parts: [{text: systemInstruction}]}]
                    };
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(titleGenerationPayload) });
                    if (!response.ok) { throw new Error("API request for title failed."); }
                    const result = await response.json();
                    return result.candidates?.[0]?.content?.parts?.[0]?.text || "Untitled Story";

                } else {
                     const firstUserMessageIndex = messagesForAPI.findIndex(msg => msg.role === 'user');
                    if (firstUserMessageIndex !== -1) {
                        messagesForAPI[firstUserMessageIndex].parts[0].text = 
                            `${systemInstruction}\n\n${messagesForAPI[firstUserMessageIndex].parts[0].text}`;
                    } else {
                        messagesForAPI.unshift({ role: 'user', parts: [{ text: systemInstruction }] });
                    }
                }

                const payload = { contents: messagesForAPI };
                
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error("AI response API error:", errorText);
                    const errorData = JSON.parse(errorText || "{}");
                    throw new Error(errorData?.error?.message || `API request failed with status ${response.status}`);
                }

                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    console.error("Unexpected AI response format:", result);
                    throw new Error(`Unexpected API response format.`);
                }
            }
            
             async function generateImage(prompt) {
                const apiKey = "AIzaSyA29N25PG96j0NURl1m-Hn8ydX9P_X97kY";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;
                
                const payload = {
                    instances: [{ "prompt": prompt }],
                    parameters: { "sampleCount": 1 }
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error("Image generation API error:", errorText);
                    throw new Error(`Image generation failed with status: ${response.status}`);
                }

                const result = await response.json();
                
                if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                    return `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                } else {
                    console.error("Unexpected image generation response:", result);
                    throw new Error('Could not retrieve image from API response.');
                }
            }
            
            // --- Event Listeners ---
            continueBtn.addEventListener('click', handleContinueStory);
            promptInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleContinueStory();
                }
            });
            
            resetStoryBtn.addEventListener('click', resetApp);
            
            saveStoryBtn.addEventListener('click', () => saveStoryAsHtml());
            saveWeaverBtn.addEventListener('click', () => {
                const weaverText = storyHistory
                    .map(p => {
                        let author = p.role === 'user' ? 'You' : 'AI Story Weaver';
                        return `[${author}]:\n${p.parts[0].text}`
                    })
                    .join('\n\n');
                saveAsTxt(weaverText, 'Weaver-Chat.txt');
            });
             savePromptsBtn.addEventListener('click', () => {
                const promptsText = storyHistory
                    .filter(p => p.role === 'user')
                    .map((p, i) => `Prompt ${i + 1}:\n${p.parts[0].text}`)
                    .join('\n\n---\n\n');
                saveAsTxt(promptsText, 'My-Prompts.txt');
            });

            undoBtn.addEventListener('click', handleUndo);
            redoBtn.addEventListener('click', handleRedo);
            helpIcon.addEventListener('click', () => { instructionsModal.classList.remove('hidden'); });
            closeInstructionsModalBtn.addEventListener('click', () => { instructionsModal.classList.add('hidden'); });
            instructionsModal.addEventListener('click', (e) => {
                if (e.target === instructionsModal) {
                    instructionsModal.classList.add('hidden');
                }
            });

            personaSelect.addEventListener('change', (e) => { currentPersonaIndex = parseInt(e.target.value); resetApp() });
            toneSelect.addEventListener('change', (e) => { currentToneIndex = parseInt(e.target.value); resetApp() });
            imageStyleSelect.addEventListener('change', (e) => { currentImageStyleIndex = parseInt(e.target.value); });
            sentenceLengthSelect.addEventListener('change', (e) => { currentSentenceLength = parseInt(e.target.value); resetApp(); });


            // --- Initialization ---
            initializeApp();
        });
    </script>
</body>
</html>
