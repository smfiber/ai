<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-900">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Whiteboard & Chat</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts & Font Awesome -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Base styles */
        body { font-family: 'Inter', sans-serif; }
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }

        /* Main Layout */
        #main-layout { display: flex; height: 100vh; width: 100vw; }
        #chat-container { width: 700px; flex-shrink: 0; background-color: #1f2937; display: flex; flex-direction: column; padding: 1rem; border-right: 2px solid #374151; }
        #whiteboard-wrapper { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }
        
        /* Chat Box Styles */
        #chat-header { font-size: 1.5rem; font-weight: bold; color: white; margin-bottom: 1rem; text-align: center; border-bottom: 1px solid #4b5563; padding-bottom: 0.5rem;}
        #chat-messages { flex-grow: 1; overflow-y: auto; font-family: Arial, sans-serif; font-size: 16px; line-height: 1.15; color: white;}
        .chat-message { margin-bottom: 1rem; display: flex; align-items: flex-start; }
        .chat-avatar { width: 40px; height: 40px; border-radius: 50%; margin-right: 10px; background-color: #4b5563; object-fit: cover;}
        .chat-content { display: flex; flex-direction: column; max-width: calc(100% - 50px); }
        .chat-author { font-weight: bold; color: #a5b4fc; font-size: 0.8rem; margin-bottom: 2px;  word-break: break-all; }
        .chat-text { word-wrap: break-word; white-space: pre-wrap; }
        .chat-image { max-width: 100%; border-radius: 0.5rem; cursor: pointer; }
        #chat-input-area { display: flex; margin-top: 1rem; flex-wrap: wrap; }
        #chat-input {
            flex-grow: 1; background: #374151; border: 1px solid #4b5563;
            color: white; padding: 0.5rem; border-radius: 0.5rem; 
            outline: none; resize: none; height: 4rem; width: 100%; margin-bottom: 0.5rem;
        }
        .chat-btn { background: #4f46e5; color: white; padding: 0 1rem; border-radius: 0.5rem; border: none; cursor: pointer; height: 2.5rem; display: flex; align-items: center; justify-content: center;}
        .chat-btn:hover { background: #4338ca; }
        
        /* Whiteboard Styles */
        #app-container { width: 100%; height: 100%; display: flex; flex-direction: column; background-color: #111827; padding: 1rem; }
        #main-content { position: relative; flex-grow: 1; background-color: #1f2937; } /* bg-gray-800 equivalent */
        #whiteboard, #overlay-canvas, #event-capture-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #whiteboard { z-index: 1; }
        #overlay-canvas { z-index: 2; pointer-events: none; }
        #event-capture-layer { z-index: 3; }
        .tool-btn, .color-swatch, .size-btn { transition: all 0.1s ease-in-out; }
        .tool-btn.selected, .size-btn.selected { background-color: #4f46e5; color: white; transform: scale(1.1); }
        .tool-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .color-swatch.parent-selected { box-shadow: 0 0 0 2px white, 0 0 0 4px var(--tw-color-ring); }
        .shade-swatch.selected { box-shadow: 0 0 0 2px white, 0 0 0 4px #4f46e5; transform: scale(1.1); }
        #text-input-container { position: absolute; display: none; z-index: 20; }
        #text-input { background: #1f2937; border: 1px dashed #6b7280; color: white; outline: none; padding: 4px; border-radius: 4px; }
        #delete-btn:disabled, #front-btn:disabled, #duplicate-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        #whiteboard-title, #whiteboard-description { cursor: default; }
        
        /* Dropdown menus */
        .dropdown { position: relative; }
        .dropdown-content { visibility: hidden; opacity: 0; transform: translateY(-10px); transition: all 0.2s ease-out; position: absolute; top: 115%; left: 50%; transform: translateX(-50%) translateY(0px); z-index: 50; }
        .dropdown:hover .dropdown-content { visibility: visible; opacity: 1; transform: translateX(-50%) translateY(0); }
        .dropdown-content .tool-btn { white-space: nowrap; }
        .dropdown-content .tool-btn:hover { background-color: #4b5563; transform: scale(1.1); }

        /* Effects & Modals */
        #flash-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9998; pointer-events: none; opacity: 0; animation: flash-animation 0.8s ease-out forwards; }
        @keyframes flash-animation { 0% { opacity: 0; } 25% { opacity: 0.7; } 50% { opacity: 0; } 75% { opacity: 0.7; } 100% { opacity: 0; } }
        .effect-particle { position: absolute; pointer-events: none; z-index: 9999; animation: float-up 5s linear forwards; font-size: 2rem; background-color: transparent !important; }
        @keyframes float-up { from { transform: translateY(0); opacity: 1; } to { transform: translateY(-100vh); opacity: 0; } }
        
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; display: flex; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        .modal-overlay.visible { opacity: 1; pointer-events: auto; }
        .modal { background-color: #1f2937; color: white; padding: 2rem; border-radius: 1rem; width: 90%; max-width: 600px; max-height: 80vh; overflow-y: auto; position: relative; }
        #image-viewer-modal img { max-width: 90vw; max-height: 90vh; }
    </style>
</head>
<body class="bg-gray-900 text-white antialiased">
    <div id="main-layout">
        <!-- Chat Column -->
        <div id="chat-container">
            <div class="flex justify-between items-center mb-4">
                <h2 id="chat-header" class="flex-grow text-center">Live Chat</h2>
                <div class="flex gap-2">
                     <button id="save-chat-btn" class="chat-btn" title="Save Chat History"><i class="fa-solid fa-save"></i></button>
                     <button id="clear-chat-btn" class="chat-btn" title="Clear Chat History"><i class="fa-solid fa-trash"></i></button>
                </div>
            </div>
            <div id="chat-messages" class="flex-grow"></div>
            <div id="chat-input-area">
                <textarea id="chat-input" placeholder="Say something... (Shift+Enter for new line)"></textarea>
                <div class="flex justify-between w-full">
                    <button id="ai-image-btn" class="chat-btn"><i class="fa-solid fa-wand-magic-sparkles"></i> &nbsp; AI Image</button>
                    <button id="chat-send-btn" class="chat-btn"><i class="fa-solid fa-paper-plane"></i> &nbsp; Send</button>
                </div>
            </div>
        </div>

        <!-- Whiteboard Column -->
        <div id="whiteboard-wrapper">
            <div id="app-container">
                <!-- Header -->
                <header class="flex flex-col md:flex-row justify-between items-start mb-4 pb-4 border-b border-gray-700">
                    <div>
                        <h1 id="whiteboard-title" class="text-2xl font-bold text-white rounded px-1"></h1>
                        <p id="whiteboard-description" class="text-sm text-gray-400 rounded px-1"></p>
                    </div>
                     <div class="flex flex-col items-end mt-2 md:mt-0 text-xs text-gray-500 space-y-2">
                        <div>User: <span id="userId" class="font-mono bg-gray-700 px-2 py-1 rounded">Loading...</span></div>
                        <div>Version: <span id="version-number" class="font-mono bg-gray-700 px-2 py-1 rounded">1.25</span></div>
                         <button id="help-btn" class="p-2 text-blue-400 hover:text-blue-500 text-2xl" title="Help"><i class="fa-solid fa-circle-question"></i></button>
                    </div>
                </header>
                <!-- Toolbar -->
                <div id="toolbar" class="flex flex-wrap items-center justify-center gap-x-4 gap-y-2 mb-4">
                     <div id="tool-selector" class="flex items-center gap-2 bg-gray-700 p-1 rounded-lg">
                        <button data-tool="select" class="tool-btn p-2" title="Select & Move"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 3l7 19 2.5-7.5L22 3z"/></svg></button>
                        <button data-tool="pen" class="tool-btn selected p-2" title="Pen"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg></button>
                        <div class="dropdown">
                             <button class="tool-btn p-2" title="Shapes"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path></svg></button>
                             <div class="dropdown-content flex flex-col items-start gap-1 p-2 rounded-md bg-gray-600 shadow-lg">
                                <button data-tool="line" class="tool-btn p-2" title="Line"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="19" x2="19" y2="5"></line></svg></button>
                                <button data-tool="rectangle" class="tool-btn p-2" title="Rectangle"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/></svg></button>
                                <button data-tool="circle" class="tool-btn p-2" title="Circle"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/></svg></button>
                                <button data-tool="triangle" class="tool-btn p-2" title="Triangle"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 20h18L12 4z"/></svg></button>
                             </div>
                        </div>
                        <button data-tool="text" class="tool-btn p-2" title="Text"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg></button>
                    </div>
                     <div class="flex items-center gap-2 bg-gray-700 p-1 rounded-lg">
                        <button id="undo-btn" class="tool-btn p-2" title="Undo" disabled><i class="fa-solid fa-undo"></i></button>
                        <button id="redo-btn" class="tool-btn p-2" title="Redo" disabled><i class="fa-solid fa-redo"></i></button>
                    </div>
                     <div class="flex items-center gap-2 bg-gray-700 p-1 rounded-lg">
                        <button id="duplicate-btn" class="tool-btn p-2 text-green-400 hover:text-green-500" title="Duplicate Selected" disabled><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button>
                        <button id="front-btn" class="tool-btn p-2 text-blue-400 hover:text-blue-500" title="Bring to Front" disabled><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg></button>
                        <button id="delete-btn" class="tool-btn p-2 text-red-400 hover:text-red-500" title="Delete Selected" disabled><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg></button>
                    </div>
                     <div class="flex items-center gap-2 bg-gray-700 p-1 rounded-lg">
                        <button id="toggle-grid-btn" class="tool-btn p-2 selected" title="Toggle Grid"><i class="fa-solid fa-border-all"></i></button>
                        <button id="toggle-snap-btn" class="tool-btn p-2 selected" title="Toggle Snapping"><i class="fa-solid fa-magnet"></i></button>
                    </div>
                    <div id="brush-size-selector" class="flex items-center gap-2 bg-gray-700 p-1 rounded-lg">
                         <button data-size="2" class="size-btn selected p-2" title="Small"><div class="w-1.5 h-1.5 bg-white rounded-full"></div></button>
                         <button data-size="5" class="size-btn p-2" title="Medium"><div class="w-2.5 h-2.5 bg-white rounded-full"></div></button>
                         <button data-size="10" class="size-btn p-2" title="Large"><div class="w-4 h-4 bg-white rounded-full"></div></button>
                    </div>
                    <div id="color-palette" class="flex items-end gap-2"></div>
                    <div class="flex items-center gap-2">
                        <div class="dropdown">
                            <button class="p-2 bg-purple-600 hover:bg-purple-700 rounded-lg text-white" title="Screen Effects"><i class="fa-solid fa-wand-magic-sparkles"></i></button>
                            <div id="effects-dropdown" class="dropdown-content flex flex-col items-start gap-1 p-2 rounded-md bg-gray-600 shadow-lg">
                                <button data-effect="random-flash" class="tool-btn p-2 w-full text-left">flashes screen in random colors</button>
                                <button data-effect="hearts" class="tool-btn p-2 w-full text-left">abundance of hearts</button>
                                <button data-effect="rain" class="tool-btn p-2 w-full text-left">wet for you</button>
                                <button data-effect="pickles" class="tool-btn p-2 w-full text-left">big pickles</button>
                            </div>
                        </div>
                        <button id="save-btn" class="p-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-white" title="Save as PNG"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg></button>
                        <button id="clear-canvas-btn" class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg font-semibold">Clear Canvas</button>
                    </div>
                </div>
                <!-- Main Content Area -->
                <main id="main-content" class="flex-grow w-full h-full min-h-0 relative">
                    <canvas id="whiteboard" class="shadow-inner rounded-lg"></canvas>
                    <canvas id="overlay-canvas" class="rounded-lg"></canvas>
                    <div id="event-capture-layer" class="rounded-lg"></div>
                    <div id="text-input-container"><input type="text" id="text-input" /></div>
                </main>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="help-modal-overlay" class="modal-overlay">
        <div id="help-modal" class="modal">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">Whiteboard Help</h2>
                <button id="close-help-btn" class="text-2xl">&times;</button>
            </div>
            <h3>Core Concepts</h3>
            <p>Welcome to a space of inspiration! The title and description of this board change daily to provide a new creative spark. Every user is assigned a unique, yogic-themed avatar.</p>
            <h4 class="font-bold mt-4 mb-2">Features</h4>
            <ul class="list-disc list-inside space-y-2">
                <li><b>Real-time Whiteboard:</b> Draw freely with various tools (pen, shapes, text), colors, and brush sizes. The pen tool uses smoothing for better results.</li>
                <li><b>Grid & Snapping:</b> Toggle a background grid and snap-to-grid for precise alignment of objects.</li>
                <li><b>Undo/Redo:</b> Easily undo and redo your actions on the canvas using the dedicated buttons.</li>
                <li><b>Live Chat:</b> Communicate with others on the board in real-time.</li>
                <li><b>AI Image Generation:</b> Click the "AI Image" button to create and share unique images from a text description. You can preview the image before sending or try again.</li>
                <li><b>Object Manipulation:</b> Select, move, resize, duplicate, delete, and bring objects to the front.</li>
                <li><b>Save & Export:</b> Save the whiteboard canvas as a PNG image and export the chat history as a text file.</li>
                <li><b>Fun Effects:</b> Add some visual flair with screen effects like "random flash", "abundance of hearts", "wet for you", and "big pickles".</li>
                <li><b>Daily Inspiration:</b> The board's title and description change daily to spark creativity.</li>
            </ul>
            <p class="mt-4 text-xs text-gray-400">Version: 1.25</p>
        </div>
    </div>
    <div id="ai-image-modal-overlay" class="modal-overlay">
        <div id="ai-image-modal" class="modal">
             <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">Generate AI Image</h2>
                <button id="close-ai-image-btn" class="text-2xl">&times;</button>
            </div>
            <p class="text-gray-400 mb-4">Describe the image you want to create. Be as descriptive as you like!</p>
            <div id="ai-image-prompt-area">
                <div class="flex gap-2">
                    <input type="text" id="ai-image-prompt-input" class="w-full bg-gray-700 p-2 rounded" placeholder="e.g., a happy cat wearing a party hat">
                    <button id="ai-image-generate-btn" class="chat-btn">Generate</button>
                </div>
            </div>
            <div id="ai-image-results" class="mt-4 text-center"></div>
        </div>
    </div>
     <div id="image-viewer-overlay" class="modal-overlay">
        <img id="image-viewer-content" src="" alt="Full size image" />
    </div>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, onSnapshot, collection, addDoc, doc, setDoc, getDoc, query, where, updateDoc, orderBy, serverTimestamp, writeBatch, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- App Configuration ---
        const firebaseConfig = { apiKey: "AIzaSyAGO0CRIL44bj9-y5k2ARi2qGqZaZ7vLPc", authDomain: "whiteboard-00.firebaseapp.com", projectId: "whiteboard-00", storageBucket: "whiteboard-00.appspot.com", messagingSenderId: "34696279859", appId: "1:34696279859:web:a01addc7e57a8d06947046" };
        const whiteboardId = "google-sites-whiteboard-advanced";
        const API_KEY = "AIzaSyAGO0CRIL44bj9-y5k2ARi2qGqZaZ7vLPc";

        // --- DOM Elements ---
        const whiteboardTitleEl = document.getElementById('whiteboard-title');
        const whiteboardDescriptionEl = document.getElementById('whiteboard-description');
        const eventCaptureLayer = document.getElementById('event-capture-layer');
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        const overlayCanvas = document.getElementById('overlay-canvas');
        const overlayCtx = overlayCanvas.getContext('2d');
        const textInputContainer = document.getElementById('text-input-container');
        const textInput = document.getElementById('text-input');
        const helpModalOverlay = document.getElementById('help-modal-overlay');
        const chatMessagesContainer = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');
        const deleteBtn = document.getElementById('delete-btn');
        const frontBtn = document.getElementById('front-btn');
        const duplicateBtn = document.getElementById('duplicate-btn');
        const clearCanvasBtn = document.getElementById('clear-canvas-btn');
        const clearChatBtn = document.getElementById('clear-chat-btn');
        const saveChatBtn = document.getElementById('save-chat-btn');
        const aiImageBtn = document.getElementById('ai-image-btn');
        const aiImageModalOverlay = document.getElementById('ai-image-modal-overlay');
        const imageViewerOverlay = document.getElementById('image-viewer-overlay');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const toggleGridBtn = document.getElementById('toggle-grid-btn');
        const toggleSnapBtn = document.getElementById('toggle-snap-btn');

        // --- Firebase & State Globals ---
        let db, userId, auth;
        let unsubscribeFromDrawings, unsubscribeFromState, unsubscribeFromEvents, unsubscribeFromChat;
        let localChatHistory = [];
        const userAvatars = new Map();
        const state = {
            action: 'none', startPos: null, currentTool: 'pen', currentColor: '#FFFFFF', currentBrushSize: 2, currentEpoch: 0,
            allDrawings: new Map(), sortedDrawings: [], selectedObjectId: null, dragOffset: { x: 0, y: 0 },
            tempDrawing: null, resizeHandle: null, isTexting: false, isShiftDown: false,
            undoStack: [], redoStack: [],
            isGridVisible: true, isSnapEnabled: true, gridSize: 20,
        };
        
        const dailyTitles = ["Flow", "Clarity", "Presence", "Intention", "Balance", "Growth", "Stillness", "Awareness", "Release", "Connect"];
        const dailyQuotes = [
            "The body benefits from movement, and the mind benefits from stillness.", "Yoga is the journey of the self, through the self, to the self.", "In the midst of movement and chaos, keep stillness inside of you.", "The longest journey of any person is the journey inward.", "Be where you are, not where you think you should be.", "The nature of yoga is to shine the light of awareness into the darkest corners of the body.", "We are not trying to escape our lives, but to return to them.", "Your task is not to seek for love, but merely to seek and find all the barriers within yourself that you have built against it.", "Let your practice be a celebration of life.", "The goal of yoga is not to be perfect, but to be whole."
        ];
        
        const userNicknames = {
            'lALY0TmTtaNdbtSjkt8o96NbS4z2': 'Sexy Honey Bee',
            '4Kgf667MeLODXTwhfBkhIWERQdG3': 'White Stallion'
        };

        // --- Avatar & Name Generation ---
        function getUserDisplayName(uid) { return userNicknames[uid] || uid; }

        async function getOrGenerateAvatar(uid) {
            if (userAvatars.has(uid) && userAvatars.get(uid).url) {
                return userAvatars.get(uid).url;
            }

            const avatarDocRef = doc(db, `whiteboards/${whiteboardId}/avatars`, uid);
            const avatarDoc = await getDoc(avatarDocRef);
            const oneDayAgo = Date.now() - 24 * 60 * 60 * 1000;

            if (avatarDoc.exists() && avatarDoc.data().generatedAt.toMillis() > oneDayAgo) {
                const url = avatarDoc.data().imageUrl;
                userAvatars.set(uid, { url });
                return url;
            }

            // Generate a new one
            const nickname = getUserDisplayName(uid);
            const prompt = `A cool and artistic avatar for a user named '${nickname}'. Vibrant colors, modern digital art, abstract.`;

            const payload = { instances: [{ prompt: prompt }], parameters: { "sampleCount": 1 } };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${API_KEY}`;

            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                 if (!response.ok) {
                    const errorBody = await response.text();
                    let errorDetails = errorBody;
                    try {
                        const errorJson = JSON.parse(errorBody);
                        errorDetails = errorJson.error?.message || errorBody;
                    } catch (e) { /* Not a JSON error */ }
                    throw new Error(`HTTP error! status: ${response.status}, details: ${errorDetails}`);
                }
                const result = await response.json();
                if (result.predictions && result.predictions[0].bytesBase64Encoded) {
                    const base64 = result.predictions[0].bytesBase64Encoded;
                    const img = new Image();
                    const promise = new Promise((resolve, reject) => {
                         img.onload = async () => {
                            const maxDimension = 128;
                            const scale = Math.min(maxDimension / img.width, maxDimension / img.height, 1);
                            const tempCanvas = document.createElement('canvas');
                            tempCanvas.width = img.width * scale;
                            tempCanvas.height = img.height * scale;
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
                            const compressedUrl = tempCanvas.toDataURL('image/jpeg', 0.8);
                            
                            await setDoc(avatarDocRef, { imageUrl: compressedUrl, generatedAt: serverTimestamp() });
                            userAvatars.set(uid, { url: compressedUrl });
                            resolve(compressedUrl);
                         };
                         img.onerror = reject;
                    });
                    img.src = `data:image/png;base64,${base64}`;
                    return promise;
                }
            } catch (error) {
                console.error("Failed to generate avatar for", uid, error);
            }
            return ''; // Fallback
        }


        // --- Firebase Listeners ---
        function setupStateListener() { 
            const stateDocPath = `whiteboards/${whiteboardId}/state/main`; 
            if(unsubscribeFromState) unsubscribeFromState(); 
            unsubscribeFromState = onSnapshot(doc(db, stateDocPath), (docSnapshot) => { 
                const boardState = docSnapshot.data() || {};
                const newEpoch = boardState.epoch || Date.now();
                if (newEpoch !== state.currentEpoch) { 
                    state.currentEpoch = newEpoch; 
                    setupDrawingsListener(); 
                } 
            }); 
        }
        function setupDrawingsListener() { if (state.currentEpoch === 0) return; if (unsubscribeFromDrawings) unsubscribeFromDrawings(); state.allDrawings.clear(); state.selectedObjectId = null; redrawCanvas(); const drawingsCollectionPath = `whiteboards/${whiteboardId}/drawings`; const q = query(collection(db, drawingsCollectionPath), where("epoch", "==", state.currentEpoch)); unsubscribeFromDrawings = onSnapshot(q, (snapshot) => { snapshot.docChanges().forEach((change) => { const docData = change.doc.data(); if (change.type === 'removed' || docData.isDeleted) { state.allDrawings.delete(change.doc.id); } else { state.allDrawings.set(change.doc.id, { id: change.doc.id, ...docData }); } }); state.sortedDrawings = Array.from(state.allDrawings.values()).sort((a, b) => (a.timestamp?.seconds || 0) - (b.timestamp?.seconds || 0)); redrawCanvas(); }); }
        function setupEventsListener() { const eventsCollectionPath = `whiteboards/${whiteboardId}/events`; const q = query(collection(db, eventsCollectionPath), where("timestamp", ">", new Date(Date.now() - 10000))); if(unsubscribeFromEvents) unsubscribeFromEvents(); unsubscribeFromEvents = onSnapshot(q, (snapshot) => { snapshot.docChanges().forEach((change) => { if (change.type === "added") { const eventData = change.doc.data(); if (eventData.author !== userId) { triggerEffect(eventData.type); } } }); }); }
        
        async function setupChatListener() {
            const chatCollectionPath = `whiteboards/${whiteboardId}/chat`;
            const q = query(collection(db, chatCollectionPath), orderBy("timestamp", "asc"));
            if (unsubscribeFromChat) unsubscribeFromChat();
            unsubscribeFromChat = onSnapshot(q, async (snapshot) => {
                localChatHistory = [];
                 let messagesHtml = '';
                for(const doc of snapshot.docs) {
                    const msg = {id: doc.id, ...doc.data()};
                    localChatHistory.push(msg);
                    const avatarUrl = await getOrGenerateAvatar(msg.author);
                    const displayName = getUserDisplayName(msg.author);
                    let textHtml = '';
                    let imageHtml = '';

                    if (msg.text) {
                        const sanitizedText = msg.text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        textHtml = `<div class="chat-text">${sanitizedText}</div>`;
                    }

                    if (msg.url && msg.type === 'image') {
                        const imageMargin = msg.text ? 'mt-2' : '';
                        imageHtml = `<img src="${msg.url}" class="chat-image ${imageMargin}" data-full-src="${msg.url}" alt="AI generated image">`;
                    }
                    
                    const contentHtml = textHtml + imageHtml;
                    const finalAvatarUrl = avatarUrl || 'https://placehold.co/40x40/4b5563/FFFFFF?text=?';

                    messagesHtml += `
                        <div class="chat-message" data-message-id="${msg.id}">
                            <img src="${finalAvatarUrl}" class="chat-avatar">
                            <div class="chat-content">
                                <div class="chat-author">${displayName}</div>
                                ${contentHtml}
                            </div>
                        </div>
                    `;
                };
                chatMessagesContainer.innerHTML = messagesHtml;
                chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
            });
        }
        
        // --- Drawing & Core Logic ---
        function drawGrid() { if (!state.isGridVisible) return; ctx.save(); ctx.strokeStyle = '#374151'; /* gray-700 */ ctx.lineWidth = 0.5; for (let x = 0; x < canvas.width; x += state.gridSize) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); } for (let y = 0; y < canvas.height; y += state.gridSize) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); } ctx.restore(); }
        function redrawCanvas() { const dpr = window.devicePixelRatio || 1; const rect = document.getElementById('main-content').getBoundingClientRect(); [canvas, overlayCanvas].forEach(c => { if (c.width !== rect.width * dpr || c.height !== rect.height * dpr) { c.width = rect.width * dpr; c.height = rect.height * dpr; if (c.style) { c.style.width = `${rect.width}px`; c.style.height = `${rect.height}px`; } c.getContext('2d').scale(dpr, dpr); } }); ctx.clearRect(0, 0, canvas.width, canvas.height); drawGrid(); state.sortedDrawings.forEach(data => drawObject(ctx, data)); drawOverlay(); }
        function drawOverlay() { overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height); if (state.tempDrawing) { drawObject(overlayCtx, state.tempDrawing); } const selectedObject = state.allDrawings.get(state.selectedObjectId); if (selectedObject) { drawSelectionBox(selectedObject); deleteBtn.disabled = false; frontBtn.disabled = false; duplicateBtn.disabled = false; } else { deleteBtn.disabled = true; frontBtn.disabled = true; duplicateBtn.disabled = true; } }
        function drawObject(context, data) { if (!data) return; context.save(); const bounds = getObjectBounds(data); if(!bounds) { context.restore(); return; } context.strokeStyle = data.color; context.fillStyle = data.color; context.lineWidth = data.lineWidth || 2; context.lineCap = 'round'; context.lineJoin = 'round'; switch(data.type) { case 'path': if (!data.points || data.points.length < 1) break; context.beginPath(); if (data.points.length < 3) { context.moveTo(data.points[0].x, data.points[0].y); for (let i = 1; i < data.points.length; i++) { context.lineTo(data.points[i].x, data.points[i].y); } } else { context.moveTo(data.points[0].x, data.points[0].y); for (var i = 1; i < data.points.length - 2; i++) { var c = (data.points[i].x + data.points[i + 1].x) / 2; var d = (data.points[i].y + data.points[i + 1].y) / 2; context.quadraticCurveTo(data.points[i].x, data.points[i].y, c, d); } context.quadraticCurveTo(data.points[i].x, data.points[i].y, data.points[i + 1].x, data.points[i + 1].y); } context.stroke(); break; case 'line': if (!data.points || data.points.length < 2) break; context.beginPath(); context.moveTo(data.points[0].x, data.points[0].y); context.lineTo(data.points[1].x, data.points[1].y); context.stroke(); break; case 'rectangle': context.strokeRect(data.x, data.y, data.width, data.height); break; case 'circle': context.beginPath(); context.arc(data.cx, data.cy, data.radius, 0, 2 * Math.PI); context.stroke(); break; case 'triangle': if (!data.points || data.points.length < 3) break; context.beginPath(); context.moveTo(data.points[0].x, data.points[0].y); context.lineTo(data.points[1].x, data.points[1].y); context.lineTo(data.points[2].x, data.points[2].y); context.closePath(); context.stroke(); break; case 'text': context.font = `${data.fontSize}px Inter`; context.textBaseline = 'top'; context.fillText(data.text, data.x, data.y); break; } context.restore(); }
        function drawSelectionBox(obj) { const bounds = getObjectBounds(obj); if (!bounds) return; overlayCtx.save(); overlayCtx.strokeStyle = '#4f46e5'; overlayCtx.lineWidth = 1; overlayCtx.setLineDash([4, 4]); overlayCtx.strokeRect(bounds.x - 5, bounds.y - 5, bounds.width + 10, bounds.height + 10); overlayCtx.setLineDash([]); const handles = getResizeHandles(bounds); overlayCtx.fillStyle = '#4f46e5'; for (const key in handles) { const handle = handles[key]; overlayCtx.fillRect(handle.x - 4, handle.y - 4, 8, 8); } overlayCtx.restore(); }
        function getResizeHandles(bounds) { return { tl: { x: bounds.x - 5, y: bounds.y - 5, cursor: 'nwse-resize' }, tr: { x: bounds.x + bounds.width + 5, y: bounds.y - 5, cursor: 'nesw-resize' }, bl: { x: bounds.x - 5, y: bounds.y + bounds.height + 5, cursor: 'nesw-resize' }, br: { x: bounds.x + bounds.width + 5, y: bounds.y + bounds.height + 5, cursor: 'nwse-resize' } }; }
        function getObjectBounds(obj) { let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; if(!obj) return null; switch (obj.type) { case 'rectangle': return { x: obj.x, y: obj.y, width: obj.width, height: obj.height }; case 'circle': return { x: obj.cx - obj.radius, y: obj.cy - obj.radius, width: obj.radius * 2, height: obj.radius * 2 }; case 'text': ctx.font = `${obj.fontSize}px Inter`; const metrics = ctx.measureText(obj.text); const height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent; return { x: obj.x, y: obj.y, width: metrics.width, height: height || obj.fontSize }; case 'path': case 'line': case 'triangle': if (!obj.points || obj.points.length === 0) return {x:0,y:0,width:0,height:0}; obj.points.forEach(p => { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); }); return { x: minX, y: minY, width: maxX - minX, height: maxY - minY }; default: return null; } }
        
        // --- UI & Event Functions ---
        async function sendChatMessage(text, type = 'text', url = null) {
            const content = text.trim();
            if ((content || url) && userId) {
                try {
                    const messageData = {
                        author: userId,
                        timestamp: serverTimestamp(),
                        type: type,
                    };
                    if (content) messageData.text = content;
                    if (url) messageData.url = url;

                    await addDoc(collection(db, `whiteboards/${whiteboardId}/chat`), messageData);
                    chatInput.value = '';
                } catch (error) {
                    console.error("Error sending chat message:", error);
                }
            }
        }
        async function sendEffectToFirestore(effectType) { if(!userId) return; await addDoc(collection(db, `whiteboards/${whiteboardId}/events`), { type: effectType, author: userId, timestamp: new Date() }); triggerEffect(effectType); }
        function triggerEffect(type) { const container = document.getElementById('whiteboard-wrapper'); if (type === 'random-flash') { const flash = document.createElement('div'); flash.id = 'flash-overlay'; const randomColor = `rgba(${Math.floor(Math.random() * 156) + 100}, ${Math.floor(Math.random() * 156) + 100}, ${Math.floor(Math.random() * 156) + 100}, 0.7)`; flash.style.backgroundColor = randomColor; document.body.appendChild(flash); setTimeout(() => flash.remove(), 800); } else if (['hearts', 'rain', 'pickles'].includes(type)) { let emoji = '‚ù§Ô∏è'; if (type === 'rain') emoji = 'üíß'; if (type === 'pickles') emoji = 'ü•í'; for (let i = 0; i < 25; i++) { const particle = document.createElement('div'); particle.className = 'effect-particle'; particle.textContent = emoji; particle.style.left = `${Math.random() * 100}%`; particle.style.animationDelay = `${Math.random() * 2}s`; container.appendChild(particle); setTimeout(() => particle.remove(), 5000); } } }
        async function clearAllDrawings() { await setDoc(doc(db, `whiteboards/${whiteboardId}/state/main`), { epoch: Date.now() }, {merge: true}); }
        async function clearAllChat() { const batch = writeBatch(db); localChatHistory.forEach(msg => { const docRef = doc(db, `whiteboards/${whiteboardId}/chat`, msg.id); batch.delete(docRef); }); await batch.commit(); }
        function saveChatHistory() { let chatText = `Chat History for Whiteboard: ${whiteboardTitleEl.textContent}\nSaved on: ${new Date().toLocaleString()}\n\n`; localChatHistory.forEach(msg => { const time = msg.timestamp ? new Date(msg.timestamp.seconds * 1000).toLocaleTimeString() : '...'; const author = msg.author.substring(0,8); let content = msg.type === 'image' ? `[Image: ${msg.url}]` : msg.text; chatText += `[${time}] ${author}: ${content}\n`; }); const blob = new Blob([chatText], { type: 'text/plain' }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = 'chat-history.txt'; link.click(); }
        function setDailyContent() { const today = new Date(); const dayOfYear = Math.floor((today - new Date(today.getFullYear(), 0, 0)) / (1000 * 60 * 60 * 24)); const titleIndex = dayOfYear % dailyTitles.length; const quoteIndex = dayOfYear % dailyQuotes.length; whiteboardTitleEl.textContent = dailyTitles[titleIndex]; whiteboardDescriptionEl.textContent = dailyQuotes[quoteIndex]; }
        
        // --- Mouse and Event Handlers ---
        function snapToGrid(pos) { if (!state.isSnapEnabled) return pos; return { x: Math.round(pos.x / state.gridSize) * state.gridSize, y: Math.round(pos.y / state.gridSize) * state.gridSize, }; }
        function getMousePos(evt) { const rect = eventCaptureLayer.getBoundingClientRect(); return { x: evt.clientX - rect.left, y: evt.clientY - rect.top }; }
        function handleMouseDown(e) { if (state.isTexting) return; const pos = getMousePos(e); state.startPos = snapToGrid(pos); state.action = 'none'; if (state.currentTool === 'select') { const selectedObject = state.allDrawings.get(state.selectedObjectId); if (selectedObject) { const bounds = getObjectBounds(selectedObject); const handles = getResizeHandles(bounds); for (const key in handles) { const handle = handles[key]; if (Math.abs(pos.x - handle.x) < 5 && Math.abs(pos.y - handle.y) < 5) { state.action = 'resizing'; state.resizeHandle = key; return; } } } const clickedObjectId = findClickedObject(pos.x, pos.y); if (clickedObjectId) { state.selectedObjectId = clickedObjectId; state.action = 'moving'; const obj = state.allDrawings.get(clickedObjectId); const bounds = getObjectBounds(obj); state.dragOffset = { x: pos.x - bounds.x, y: pos.y - bounds.y }; } else { state.selectedObjectId = null; } drawOverlay(); } else if (state.currentTool === 'text') { startTextEntry(state.startPos); } else { state.action = 'drawing'; state.tempDrawing = createPreviewObject(state.startPos, state.startPos); } }
        function handleMouseMove(e) { if (!state.startPos) return; let pos = getMousePos(e); if (state.isSnapEnabled) { pos = snapToGrid(pos); } if (state.action === 'drawing') { if (state.currentTool === 'pen') { state.tempDrawing.points.push(pos); } else { state.tempDrawing = createPreviewObject(state.startPos, pos); } drawOverlay(); } else if (state.action === 'moving' && state.selectedObjectId) { const snappedPos = state.isSnapEnabled ? snapToGrid({ x: pos.x - state.dragOffset.x, y: pos.y - state.dragOffset.y }) : { x: pos.x - state.dragOffset.x, y: pos.y - state.dragOffset.y }; const obj = state.allDrawings.get(state.selectedObjectId); moveObject(obj, snappedPos.x, snappedPos.y); drawOverlay(); } else if (state.action === 'resizing' && state.selectedObjectId) { const obj = state.allDrawings.get(state.selectedObjectId); const bounds = getObjectBounds(obj); let {x, y, width, height} = bounds; switch(state.resizeHandle) { case 'br': width = pos.x - x; height = pos.y - y; break; case 'bl': width = (x + width) - pos.x; x = pos.x; height = pos.y - y; break; case 'tr': width = pos.x - x; height = (y + height) - pos.y; y = pos.y; break; case 'tl': width = (x + width) - pos.x; height = (y + height) - pos.y; x = pos.x; y = pos.y; break; } const updatedData = { ...obj, x, y, width: Math.max(1, width), height: Math.max(1, height) }; state.tempDrawing = updatedData; drawOverlay(); } else if (state.currentTool === 'select') { const selectedObject = state.allDrawings.get(state.selectedObjectId); if (selectedObject) { const bounds = getObjectBounds(selectedObject); const handles = getResizeHandles(bounds); let cursor = 'move'; for (const key in handles) { const handle = handles[key]; if (Math.abs(pos.x - handle.x) < 5 && Math.abs(pos.y - handle.y) < 5) { cursor = handle.cursor; break; } } eventCaptureLayer.style.cursor = cursor; } else { eventCaptureLayer.style.cursor = 'default'; } } }
        async function handleMouseUp(e) { if (!state.startPos) return; if (state.action === 'drawing' && state.tempDrawing) { if (state.currentTool !== 'pen' || state.tempDrawing.points.length >= 2) { const newDocRef = await addObjectToFirestore(state.tempDrawing); if (newDocRef) { pushToUndoStack({type: 'add', payload: { id: newDocRef.id, data: state.tempDrawing }}); } } } else if (state.action === 'moving' && state.selectedObjectId) { const obj = state.allDrawings.get(state.selectedObjectId); updateObjectInFirestore(state.selectedObjectId, obj); } else if (state.action === 'resizing' && state.selectedObjectId && state.tempDrawing) { const { id, ...dataToUpdate } = state.tempDrawing; updateObjectInFirestore(id, dataToUpdate); } state.action = 'none'; state.startPos = null; state.tempDrawing = null; state.resizeHandle = null; redrawCanvas(); }
        function createPreviewObject(start, end) { const common = { color: state.currentColor, lineWidth: state.currentBrushSize, author: userId, epoch: state.currentEpoch }; const x1 = start.x, y1 = start.y, x2 = end.x, y2 = end.y; const width = Math.abs(x1 - x2); const height = Math.abs(y1 - y2); switch (state.currentTool) { case 'pen': return { ...common, type: 'path', points: [start] }; case 'line': return { ...common, type: 'line', points: [start, end] }; case 'rectangle': return { ...common, type: 'rectangle', x: Math.min(x1, x2), y: Math.min(y1, y2), width, height }; case 'circle': return { ...common, type: 'circle', cx: x1, cy: y1, radius: Math.sqrt(width*width + height*height) }; case 'triangle': return { ...common, type: 'triangle', points: [ {x: x1, y: y2}, {x: (x1+x2)/2, y: y1}, {x: x2, y: y2} ] }; default: return null; } }
        function findClickedObject(x, y) { for (let i = state.sortedDrawings.length - 1; i >= 0; i--) { const obj = state.sortedDrawings[i]; const bounds = getObjectBounds(obj); if (bounds && x >= bounds.x && x <= bounds.x + bounds.width && y >= bounds.y && y <= bounds.y + bounds.height) { return obj.id; } } return null; }
        function moveObject(obj, newX, newY) { const bounds = getObjectBounds(obj); const dx = newX - bounds.x; const dy = newY - bounds.y; if (obj.points) { obj.points = obj.points.map(p => ({ x: p.x + dx, y: p.y + dy })); } else if (obj.type === 'circle') { obj.cx += dx; obj.cy += dy; } else { obj.x = newX; obj.y = newY; } }
        
        function startTextEntry(pos) {
            state.isTexting = true;
            textInputContainer.style.left = `${pos.x}px`;
            textInputContainer.style.top = `${pos.y}px`;
            textInputContainer.style.display = 'block';
            textInput.style.color = state.currentColor;
            textInput.style.fontSize = `${state.currentBrushSize * 5 + 12}px`;
            textInput.value = '';
            textInput.focus();

            const finish = async (shouldAddText) => {
                if (!state.isTexting) return;
                state.isTexting = false;
                
                textInput.onblur = null;
                document.removeEventListener('mousedown', handleClickOutside, true);

                if (shouldAddText) {
                    const text = textInput.value.trim();
                    if (text) {
                        const textData = { type: 'text', text, x: pos.x, y: pos.y, color: state.currentColor, fontSize: state.currentBrushSize * 5 + 12, author: userId, epoch: state.currentEpoch };
                        const newDocRef = await addObjectToFirestore(textData);
                        if (newDocRef) {
                            pushToUndoStack({type: 'add', payload: { id: newDocRef.id, data: textData }});
                        }
                    }
                }
                textInput.value = '';
                textInputContainer.style.display = 'none';
            }
            
            const handleClickOutside = (event) => {
                if (!textInputContainer.contains(event.target)) {
                    finish(true);
                }
            };

            textInput.onkeydown = (e) => {
                if (e.key === 'Enter') { e.preventDefault(); finish(true); }
                else if (e.key === 'Escape') { finish(false); }
            };

            setTimeout(() => {
                 document.addEventListener('mousedown', handleClickOutside, true);
            }, 0);
        }

        // --- Firestore Actions ---
        async function addObjectToFirestore(objData) { try { const docRef = await addDoc(collection(db, `whiteboards/${whiteboardId}/drawings`), { ...objData, timestamp: serverTimestamp() }); return docRef; } catch (error) { console.error("Error adding document: ", error); return null;} }
        async function updateObjectInFirestore(docId, updatedData) { const originalObject = state.allDrawings.get(docId); if(originalObject) { pushToUndoStack({ type: 'update', payload: { id: docId, before: originalObject, after: {...originalObject, ...updatedData} }}); } try { await updateDoc(doc(db, `whiteboards/${whiteboardId}/drawings`, docId), { ...updatedData, timestamp: serverTimestamp() }); } catch (error) { console.error("Error updating document: ", error); } }
        async function deleteSelectedObject() { if (!state.selectedObjectId) return; const objectToDelete = state.allDrawings.get(state.selectedObjectId); if(objectToDelete) { pushToUndoStack({ type: 'delete', payload: objectToDelete }); } try { await deleteDoc(doc(db, `whiteboards/${whiteboardId}/drawings`, state.selectedObjectId)); state.selectedObjectId = null; redrawCanvas(); } catch (error) { console.error("Error deleting document: ", error); } }
        async function bringToFront() { if (!state.selectedObjectId) return; await updateObjectInFirestore(state.selectedObjectId, {}); }
        async function duplicateSelectedObject() { if (!state.selectedObjectId) return; const original = state.allDrawings.get(state.selectedObjectId); const { id, timestamp, ...cloneData } = original; if (cloneData.points) { cloneData.points = cloneData.points.map(p => ({ x: p.x + 10, y: p.y + 10 })); } else if (cloneData.type === 'circle') { cloneData.cx += 10; cloneData.cy += 10; } else { cloneData.x += 10; cloneData.y += 10; } const newDocRef = await addObjectToFirestore(cloneData); if (newDocRef) { pushToUndoStack({type: 'add', payload: { id: newDocRef.id, data: cloneData }}); state.selectedObjectId = newDocRef.id; drawOverlay(); } }
        
        // --- Undo/Redo Logic ---
        function updateUndoRedoButtons() { undoBtn.disabled = state.undoStack.length === 0; redoBtn.disabled = state.redoStack.length === 0; }
        function pushToUndoStack(action) { state.undoStack.push(action); state.redoStack = []; updateUndoRedoButtons(); }
        async function handleUndo() { if (state.undoStack.length === 0) return; const action = state.undoStack.pop(); state.redoStack.push(action); state.selectedObjectId = null; switch (action.type) { case 'add': await deleteDoc(doc(db, `whiteboards/${whiteboardId}/drawings`, action.payload.id)); break; case 'delete': const { id: delId, ...delData } = action.payload; await setDoc(doc(db, `whiteboards/${whiteboardId}/drawings`, delId), delData); break; case 'update': const { id: updId, before: beforeData } = action.payload; const { id: ignoredId, ...updData } = beforeData; await updateDoc(doc(db, `whiteboards/${whiteboardId}/drawings`, updId), updData); break; } updateUndoRedoButtons(); }
        async function handleRedo() { if (state.redoStack.length === 0) return; const action = state.redoStack.pop(); state.undoStack.push(action); state.selectedObjectId = null; switch (action.type) { case 'add': const { id: addId, data: addData } = action.payload; await setDoc(doc(db, `whiteboards/${whiteboardId}/drawings`, addId), addData); break; case 'delete': await deleteDoc(doc(db, `whiteboards/${whiteboardId}/drawings`, action.payload.id)); break; case 'update': const { id: updId, after: afterData } = action.payload; const { id: ignoredId, ...updData } = afterData; await updateDoc(doc(db, `whiteboards/${whiteboardId}/drawings`, updId), updData); break; } updateUndoRedoButtons(); }

        // --- AI Image Modal Functions ---
        function showModal(modal) { modal.classList.add('visible'); }
        function hideModal(modal) { modal.classList.remove('visible'); }
        
        function resetAiModal() {
            const resultsContainer = document.getElementById('ai-image-results');
            const promptArea = document.getElementById('ai-image-prompt-area');
            const promptInput = document.getElementById('ai-image-prompt-input');
            resultsContainer.innerHTML = '';
            promptInput.value = '';
            promptArea.style.display = 'block';
        }

        async function generateAiImage() {
            const promptInput = document.getElementById('ai-image-prompt-input');
            const prompt = promptInput.value;
            if(!prompt) return;

            const resultsContainer = document.getElementById('ai-image-results');
            const promptArea = document.getElementById('ai-image-prompt-area');
            const generateBtn = document.getElementById('ai-image-generate-btn');
            
            promptArea.style.display = 'none';
            resultsContainer.innerHTML = `<div class="flex justify-center items-center gap-2"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div><span>Generating...</span></div>`;
            generateBtn.disabled = true;

            const payload = { instances: [{ prompt: prompt }], parameters: { "sampleCount": 1} };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${API_KEY}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();

                if (!response.ok) {
                    const errorDetails = result.error?.message || response.statusText;
                    throw new Error(`HTTP error! status: ${response.status}, details: ${errorDetails}`);
                }
                
                if (result.error) {
                    throw new Error(`AI Service Error: ${result.error.message}`);
                }

                if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                    const originalBase64 = result.predictions[0].bytesBase64Encoded;
                    
                    const img = new Image();
                    img.onload = async () => {
                        const maxDimension = 512;
                        const scale = Math.min(maxDimension / img.width, maxDimension / img.height, 1);
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = img.width * scale;
                        tempCanvas.height = img.height * scale;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
                        const compressedImageUrl = tempCanvas.toDataURL('image/jpeg', 0.7);
                        
                        // Display preview and action buttons
                        resultsContainer.innerHTML = `
                            <img src="${compressedImageUrl}" class="max-w-full rounded-lg mx-auto" alt="AI generated preview">
                            <div class="flex justify-center gap-4 mt-4">
                                <button id="send-ai-image-btn" class="chat-btn bg-green-600 hover:bg-green-700">Send to Chat</button>
                                <button id="try-again-ai-image-btn" class="chat-btn bg-gray-500 hover:bg-gray-600">Try Again</button>
                            </div>
                        `;
                        
                        document.getElementById('send-ai-image-btn').addEventListener('click', async () => {
                            await sendChatMessage(`"${prompt}"`, 'image', compressedImageUrl);
                            hideModal(aiImageModalOverlay);
                            resetAiModal();
                        });

                        document.getElementById('try-again-ai-image-btn').addEventListener('click', resetAiModal);
                    };
                    img.onerror = (err) => {
                         console.error("Failed to load generated image for compression.", err);
                         resultsContainer.innerHTML = '<span class="text-red-500">Error processing generated image.</span>';
                         promptArea.style.display = 'block'; // Show prompt again on error
                    };
                    img.src = `data:image/png;base64,${originalBase64}`;
                } else {
                    console.error("Invalid response structure from AI image API:", result);
                    throw new Error('Invalid response structure from AI image API.');
                }
            } catch (error) {
                console.error("AI Image Generation Error:", error);
                resultsContainer.innerHTML = `<span class="text-red-500">${error.message}</span>`;
                promptArea.style.display = 'block'; // Show prompt again on error
            } finally {
                 generateBtn.disabled = false;
            }
        }


        // --- App Initialization ---
        window.addEventListener('load', () => {
            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            setDailyContent();
            onAuthStateChanged(auth, async (user) => { 
                if (user) { 
                    userId = user.uid; 
                    document.getElementById('userId').textContent = getUserDisplayName(userId); 
                    await getOrGenerateAvatar(userId);
                    setupStateListener(); 
                    setupEventsListener(); 
                    setupChatListener(); 
                } else { 
                    try { 
                        await signInAnonymously(auth); 
                    } catch (error) { 
                        console.error("Sign-in error", error); 
                    } 
                } 
            });
            
            // --- Event Listeners Setup ---
            const allToolButtons = document.querySelectorAll('#tool-selector .tool-btn, #tool-selector .dropdown-content .tool-btn');
            allToolButtons.forEach(button => { button.addEventListener('click', (e) => { const clickedButton = e.currentTarget; const tool = clickedButton.dataset.tool; if (!tool) return; state.currentTool = tool; eventCaptureLayer.style.cursor = tool === 'select' ? 'default' : (tool === 'text' ? 'text' : 'crosshair'); document.querySelectorAll('#tool-selector .tool-btn').forEach(b => b.classList.remove('selected')); const parentDropdownBtn = clickedButton.closest('.dropdown')?.querySelector('.tool-btn'); if (parentDropdownBtn) { parentDropdownBtn.classList.add('selected'); } else { clickedButton.classList.add('selected'); } state.selectedObjectId = null; drawOverlay(); }); });
            document.querySelectorAll('#brush-size-selector .size-btn').forEach(btn => { btn.addEventListener('click', (e) => { document.querySelectorAll('#brush-size-selector .size-btn').forEach(b => b.classList.remove('selected')); const clickedBtn = e.currentTarget; clickedBtn.classList.add('selected'); state.currentBrushSize = parseInt(clickedBtn.dataset.size, 10); }); });
            const colors = ['#FFFFFF', '#EF4444', '#F97316', '#EAB308', '#22C55E', '#3B82F6', '#8B5CF6', '#EC4899'];
            const colorPalette = document.getElementById('color-palette');
            colors.forEach((color, index) => { const swatch = document.createElement('button'); swatch.className = 'color-swatch w-8 h-8 rounded-full border-2 border-gray-500 hover:scale-110'; swatch.style.backgroundColor = color; if(index === 0) swatch.classList.add('parent-selected'); swatch.addEventListener('click', () => { state.currentColor = color; document.querySelectorAll('#color-palette .color-swatch').forEach(s => s.classList.remove('parent-selected')); swatch.classList.add('parent-selected'); }); colorPalette.appendChild(swatch); });
            
            chatSendBtn.addEventListener('click', () => sendChatMessage(chatInput.value));
            chatInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendChatMessage(chatInput.value); }});
            
            clearCanvasBtn.addEventListener('click', () => { clearAllDrawings(); });
            clearChatBtn.addEventListener('click', () => { if(confirm("Are you sure you want to delete the entire chat history for everyone? This cannot be undone.")) { clearAllChat(); } });
            saveChatBtn.addEventListener('click', saveChatHistory);
            
            helpModalOverlay.addEventListener('click', (e) => { if(e.target === helpModalOverlay) hideModal(helpModalOverlay); });
            document.getElementById('close-help-btn').addEventListener('click', () => hideModal(helpModalOverlay));
            document.getElementById('help-btn').addEventListener('click', () => showModal(helpModalOverlay));

            aiImageBtn.addEventListener('click', () => {
                resetAiModal();
                showModal(aiImageModalOverlay);
            });
            document.getElementById('close-ai-image-btn').addEventListener('click', () => hideModal(aiImageModalOverlay));
            aiImageModalOverlay.addEventListener('click', (e) => { if(e.target === aiImageModalOverlay) hideModal(aiImageModalOverlay); });
            document.getElementById('ai-image-generate-btn').addEventListener('click', generateAiImage);
            document.getElementById('ai-image-prompt-input').addEventListener('keydown', (e) => {if(e.key === 'Enter') generateAiImage()});

            imageViewerOverlay.addEventListener('click', () => hideModal(imageViewerOverlay));
            chatMessagesContainer.addEventListener('click', (e) => {
                if(e.target.classList.contains('chat-image')) {
                    document.getElementById('image-viewer-content').src = e.target.dataset.fullSrc;
                    showModal(imageViewerOverlay);
                }
            });

            deleteBtn.addEventListener('click', deleteSelectedObject); frontBtn.addEventListener('click', bringToFront); duplicateBtn.addEventListener('click', duplicateSelectedObject);
            undoBtn.addEventListener('click', handleUndo);
            redoBtn.addEventListener('click', handleRedo);
            toggleGridBtn.addEventListener('click', () => { state.isGridVisible = !state.isGridVisible; toggleGridBtn.classList.toggle('selected', state.isGridVisible); redrawCanvas(); });
            toggleSnapBtn.addEventListener('click', () => { state.isSnapEnabled = !state.isSnapEnabled; toggleSnapBtn.classList.toggle('selected', state.isSnapEnabled); });
            document.querySelectorAll('#effects-dropdown .tool-btn').forEach(btn => { btn.addEventListener('click', (e) => { sendEffectToFirestore(e.currentTarget.dataset.effect); }); });
            document.getElementById('save-btn').addEventListener('click', () => { const link = document.createElement('a'); link.download = `${whiteboardTitleEl.textContent.trim()}-whiteboard.png`; link.href = canvas.toDataURL("image/png").replace("image/png", "image/octet-stream"); link.click(); });
            eventCaptureLayer.addEventListener('mousedown', handleMouseDown); eventCaptureLayer.addEventListener('mousemove', handleMouseMove); eventCaptureLayer.addEventListener('mouseup', handleMouseUp); eventCaptureLayer.addEventListener('mouseleave', handleMouseUp);
            window.addEventListener('resize', redrawCanvas, { passive: true }); window.addEventListener('keydown', (e) => { if(e.key === 'Shift') state.isShiftDown = true; }); window.addEventListener('keyup', (e) => { if(e.key === 'Shift') state.isShiftDown = false; });
            redrawCanvas();
        });
    </script>
</body>
</html>
