<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Whiteboard 3.0 (AI Image Gen)</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŽ¨</text></svg>">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- iro.js Color Picker -->
    <script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5"></script>
    <!-- Google Fonts & Font Awesome -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* --- Base & Layout Styles --- */
        :root {
            --bg-color: #111827;
            --surface-color: rgba(31, 41, 55, 0.7);
            --border-color: rgba(55, 65, 81, 0.8);
            --accent-color: #4f46e5;
            --text-color: #ffffff;
            --text-muted-color: #9ca3af;
        }
        body { 
            font-family: 'Inter', sans-serif;
            background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
        }
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }

        #main-layout { display: flex; height: 100vh; width: 100vw; }
        #whiteboard-wrapper { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; position: relative; }
        #app-container { width: 100%; height: 100%; display: flex; flex-direction: column; padding: 1rem; }
        #main-content { position: relative; flex-grow: 1; background-color: transparent; border-radius: 0.75rem; }

        /* --- Glassmorphism & Enhanced UI --- */
        .glass-ui {
            background: var(--surface-color);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            transition: all 0.3s ease;
        }

        /* --- Chat Column --- */
        #chat-container { 
            width: 350px; flex-shrink: 0; display: flex; flex-direction: column; 
            padding: 1rem; position: relative; transition: all 0.3s ease; z-index: 50;
        }
        #chat-container.hidden { width: 0; padding: 0; transform: translateX(-100%); overflow: hidden; }
        #chat-content-wrapper { width: 100%; height: 100%; display: flex; flex-direction: column; }
        #toggle-chat-btn {
            position: absolute; top: 50%; right: -14px; transform: translateY(-50%); z-index: 55;
            background-color: #374151; color: white; border: 1px solid #4b5563; border-left: none;
            width: 28px; height: 60px; border-radius: 0 1rem 1rem 0; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }
        #show-chat-btn {
            position: absolute; top: 50%; left: 0; transform: translateY(-50%); z-index: 55;
            background-color: #374151; color: white; border: 1px solid #4b5563; border-left: none;
            width: 28px; height: 60px; border-radius: 0 1rem 1rem 0; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }
        #chat-header { font-size: 1.5rem; font-weight: bold; color: white; margin-bottom: 1rem; text-align: center; border-bottom: 1px solid #4b5563; padding-bottom: 0.5rem;}
        #chat-messages { flex-grow: 1; overflow-y: auto; color: white; scrollbar-width: thin; scrollbar-color: var(--accent-color) transparent; padding: 0 0.5rem;}
        .chat-message { margin-bottom: 1rem; display: flex; align-items: flex-start; }
        .chat-avatar { width: 40px; height: 40px; border-radius: 50%; margin-right: 10px; background-color: #4b5563; object-fit: cover;}
        .chat-content { display: flex; flex-direction: column; max-width: calc(100% - 50px); }
        .chat-author { font-weight: bold; color: #a5b4fc; font-size: 0.8rem; margin-bottom: 2px;  word-break: break-all; }
        .chat-text { word-wrap: break-word; white-space: pre-wrap; }
        .chat-image { max-width: 100%; border-radius: 0.5rem; cursor: pointer; margin-top: 0.5rem; }
        #chat-input { background: #374151; border: 1px solid #4b5563; color: white; padding: 0.5rem; border-radius: 0.5rem; outline: none; resize: none; height: 6rem; width: 100%; margin-bottom: 0.5rem; }
        .chat-btn { background: var(--accent-color); color: white; padding: 0 1rem; border-radius: 0.5rem; border: none; cursor: pointer; height: 2.5rem; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s, transform 0.1s; }
        .chat-btn:hover { background: #4338ca; transform: translateY(-2px); }
        .chat-btn:disabled { background: #374151; opacity: 0.5; cursor: not-allowed; transform: none; }

        /* --- Whiteboard Canvas --- */
        #whiteboard, #overlay-canvas, #event-capture-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #1f2937; border-radius: 0.75rem; }
        #whiteboard { z-index: 1; background-color: transparent; }
        #overlay-canvas { z-index: 2; pointer-events: none; background-color: transparent;}
        #event-capture-layer { z-index: 3; background-color: transparent;}
        #text-input-container { position: absolute; display: none; z-index: 60; }
        #text-input { background: #1f2937; border: 1px dashed #6b7280; color: white; outline: none; padding: 4px; border-radius: 4px; }

        /* --- Revamped Toolbar --- */
        #toolbar {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            gap: 0.75rem;
            padding: 0.5rem;
            margin-bottom: 1rem;
            position: relative;
            z-index: 100;
        }
        .toolbar-group { display: flex; align-items: center; padding: 0.25rem; gap: 0.25rem; }
        .divider { width: 1px; height: 24px; background-color: var(--border-color); margin: 0 0.5rem; }
        .tool-btn, .size-btn { background: transparent; border: none; color: var(--text-muted-color); padding: 0.5rem; border-radius: 0.5rem; transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); }
        .tool-btn:hover:not(:disabled), .size-btn:hover { transform: scale(1.15) rotate(-5deg); filter: brightness(1.2); color: var(--text-color); }
        .tool-btn.selected, .size-btn.selected { background-color: var(--accent-color); color: white; transform: scale(1.1); }
        .dropdown { position: relative; display: inline-block; }
        .dropdown-content { 
            visibility: hidden; opacity: 0; transition: all 0.2s ease-out; 
            position: absolute; top: 120%; left: 50%; transform: translateX(-50%) translateY(-10px);
            z-index: 110; padding: 0.5rem;
        }
        .dropdown.open .dropdown-content { visibility: visible; opacity: 1; transform: translateX(-50%) translateY(0); }
        .shape-btn {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            gap: 4px; width: 100%; height: 50px; font-size: 0.65rem;
        }
        .shape-btn i { font-size: 1.1rem; }
        
        /* --- Color Picker --- */
        #color-picker-popover {
            visibility: hidden; opacity: 0; position: absolute;
            padding: 1rem; z-index: 1000;
            transition: all 0.2s ease-out;
            transform: translateY(-10px);
        }
        #color-picker-popover.visible { visibility: visible; opacity: 1; transform: translateY(0); }
        #color-picker-btn { width: 2.25rem; height: 2.25rem; border-radius: 50%; border: 2px solid white; cursor: pointer; transition: transform 0.2s; }
        #color-picker-btn:hover { transform: scale(1.1); }
        #eyedropper-btn { font-size: 1.25rem; }
        body.eyedropper-active { cursor: crosshair; }

        /* --- Modals & Overlays --- */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
        .modal-overlay.visible { opacity: 1; pointer-events: auto; }
        .modal { transform: scale(0.95); transition: transform 0.3s ease; }
        .modal-overlay.visible .modal { transform: scale(1); }
        #image-viewer-overlay img { max-width: 90vw; max-height: 90vh; border-radius: 0.5rem; }
        
        /* --- GIF Search Modal --- */
        #gif-search-results { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.5rem; margin-top: 1rem; overflow-y: auto; max-height: 60vh; }
        #gif-search-results img { width: 100%; height: 100px; object-fit: cover; border-radius: 0.5rem; cursor: pointer; transition: transform 0.2s; }
        #gif-search-results img:hover { transform: scale(1.05); }

        /* --- Command Palette --- */
        #command-palette-overlay { z-index: 20000; }
        #command-palette { width: 640px; max-width: 90vw; }
        #command-input { width: 100%; background-color: #374151; border: none; padding: 1rem; font-size: 1.25rem; color: white; outline: none; }
        #command-list { max-height: 400px; overflow-y: auto; }
        .command-item { padding: 0.75rem 1rem; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .command-item:hover, .command-item.selected { background-color: var(--accent-color); }
        .command-item kbd { background-color: #4b5563; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; }

        /* --- AI Features --- */
        #beautify-suggestion {
            position: absolute;
            display: none;
            z-index: 200;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            align-items: center;
            gap: 0.75rem;
        }
        .loader {
            width: 2rem; height: 2rem; border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.3);
            border-top-color: #fff;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* AI Icon & Image Generation */
        #ai-icon-results, #ai-image-results {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
            max-height: 50vh;
            overflow-y: auto;
        }
        #ai-image-results { grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); }
        .ai-result-item {
            cursor: pointer; border-radius: 0.5rem; background-color: #374151;
            padding: 0.5rem; transition: all 0.2s ease; position: relative;
        }
        .ai-result-item:hover { transform: scale(1.05); background-color: var(--accent-color); }
        .ai-result-item img { width: 100%; height: auto; object-fit: contain; border-radius: 0.25rem; }
        #ai-image-generation-area .sub-btn { font-size: 0.8rem; padding: 0.25rem 0.5rem; height: auto; }

        /* Image Library */
        #image-library-gallery {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem; margin-top: 1rem; max-height: 70vh; overflow-y: auto; padding: 0.5rem;
        }
        .library-item { position: relative; border-radius: 0.5rem; overflow: hidden; }
        .library-item img { width: 100%; height: 150px; object-fit: cover; display: block; }
        .library-item-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); opacity: 0; transition: opacity 0.3s ease;
            display: flex; flex-direction: column; justify-content: space-between; align-items: center; padding: 0.5rem;
        }
        .library-item:hover .library-item-overlay { opacity: 1; }
        .library-item-prompt { font-size: 0.75rem; color: white; text-align: center; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; }
        .library-item-actions { display: flex; gap: 0.5rem; }
        .library-item-actions button { background: rgba(255,255,255,0.2); border: none; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; cursor: pointer; }
        .library-item-actions button:hover { background: var(--accent-color); }
    </style>
</head>
<body class="text-white antialiased">
    <div id="main-layout">
        <!-- Chat Column -->
        <div id="chat-container">
            <div id="chat-content-wrapper" class="glass-ui">
                <button id="toggle-chat-btn"><i class="fa-solid fa-chevron-left"></i></button>
                <div class="flex justify-between items-center mb-4 p-4">
                    <h2 id="chat-header" class="flex-grow text-center">Live Chat</h2>
                    <button id="summarize-chat-btn" class="chat-btn !p-2" title="Summarize Chat"><i class="fa-solid fa-wand-magic-sparkles"></i></button>
                </div>
                <div id="chat-messages" class="flex-grow px-4"></div>
                <div id="chat-input-area" class="p-4">
                    <textarea id="chat-input" placeholder="Sign in to use the chat." disabled></textarea>
                    <div class="flex justify-between w-full">
                        <button id="gif-search-btn" class="chat-btn" disabled><i class="fa-solid fa-photo-film"></i> &nbsp; GIF</button>
                        <button id="chat-send-btn" class="chat-btn" disabled><i class="fa-solid fa-paper-plane"></i> &nbsp; Send</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Whiteboard Column -->
        <div id="whiteboard-wrapper">
            <button id="show-chat-btn" class="hidden"><i class="fa-solid fa-chevron-right"></i></button>
            <div id="app-container">
                <!-- Header -->
                <header class="flex flex-col md:flex-row justify-between items-start mb-4">
                    <div>
                        <h1 id="whiteboard-title" class="text-2xl font-bold text-white rounded px-1"></h1>
                        <p id="whiteboard-description" class="text-sm text-gray-400 rounded px-1"></p>
                    </div>
                     <div class="flex flex-col items-end mt-2 md:mt-0 space-y-2">
                        <div id="auth-container" class="flex items-center gap-2">
                            <span id="user-display-name" class="text-sm text-white font-semibold"></span>
                            <button id="google-signin-btn" class="p-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg text-sm font-semibold flex items-center gap-2">
                                <i class="fa-brands fa-google"></i> Sign In
                            </button>
                            <button id="signout-btn" class="hidden p-2 bg-red-600 hover:bg-red-700 rounded-lg text-sm font-semibold">
                                Sign Out
                            </button>
                        </div>
                        <div class="text-xs text-gray-500">User ID: <span id="userId" class="font-mono bg-gray-700 px-2 py-1 rounded">Not Signed In</span></div>
                        <div class="text-xs text-gray-500">Version: <span id="version-number" class="font-mono bg-gray-700 px-2 py-1 rounded">3.0-img-gen</span></div>
                         <button id="help-btn" class="p-2 text-blue-400 hover:text-blue-500 text-2xl" title="Help (Ctrl+K)"><i class="fa-solid fa-circle-question"></i></button>
                    </div>
                </header>
                <!-- Revamped Toolbar -->
                <div id="toolbar" class="glass-ui">
                    <div class="toolbar-group">
                        <button data-tool="select" class="tool-btn p-2" title="Select & Move (V)"><i class="fa-solid fa-arrow-pointer"></i></button>
                        <button data-tool="pen" class="tool-btn selected p-2" title="Pen (P)"><i class="fa-solid fa-pen"></i></button>
                        <div id="shapes-dropdown" class="dropdown">
                             <button class="tool-btn p-2" title="Shapes (S)"><i class="fa-solid fa-shapes"></i></button>
                             <div class="dropdown-content glass-ui grid grid-cols-4 gap-2 p-3 w-64 rounded-md shadow-lg">
                                <!-- Shape buttons will be injected here by JS -->
                             </div>
                        </div>
                        <button data-tool="text" class="tool-btn p-2" title="Text (T)"><i class="fa-solid fa-font"></i></button>
                        <button data-tool="ai-icon" class="tool-btn p-2 text-purple-400" title="Generate Icon with AI"><i class="fa-solid fa-wand-magic-sparkles"></i></button>
                        <!-- NEW: AI Image Generation Button -->
                        <button id="ai-image-btn" class="tool-btn p-2 text-teal-400" title="Create Image with AI"><i class="fa-solid fa-image"></i></button>
                    </div>
                    <div class="divider"></div>
                    <div class="toolbar-group">
                        <button id="undo-btn" class="tool-btn p-2" title="Undo (Ctrl+Z)" disabled><i class="fa-solid fa-undo"></i></button>
                        <button id="redo-btn" class="tool-btn p-2" title="Redo (Ctrl+Y)" disabled><i class="fa-solid fa-redo"></i></button>
                    </div>
                    <div class="divider"></div>
                    <div class="toolbar-group">
                        <div id="brush-size-dropdown" class="dropdown">
                            <button class="tool-btn p-2" title="Brush Size"><i class="fa-solid fa-circle-half-stroke"></i></button>
                            <div class="dropdown-content glass-ui flex flex-col items-start gap-1 p-2 rounded-md shadow-lg">
                                <button data-size="2" class="size-btn p-2 flex items-center gap-2 w-full" title="Small"><div class="w-1.5 h-1.5 bg-white rounded-full"></div> Small</button>
                                <button data-size="5" class="size-btn p-2 flex items-center gap-2 w-full selected" title="Medium"><div class="w-2.5 h-2.5 bg-white rounded-full"></div> Medium</button>
                                <button data-size="10" class="size-btn p-2 flex items-center gap-2 w-full" title="Large"><div class="w-4 h-4 bg-white rounded-full"></div> Large</button>
                            </div>
                        </div>
                        <div id="color-picker-container" class="relative">
                            <button id="eyedropper-btn" class="tool-btn p-2" title="Eyedropper (I)"><i class="fa-solid fa-eye-dropper"></i></button>
                            <button id="color-picker-btn" title="Select Color"></button>
                        </div>
                    </div>
                    <div class="divider"></div>
                    <div class="toolbar-group">
                        <button id="duplicate-btn" class="tool-btn p-2 text-green-400" title="Duplicate Selected (Ctrl+D)" disabled><i class="fa-regular fa-copy"></i></button>
                        <button id="front-btn" class="tool-btn p-2 text-blue-400" title="Bring to Front" disabled><i class="fa-solid fa-layer-group"></i></button>
                        <button id="delete-btn" class="tool-btn p-2 text-red-400" title="Delete Selected (Del/Backspace)" disabled><i class="fa-solid fa-trash"></i></button>
                    </div>
                    <div class="divider"></div>
                    <div class="toolbar-group">
                         <!-- NEW: Image Library Button -->
                        <button id="image-library-btn" class="tool-btn p-2 text-yellow-400" title="Image Library"><i class="fa-solid fa-images"></i></button>
                        <button id="toggle-grid-btn" class="tool-btn p-2 selected" title="Toggle Grid (G)"><i class="fa-solid fa-border-all"></i></button>
                        <button id="toggle-snap-btn" class="tool-btn p-2 selected" title="Toggle Snapping"><i class="fa-solid fa-magnet"></i></button>
                        <button id="clear-canvas-btn" class="tool-btn p-2 text-red-400" title="Clear Canvas"><i class="fa-solid fa-eraser"></i></button>
                    </div>
                </div>
                <!-- Main Content Area -->
                <main id="main-content" class="flex-grow w-full h-full min-h-0 relative">
                    <canvas id="whiteboard"></canvas>
                    <canvas id="overlay-canvas"></canvas>
                    <div id="event-capture-layer"></div>
                    <div id="text-input-container"><input type="text" id="text-input" /></div>
                    <div id="beautify-suggestion" class="glass-ui">
                        <i class="fa-solid fa-wand-magic-sparkles text-purple-400"></i>
                        <span>Beautify Shape?</span>
                        <button id="beautify-confirm-btn" class="bg-indigo-600 rounded-md px-2 py-1 text-xs">Yes</button>
                        <button id="beautify-cancel-btn" class="bg-gray-600 rounded-md px-2 py-1 text-xs">No</button>
                    </div>
                </main>
            </div>
        </div>
    </div>
    
    <!-- Color Picker Popover -->
    <div id="color-picker-popover" class="glass-ui">
        <div class="color-picker-wheel"></div>
    </div>

    <!-- Modals -->
    <div id="command-palette-overlay" class="modal-overlay">
        <div id="command-palette" class="modal glass-ui flex flex-col overflow-hidden">
            <input id="command-input" type="text" placeholder="Type a command...">
            <div id="command-list"></div>
        </div>
    </div>
    <div id="confirm-modal-overlay" class="modal-overlay">
        <div id="confirm-modal" class="modal glass-ui p-6">
            <h2 id="confirm-modal-title" class="text-xl font-bold mb-4">Are you sure?</h2>
            <p id="confirm-modal-text" class="mb-6">This action cannot be undone.</p>
            <div class="flex justify-end gap-4">
                <button id="confirm-modal-cancel-btn" class="px-4 py-2 bg-gray-500 hover:bg-gray-600 rounded-lg font-semibold">Cancel</button>
                <button id="confirm-modal-confirm-btn" class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg font-semibold">Confirm</button>
            </div>
        </div>
    </div>
    <div id="api-key-modal-overlay" class="modal-overlay">
        <div id="api-key-modal" class="modal glass-ui p-6">
            <h2 class="text-2xl font-bold mb-4">Enter API Keys</h2>
            <p class="text-gray-300 mb-6">This app requires API keys for full functionality. Keys are stored only in your browser.</p>
            <div class="space-y-4">
                <div>
                    <label for="firebase-api-key-input" class="block text-sm font-medium text-gray-200 mb-1">Firebase & Google AI API Key</label>
                    <input type="password" id="firebase-api-key-input" class="w-full bg-gray-800 p-2 rounded border border-gray-600 focus:ring-2 focus:ring-indigo-500 outline-none" placeholder="Enter your Google Cloud API key">
                    <p class="text-xs text-gray-400 mt-1">Used for Firebase DB, Auth, and Gemini/Imagen AI features.</p>
                </div>
                <div>
                    <label for="tenor-api-key-input" class="block text-sm font-medium text-gray-200 mb-1">Tenor API Key</label>
                    <input type="password" id="tenor-api-key-input" class="w-full bg-gray-800 p-2 rounded border border-gray-600 focus:ring-2 focus:ring-indigo-500 outline-none" placeholder="Enter your Tenor API key">
                     <p class="text-xs text-gray-400 mt-1">Optional, for searching GIFs in chat.</p>
                </div>
            </div>
            <div class="flex justify-end mt-8">
                <button id="save-api-keys-btn" class="px-6 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg font-semibold chat-btn">Save and Continue</button>
            </div>
        </div>
    </div>
    <div id="gif-search-modal-overlay" class="modal-overlay">
        <div id="gif-search-modal" class="modal glass-ui p-6">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">Search for a GIF</h2>
                <button id="close-gif-search-btn" class="text-2xl">&times;</button>
            </div>
            <div id="gif-search-area">
                <div class="flex gap-2">
                    <input type="text" id="gif-search-input" class="w-full bg-gray-800 p-2 rounded border border-gray-600" placeholder="e.g., happy cat">
                    <button id="gif-search-execute-btn" class="chat-btn">Search</button>
                </div>
            </div>
            <div id="gif-search-results" class="mt-4"></div>
        </div>
    </div>
     <div id="image-viewer-overlay" class="modal-overlay">
        <img id="image-viewer-content" src="" alt="Full size image" />
    </div>
    <!-- AI Icon Generation Modal -->
    <div id="ai-icon-modal-overlay" class="modal-overlay">
        <div id="ai-icon-modal" class="modal glass-ui p-6 w-full max-w-2xl">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">Generate an Icon with AI</h2>
                <button id="close-ai-icon-btn" class="text-2xl">&times;</button>
            </div>
            <p class="text-gray-400 mb-4">Describe the icon you want to create. Keep it simple for best results (e.g., "a database", "a smiling user", "a rocket ship").</p>
            <div class="flex gap-2">
                <input type="text" id="ai-icon-prompt-input" class="w-full bg-gray-800 p-2 rounded border border-gray-600" placeholder="e.g., a simple cloud icon">
                <button id="ai-icon-generate-btn" class="chat-btn">Generate</button>
            </div>
            <div id="ai-icon-results" class="mt-4"></div>
        </div>
    </div>
    <!-- Chat Summary Modal -->
    <div id="chat-summary-modal-overlay" class="modal-overlay">
        <div id="chat-summary-modal" class="modal glass-ui p-6 w-full max-w-2xl">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">Chat Summary</h2>
                <button id="close-chat-summary-btn" class="text-2xl">&times;</button>
            </div>
            <div id="chat-summary-content" class="prose prose-invert max-w-none max-h-[70vh] overflow-y-auto"></div>
        </div>
    </div>
    <!-- NEW: AI Image Generation Modal -->
    <div id="ai-image-modal-overlay" class="modal-overlay">
        <div id="ai-image-modal" class="modal glass-ui p-6 w-full max-w-3xl">
            <div class="flex justify-between items-center mb-4">
                <h2 id="ai-image-modal-title" class="text-2xl font-bold">Create an Image with AI</h2>
                <button id="close-ai-image-btn" class="text-2xl">&times;</button>
            </div>
            <div id="ai-image-generation-area">
                <p class="text-gray-400 mb-4">Describe the image you want to create. Be as descriptive as you like!</p>
                <textarea id="ai-image-prompt-input" class="w-full bg-gray-800 p-2 rounded border border-gray-600 h-24" placeholder="e.g., a photorealistic cat astronaut floating in space"></textarea>
                <div class="flex gap-4 items-center my-4">
                    <label for="ai-image-aspect-ratio" class="font-semibold">Aspect Ratio:</label>
                    <select id="ai-image-aspect-ratio" class="bg-gray-800 p-2 rounded border border-gray-600">
                        <option value="1:1">Square (1:1)</option>
                        <option value="16:9">Landscape (16:9)</option>
                        <option value="9:16">Portrait (9:16)</option>
                        <option value="4:3">Standard (4:3)</option>
                        <option value="3:4">Tall (3:4)</option>
                    </select>
                    <button id="ai-image-generate-btn" class="chat-btn ml-auto">Generate</button>
                </div>
            </div>
            <div id="ai-image-results" class="mt-4 flex justify-center items-center min-h-[256px]"></div>
            <div id="ai-image-actions" class="mt-4 flex justify-center gap-4 hidden">
                <button id="ai-image-save-btn" class="chat-btn bg-green-600 hover:bg-green-700"><i class="fa-solid fa-save"></i> &nbsp; Save to Library</button>
                <button id="ai-image-insert-whiteboard-btn" class="chat-btn"><i class="fa-solid fa-plus-square"></i> &nbsp; Insert to Whiteboard</button>
                <button id="ai-image-send-chat-btn" class="chat-btn"><i class="fa-solid fa-paper-plane"></i> &nbsp; Send in Chat</button>
                <button id="ai-image-edit-prompt-btn" class="chat-btn bg-gray-600 hover:bg-gray-700"><i class="fa-solid fa-pen"></i> &nbsp; Edit Prompt</button>
            </div>
        </div>
    </div>
    <!-- NEW: Image Library Modal -->
    <div id="image-library-modal-overlay" class="modal-overlay">
        <div id="image-library-modal" class="modal glass-ui p-6 w-full max-w-5xl">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">My Image Library</h2>
                <button id="close-image-library-btn" class="text-2xl">&times;</button>
            </div>
            <div id="image-library-gallery">
                <!-- Saved images will be populated here by JS -->
            </div>
        </div>
    </div>


    <script type="module">
        // --- Firebase Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, onSnapshot, collection, addDoc, doc, setDoc, getDoc, query, where, updateDoc, serverTimestamp, writeBatch, getDocs, deleteDoc, setLogLevel, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- App Configuration ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'whiteboard-00-default';
        const whiteboardId = appId;
        
        // --- API Key Globals ---
        let firebaseApiKey, tenorApiKey;

        // --- DOM Elements ---
        const apiKeyModalOverlay = document.getElementById('api-key-modal-overlay');
        const saveApiKeysBtn = document.getElementById('save-api-keys-btn');
        const firebaseInput = document.getElementById('firebase-api-key-input');
        const tenorInput = document.getElementById('tenor-api-key-input');
        const main_content = document.getElementById('main-content');
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        const overlayCanvas = document.getElementById('overlay-canvas');
        const overlayCtx = overlayCanvas.getContext('2d');
        const eventCaptureLayer = document.getElementById('event-capture-layer');
        const deleteBtn = document.getElementById('delete-btn');
        const frontBtn = document.getElementById('front-btn');
        const duplicateBtn = document.getElementById('duplicate-btn');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const toggleGridBtn = document.getElementById('toggle-grid-btn');
        const toggleSnapBtn = document.getElementById('toggle-snap-btn');
        const clearCanvasBtn = document.getElementById('clear-canvas-btn');
        const colorPickerBtn = document.getElementById('color-picker-btn');
        const colorPickerPopover = document.getElementById('color-picker-popover');
        const eyedropperBtn = document.getElementById('eyedropper-btn');
        const commandPaletteOverlay = document.getElementById('command-palette-overlay');
        const commandInput = document.getElementById('command-input');
        const commandList = document.getElementById('command-list');
        const textInputContainer = document.getElementById('text-input-container');
        const textInput = document.getElementById('text-input');
        const chatContainer = document.getElementById('chat-container');
        const toggleChatBtn = document.getElementById('toggle-chat-btn');
        const showChatBtn = document.getElementById('show-chat-btn');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');
        const userIdEl = document.getElementById('userId');
        const helpBtn = document.getElementById('help-btn');
        const confirmModalOverlay = document.getElementById('confirm-modal-overlay');
        const confirmModalTitle = document.getElementById('confirm-modal-title');
        const confirmModalText = document.getElementById('confirm-modal-text');
        const confirmModalCancelBtn = document.getElementById('confirm-modal-cancel-btn');
        const confirmModalConfirmBtn = document.getElementById('confirm-modal-confirm-btn');
        const whiteboardTitleEl = document.getElementById('whiteboard-title');
        const whiteboardDescriptionEl = document.getElementById('whiteboard-description');
        const gifSearchBtn = document.getElementById('gif-search-btn');
        const gifSearchModalOverlay = document.getElementById('gif-search-modal-overlay');
        const closeGifSearchBtn = document.getElementById('close-gif-search-btn');
        const gifSearchInput = document.getElementById('gif-search-input');
        const gifSearchExecuteBtn = document.getElementById('gif-search-execute-btn');
        const gifSearchResults = document.getElementById('gif-search-results');
        const imageViewerOverlay = document.getElementById('image-viewer-overlay');
        const googleSignInBtn = document.getElementById('google-signin-btn');
        const signOutBtn = document.getElementById('signout-btn');
        const userDisplayNameEl = document.getElementById('user-display-name');
        // AI Feature DOM Elements
        const summarizeChatBtn = document.getElementById('summarize-chat-btn');
        const chatSummaryModalOverlay = document.getElementById('chat-summary-modal-overlay');
        const closeChatSummaryBtn = document.getElementById('close-chat-summary-btn');
        const chatSummaryContent = document.getElementById('chat-summary-content');
        const aiIconModalOverlay = document.getElementById('ai-icon-modal-overlay');
        const closeAiIconBtn = document.getElementById('close-ai-icon-btn');
        const aiIconPromptInput = document.getElementById('ai-icon-prompt-input');
        const aiIconGenerateBtn = document.getElementById('ai-icon-generate-btn');
        const aiIconResults = document.getElementById('ai-icon-results');
        const beautifySuggestion = document.getElementById('beautify-suggestion');
        const beautifyConfirmBtn = document.getElementById('beautify-confirm-btn');
        const beautifyCancelBtn = document.getElementById('beautify-cancel-btn');
        // NEW: AI Image Gen DOM Elements
        const aiImageBtn = document.getElementById('ai-image-btn');
        const aiImageModalOverlay = document.getElementById('ai-image-modal-overlay');
        const aiImageModalTitle = document.getElementById('ai-image-modal-title');
        const closeAiImageBtn = document.getElementById('close-ai-image-btn');
        const aiImageGenerationArea = document.getElementById('ai-image-generation-area'); // <-- FIX: This line was added
        const aiImagePromptInput = document.getElementById('ai-image-prompt-input');
        const aiImageAspectRatio = document.getElementById('ai-image-aspect-ratio');
        const aiImageGenerateBtn = document.getElementById('ai-image-generate-btn');
        const aiImageResults = document.getElementById('ai-image-results');
        const aiImageActions = document.getElementById('ai-image-actions');
        const aiImageSaveBtn = document.getElementById('ai-image-save-btn');
        const aiImageInsertWhiteboardBtn = document.getElementById('ai-image-insert-whiteboard-btn');
        const aiImageSendChatBtn = document.getElementById('ai-image-send-chat-btn');
        const aiImageEditPromptBtn = document.getElementById('ai-image-edit-prompt-btn');
        // NEW: Image Library DOM Elements
        const imageLibraryBtn = document.getElementById('image-library-btn');
        const imageLibraryModalOverlay = document.getElementById('image-library-modal-overlay');
        const closeImageLibraryBtn = document.getElementById('close-image-library-btn');
        const imageLibraryGallery = document.getElementById('image-library-gallery');


        // --- Firebase & State Globals ---
        let db, userId, auth, colorPicker;
        let isEyedropperActive = false;
        let unsubscribeFromDrawings, unsubscribeFromState, unsubscribeFromChat;
        let confirmCallback = null;
        const userProfiles = new Map();
        const state = {
            action: 'none', startPos: null, currentTool: 'pen', currentColor: '#FFFFFF', currentBrushSize: 5, currentEpoch: 0,
            allDrawings: new Map(), sortedDrawings: [], selectedObjectId: null, dragOffset: { x: 0, y: 0 },
            tempDrawing: null, transformHandle: null, isTexting: false, isShiftDown: false,
            undoStack: [], redoStack: [],
            isGridVisible: true, isSnapEnabled: true, gridSize: 20,
            originalObjectState: null, hoveredHandle: null,
            beautifyCandidate: null, // Store info for a potential shape beautification
            currentGeneratedImage: null, // Store data for the last generated image
            editingImageId: null // Store ID of image being edited
        };
        let commands = [];
        let activeCommandIndex = 0;
        
        // --- Content ---
        const dailyTitles = ["Flow", "Clarity", "Presence", "Intention", "Balance", "Growth", "Stillness", "Awareness", "Release", "Connect"];
        const dailyQuotes = [
            "The body benefits from movement, and the mind benefits from stillness.", "Yoga is the journey of the self, through the self, to the self.", "In the midst of movement and chaos, keep stillness inside of you.", "The longest journey of any person is the journey inward.", "Be where you are, not where you think you should be.", "The nature of yoga is to shine the light of awareness into the darkest corners of the body.", "We are not trying to escape our lives, but to return to them.", "Your task is not to seek for love, but merely to seek and find all the barriers within yourself that you have built against it.", "Let your practice be a celebration of life.", "The goal of yoga is not to be perfect, but to be whole."
        ];
       
        // --- User Profile Management ---
        async function getUserProfile(uid) {
            if (!uid) { return { name: 'Unknown User', avatar: null }; }
            if (userProfiles.has(uid)) { return userProfiles.get(uid); }
            try {
                const userDocRef = doc(db, `artifacts/${whiteboardId}/public/data/users`, uid);
                const userDoc = await getDoc(userDocRef);
                if (userDoc.exists()) {
                    const userData = userDoc.data();
                    userProfiles.set(uid, userData);
                    return userData;
                }
            } catch (error) { console.error("Error fetching user profile:", error); }
            const fallbackProfile = { name: `User ${uid.substring(0, 6)}...`, avatar: null };
            userProfiles.set(uid, fallbackProfile);
            return fallbackProfile;
        }

        // --- UI & Feature Setup ---
        function setupColorPicker() {
            colorPicker = new iro.ColorPicker('.color-picker-wheel', { width: 200, color: state.currentColor, borderWidth: 1, borderColor: "#fff", layout: [ { component: iro.ui.Wheel }, { component: iro.ui.Slider, options: { sliderType: 'hue' } }, { component: iro.ui.Slider, options: { sliderType: 'saturation' } }, { component: iro.ui.Slider, options: { sliderType: 'value' } }, { component: iro.ui.Slider, options: { sliderType: 'alpha' } }, ] });
            colorPicker.on('color:change', (color) => { const newColor = color.rgbaString; state.currentColor = newColor; colorPickerBtn.style.backgroundColor = newColor; if (state.selectedObjectId) { const selectedObject = state.allDrawings.get(state.selectedObjectId); if (selectedObject) { selectedObject.color = newColor; redrawCanvas(); } } });
            colorPicker.on('input:start', () => { if (state.selectedObjectId && !state.originalObjectState) { const selectedObject = state.allDrawings.get(state.selectedObjectId); state.originalObjectState = JSON.parse(JSON.stringify(selectedObject)); } });
            colorPicker.on('input:end', (color) => { if (state.selectedObjectId && state.originalObjectState) { const selectedObject = state.allDrawings.get(state.selectedObjectId); if (selectedObject) { selectedObject.color = color.rgbaString; const { id, ...data } = selectedObject; updateObjectInFirestore(id, data, state.originalObjectState); state.originalObjectState = null; } } });
            colorPickerBtn.addEventListener('click', (e) => { e.stopPropagation(); const btnRect = colorPickerBtn.getBoundingClientRect(); colorPickerPopover.style.top = `${btnRect.bottom + 10}px`; colorPickerPopover.style.left = `${btnRect.left + btnRect.width / 2 - colorPickerPopover.offsetWidth / 2}px`; colorPickerPopover.classList.toggle('visible'); });
            document.addEventListener('click', (e) => { if (!colorPickerPopover.contains(e.target) && e.target !== colorPickerBtn) { colorPickerPopover.classList.remove('visible'); } });
        }

        function activateEyedropper() {
            isEyedropperActive = true; document.body.classList.add('eyedropper-active'); eventCaptureLayer.style.cursor = 'crosshair';
            const pickColor = (e) => { const pos = getMousePos(e); const dpr = window.devicePixelRatio || 1; const pixel = ctx.getImageData(pos.x * dpr, pos.y * dpr, 1, 1).data; const color = `rgba(${pixel[0]}, ${pixel[1]}, ${pixel[2]}, ${pixel[3] / 255})`; state.currentColor = color; colorPicker.color.set(color); colorPickerBtn.style.backgroundColor = color; deactivateEyedropper(); };
            eventCaptureLayer.addEventListener('click', pickColor, { once: true });
        }

        function deactivateEyedropper() { isEyedropperActive = false; document.body.classList.remove('eyedropper-active'); updateCursor(); }

        function setupCommandPalette() {
            commands = [
                { name: 'Toggle Grid', action: () => toggleGridBtn.click(), shortcut: 'G' },
                { name: 'Toggle Snap', action: () => toggleSnapBtn.click(), shortcut: 'S' },
                { name: 'Clear Canvas', action: () => clearCanvasBtn.click(), shortcut: 'Del' },
                { name: 'Select Tool: Pen', action: () => selectTool('pen'), shortcut: 'P' },
                { name: 'Select Tool: Select/Move', action: () => selectTool('select'), shortcut: 'V' },
                { name: 'Select Tool: Text', action: () => selectTool('text'), shortcut: 'T' },
                { name: 'Activate Eyedropper', action: () => eyedropperBtn.click(), shortcut: 'I' },
                { name: 'Generate AI Icon', action: () => selectTool('ai-icon'), shortcut: 'A' },
                { name: 'Create AI Image', action: () => aiImageBtn.click(), shortcut: 'C' },
                { name: 'Open Image Library', action: () => imageLibraryBtn.click(), shortcut: 'L' },
            ];
            renderCommandList(commands);
            commandInput.addEventListener('input', () => { const query = commandInput.value.toLowerCase(); const filteredCommands = commands.filter(cmd => cmd.name.toLowerCase().includes(query)); renderCommandList(filteredCommands); });
            commandInput.addEventListener('keydown', (e) => { const items = commandList.querySelectorAll('.command-item'); if (items.length === 0) return; if (e.key === 'ArrowDown') { e.preventDefault(); activeCommandIndex = (activeCommandIndex + 1) % items.length; updateCommandSelection(); } else if (e.key === 'ArrowUp') { e.preventDefault(); activeCommandIndex = (activeCommandIndex - 1 + items.length) % items.length; updateCommandSelection(); } else if (e.key === 'Enter') { e.preventDefault(); const selectedItem = commandList.querySelector('.command-item.selected'); if (selectedItem) selectedItem.click(); } else if (e.key === 'Escape') { hideModal(commandPaletteOverlay); } });
            commandPaletteOverlay.addEventListener('click', (e) => { if (e.target === commandPaletteOverlay) hideModal(commandPaletteOverlay); });
        }

        function renderCommandList(commandArray) {
            commandList.innerHTML = ''; activeCommandIndex = 0;
            commandArray.forEach((cmd) => {
                const item = document.createElement('div'); item.className = 'command-item';
                item.innerHTML = `<span>${cmd.name}</span>${cmd.shortcut ? `<kbd>${cmd.shortcut}</kbd>` : ''}`;
                item.addEventListener('click', () => { cmd.action(); hideModal(commandPaletteOverlay); });
                commandList.appendChild(item);
            });
            updateCommandSelection();
        }
        
        function updateCommandSelection() { const items = commandList.querySelectorAll('.command-item'); items.forEach((item, index) => item.classList.toggle('selected', index === activeCommandIndex)); }
        
        function selectTool(tool) {
            if (!tool) return;
            if(isEyedropperActive) deactivateEyedropper();
            
            if (tool === 'ai-icon') { showModal(aiIconModalOverlay); aiIconPromptInput.focus(); return; }

            state.currentTool = tool;
            updateCursor();
            document.querySelectorAll('#toolbar .tool-btn').forEach(b => b.classList.remove('selected'));
            const btn = document.querySelector(`[data-tool="${tool}"]`);
            if(btn) {
                const parentDropdownBtn = btn.closest('.dropdown')?.querySelector('.tool-btn');
                if (parentDropdownBtn) parentDropdownBtn.classList.add('selected');
                else btn.classList.add('selected');
            }
            state.selectedObjectId = null; drawOverlay();
        }

        // --- Core Drawing & State Logic ---
        function drawGrid(rect) { if (!state.isGridVisible) return; ctx.save(); ctx.strokeStyle = 'rgba(156, 163, 175, 0.2)'; ctx.lineWidth = 1 / (window.devicePixelRatio || 1); for (let x = 0; x < rect.width; x += state.gridSize) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, rect.height); ctx.stroke(); } for (let y = 0; y < rect.height; y += state.gridSize) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(rect.width, y); ctx.stroke(); } ctx.restore(); }
        function redrawCanvas() { const dpr = window.devicePixelRatio || 1; const rect = main_content.getBoundingClientRect(); if (rect.width === 0 || rect.height === 0) return; [canvas, overlayCanvas].forEach(c => { const targetWidth = rect.width * dpr; const targetHeight = rect.height * dpr; if (c.width !== targetWidth || c.height !== targetHeight) { c.width = targetWidth; c.height = targetHeight; c.style.width = `${rect.width}px`; c.style.height = `${rect.height}px`; c.getContext('2d').scale(dpr, dpr); } }); ctx.clearRect(0, 0, rect.width, rect.height); drawGrid(rect); state.sortedDrawings = Array.from(state.allDrawings.values()).sort((a, b) => (a.timestamp?.seconds || 0) - (b.timestamp?.seconds || 0)); state.sortedDrawings.forEach(data => drawObject(ctx, data)); drawOverlay(); }
        function drawOverlay() { const rect = main_content.getBoundingClientRect(); overlayCtx.clearRect(0, 0, rect.width, rect.height); if (state.tempDrawing) { drawObject(overlayCtx, state.tempDrawing); } const selectedObject = state.allDrawings.get(state.selectedObjectId); if (selectedObject) { drawSelectionBox(selectedObject); deleteBtn.disabled = false; frontBtn.disabled = false; duplicateBtn.disabled = false; } else { deleteBtn.disabled = true; frontBtn.disabled = true; duplicateBtn.disabled = true; } }
        function drawObject(context, data) { if (!data) return; context.save(); const center = getObjectCenter(data); context.translate(center.x, center.y); context.rotate(data.rotation || 0); context.strokeStyle = data.color; context.fillStyle = data.color; context.lineWidth = data.lineWidth || 2; context.lineCap = 'round'; context.lineJoin = 'round'; switch(data.type) { case 'path': if (!data.points || data.points.length < 1) break; const pathCenter = getObjectCenter({type:'path', points: data.points}); context.translate(-pathCenter.x, -pathCenter.y); context.beginPath(); if (data.points.length < 3) { context.moveTo(data.points[0].x, data.points[0].y); for (let i = 1; i < data.points.length; i++) context.lineTo(data.points[i].x, data.points[i].y); } else { context.moveTo(data.points[0].x, data.points[0].y); for (var i = 1; i < data.points.length - 2; i++) { var c = (data.points[i].x + data.points[i + 1].x) / 2; var d = (data.points[i].y + data.points[i + 1].y) / 2; context.quadraticCurveTo(data.points[i].x, data.points[i].y, c, d); } context.quadraticCurveTo(data.points[i].x, data.points[i].y, data.points[i + 1].x, data.points[i + 1].y); } context.stroke(); break; case 'line': if (!data.points || data.points.length < 2) break; const halfWidth = (data.points[1].x - data.points[0].x) / 2; const halfHeight = (data.points[1].y - data.points[0].y) / 2; context.beginPath(); context.moveTo(-halfWidth, -halfHeight); context.lineTo(halfWidth, halfHeight); context.stroke(); break; case 'rectangle': context.strokeRect(-data.width / 2, -data.height / 2, data.width, data.height); break; case 'circle': context.beginPath(); context.arc(0, 0, data.radius, 0, 2 * Math.PI); context.stroke(); break; case 'polygon': case 'triangle': if (!data.points || data.points.length < 2) break; const polyCenter = getObjectCenter({ type: 'polygon', points: data.points }); context.translate(-polyCenter.x, -polyCenter.y); context.beginPath(); context.moveTo(data.points[0].x, data.points[0].y); for (let i = 1; i < data.points.length; i++) { context.lineTo(data.points[i].x, data.points[i].y); } context.closePath(); context.stroke(); break; case 'text': context.font = `${data.fontSize}px Inter`; context.textBaseline = 'middle'; context.textAlign = 'center'; context.fillText(data.text, 0, 0); break; case 'image': const img = new Image(); img.src = data.url; if (img.complete) { context.drawImage(img, -data.width / 2, -data.height / 2, data.width, data.height); } else { img.onload = redrawCanvas; } break; } context.restore(); }
        function drawSelectionBox(obj) { const handles = getTransformHandles(obj); if (!handles) return; overlayCtx.save(); overlayCtx.strokeStyle = '#4f46e5'; overlayCtx.lineWidth = 1; overlayCtx.setLineDash([4, 4]); overlayCtx.beginPath(); overlayCtx.moveTo(handles.tl.x, handles.tl.y); overlayCtx.lineTo(handles.tr.x, handles.tr.y); overlayCtx.lineTo(handles.br.x, handles.br.y); overlayCtx.lineTo(handles.bl.x, handles.bl.y); overlayCtx.closePath(); overlayCtx.stroke(); overlayCtx.setLineDash([]); overlayCtx.beginPath(); overlayCtx.moveTo(handles.tm.x, handles.tm.y); overlayCtx.lineTo(handles.rot.x, handles.rot.y); overlayCtx.stroke(); overlayCtx.fillStyle = '#4f46e5'; overlayCtx.beginPath(); overlayCtx.arc(handles.rot.x, handles.rot.y, 6, 0, 2*Math.PI); overlayCtx.fill(); Object.values(handles).forEach(handle => { if(handle.type === 'resize'){ overlayCtx.fillStyle = 'white'; overlayCtx.strokeStyle = '#4f46e5'; overlayCtx.lineWidth = 2; overlayCtx.fillRect(handle.x - 5, handle.y - 5, 10, 10); overlayCtx.strokeRect(handle.x - 5, handle.y - 5, 10, 10); } }); overlayCtx.restore(); }
        function getObjectBounds(obj) { let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; if(!obj) return null; switch (obj.type) { case 'rectangle': return { x: obj.x, y: obj.y, width: obj.width, height: obj.height }; case 'circle': return { x: obj.x - obj.radius, y: obj.y - obj.radius, width: obj.radius * 2, height: obj.radius * 2 }; case 'text': ctx.font = `${obj.fontSize}px Inter`; const metrics = ctx.measureText(obj.text); const height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent; return { x: obj.x - metrics.width / 2, y: obj.y - height / 2, width: metrics.width, height: height || obj.fontSize }; case 'image': return { x: obj.x - obj.width / 2, y: obj.y - obj.height / 2, width: obj.width, height: obj.height }; case 'path': case 'line': case 'triangle': case 'polygon': if (!obj.points || obj.points.length === 0) return {x:0,y:0,width:0,height:0}; obj.points.forEach(p => { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); }); return { x: minX, y: minY, width: Math.max(1, maxX - minX), height: Math.max(1, maxY - minY) }; default: return null; } }
        function getObjectCenter(obj) { const bounds = getObjectBounds(obj); if (!bounds) return {x: 0, y: 0}; return { x: bounds.x + bounds.width / 2, y: bounds.y + bounds.height / 2 }; }
        function rotatePoint(point, center, angle) { const dx = point.x - center.x; const dy = point.y - center.y; const sin = Math.sin(angle); const cos = Math.cos(angle); return { x: center.x + dx * cos - dy * sin, y: center.y + dx * sin + dy * cos }; }
        function getTransformHandles(obj) { const bounds = getObjectBounds(obj); if (!bounds || bounds.width <= 1 || bounds.height <= 1) return null; const center = getObjectCenter(obj); const w = bounds.width; const h = bounds.height; const angle = obj.rotation || 0; const corners = { tl: {x: center.x - w/2, y: center.y - h/2}, tr: {x: center.x + w/2, y: center.y - h/2}, bl: {x: center.x - w/2, y: center.y + h/2}, br: {x: center.x + w/2, y: center.y + h/2} }; const rotationHandleOffset = 30; const topMid = { x: center.x, y: center.y - h/2 }; const rotationPoint = { x: topMid.x, y: topMid.y - rotationHandleOffset }; const rotateCursorURL = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"/><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/></svg>`; return { tl:  {...rotatePoint(corners.tl, center, angle), type: 'resize', cursor: 'nwse-resize'}, tr:  {...rotatePoint(corners.tr, center, angle), type: 'resize', cursor: 'nesw-resize'}, bl:  {...rotatePoint(corners.bl, center, angle), type: 'resize', cursor: 'nesw-resize'}, br:  {...rotatePoint(corners.br, center, angle), type: 'resize', cursor: 'nwse-resize'}, tm: rotatePoint(topMid, center, angle), rot: {...rotatePoint(rotationPoint, center, angle), type: 'rotate', cursor: `url('${rotateCursorURL}') 12 12, auto`} }; }
        
        // --- MOUSE EVENT HANDLERS ---
        function handleMouseDown(e) {
            if (state.isTexting || isEyedropperActive) return;
            if (!userId) { console.warn("Cannot draw: User not authenticated."); return; }
            const pos = getMousePos(e); state.startPos = pos; state.action = 'none'; hideBeautifySuggestion();
            if (state.currentTool === 'select') {
                const currentSelectedObject = state.allDrawings.get(state.selectedObjectId);
                if (currentSelectedObject) {
                    const handles = getTransformHandles(currentSelectedObject);
                    if (handles) {
                        for (const key in handles) {
                            const handle = handles[key];
                            if (handle.type && Math.hypot(pos.x - handle.x, pos.y - handle.y) < 10) {
                                state.action = handle.type === 'rotate' ? 'rotating' : 'resizing'; state.transformHandle = key;
                                state.originalObjectState = JSON.parse(JSON.stringify(currentSelectedObject));
                                state.originalObjectState.center = getObjectCenter(currentSelectedObject);
                                return;
                            }
                        }
                    }
                }
                const clickedObjectId = findClickedObject(pos.x, pos.y);
                if (clickedObjectId) {
                    state.selectedObjectId = clickedObjectId; state.action = 'moving';
                    const obj = state.allDrawings.get(clickedObjectId); const center = getObjectCenter(obj);
                    state.dragOffset = { x: pos.x - center.x, y: pos.y - center.y };
                    state.originalObjectState = JSON.parse(JSON.stringify(obj));
                    eventCaptureLayer.style.cursor = 'grabbing';
                } else { state.selectedObjectId = null; }
                drawOverlay();
            } else if (state.currentTool === 'text') {
                startTextEntry(snapToGrid(pos));
            } else {
                state.action = 'drawing'; state.tempDrawing = createPreviewObject(snapToGrid(state.startPos), snapToGrid(pos));
            }
        }

        function handleMouseMove(e) { let pos = getMousePos(e); if (!state.startPos) { updateCursor(pos); return; } if (state.action === 'drawing') { if (state.currentTool === 'pen') { state.tempDrawing.points.push(pos); } else { state.tempDrawing = createPreviewObject(snapToGrid(state.startPos), snapToGrid(pos)); } drawOverlay(); } else if (state.action === 'moving' && state.selectedObjectId) { const selectedObject = state.allDrawings.get(state.selectedObjectId); const newCenter = { x: pos.x - state.dragOffset.x, y: pos.y - state.dragOffset.y }; const snappedCenter = snapToGrid(newCenter); moveObjectTo(selectedObject, snappedCenter.x, snappedCenter.y); drawOverlay(); } else if (state.action === 'rotating' && state.selectedObjectId) { const selectedObject = state.allDrawings.get(state.selectedObjectId); const center = state.originalObjectState.center; const originalAngle = Math.atan2(state.startPos.y - center.y, state.startPos.x - center.x); const newAngle = Math.atan2(pos.y - center.y, pos.x - center.x); selectedObject.rotation = (state.originalObjectState.rotation || 0) + (newAngle - originalAngle); drawOverlay(); } else if (state.action === 'resizing' && state.selectedObjectId) { const selectedObject = state.allDrawings.get(state.selectedObjectId); const center = state.originalObjectState.center; const angle = -(state.originalObjectState.rotation || 0); const localPos = rotatePoint(pos, center, angle); const origBounds = getObjectBounds(state.originalObjectState); if (!origBounds) return; let newWidth = Math.abs(localPos.x - center.x) * 2; let newHeight = Math.abs(localPos.y - center.y) * 2; if (state.isShiftDown && selectedObject.type !== 'line') { const origAspectRatio = origBounds.width / origBounds.height; if (newWidth / origBounds.width > newHeight / origBounds.height) { newHeight = newWidth / origAspectRatio; } else { newWidth = newHeight * origAspectRatio; } } if (selectedObject.type === 'rectangle' || selectedObject.type === 'image') { selectedObject.width = newWidth; selectedObject.height = newHeight; selectedObject.x = center.x; selectedObject.y = center.y; } else if (selectedObject.type === 'circle') { selectedObject.radius = Math.hypot(localPos.x - center.x, localPos.y - center.y); selectedObject.x = center.x; selectedObject.y = center.y; } else if (selectedObject.type === 'text') { const localStartPos = rotatePoint(state.startPos, center, angle); const origFontSize = state.originalObjectState.fontSize; const origDist = Math.hypot(localStartPos.x - center.x, localStartPos.y - center.y); const newDist = Math.hypot(localPos.x - center.x, localPos.y - center.y); if(origDist > 0.1) { const scale = newDist / origDist; selectedObject.fontSize = Math.max(5, origFontSize * scale); } } else if (['path', 'line', 'triangle', 'polygon'].includes(selectedObject.type)) { const scaleX = newWidth / origBounds.width; const scaleY = newHeight / origBounds.height; const originalPoints = state.originalObjectState.points; const originalCenter = getObjectCenter(state.originalObjectState); selectedObject.points = originalPoints.map(p => ({ x: originalCenter.x + (p.x - originalCenter.x) * scaleX, y: originalCenter.y + (p.y - originalCenter.y) * scaleY, })); } drawOverlay(); } else { updateCursor(pos); } }
        async function handleMouseUp(e) { if (!state.startPos) return; updateCursor(); const objToUpdate = state.allDrawings.get(state.selectedObjectId); if (state.action === 'drawing' && state.tempDrawing) { if (state.currentTool !== 'pen' || state.tempDrawing.points.length >= 2) { const newDocRef = await addObjectToFirestore(state.tempDrawing); if (newDocRef) { pushToUndoStack({type: 'add', payload: { id: newDocRef.id, data: state.tempDrawing }}); if (state.currentTool === 'pen') { checkForBeautify(newDocRef.id, state.tempDrawing); } } } } else if (['moving', 'resizing', 'rotating'].includes(state.action) && objToUpdate && state.originalObjectState) { const {id, ...data} = objToUpdate; updateObjectInFirestore(id, data, state.originalObjectState); } state.action = 'none'; state.startPos = null; state.tempDrawing = null; state.transformHandle = null; state.originalObjectState = null; redrawCanvas(); }
        
        function createPreviewObject(start, end) { const common = { color: state.currentColor, lineWidth: state.currentBrushSize, author: userId, epoch: state.currentEpoch, rotation: 0 }; let x1 = start.x, y1 = start.y, x2 = end.x, y2 = end.y; if (state.isShiftDown) { const dx = x2 - x1; const dy = y2 - y1; if (state.currentTool === 'line') { const angle = Math.atan2(dy, dx); const snappedAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4); const dist = Math.hypot(dx, dy); x2 = x1 + Math.cos(snappedAngle) * dist; y2 = y1 + Math.sin(snappedAngle) * dist; } else if (['rectangle', 'circle', 'polygon'].includes(state.currentTool) || state.currentTool.endsWith('-gon') || state.currentTool === 'star') { const size = Math.max(Math.abs(dx), Math.abs(dy)); x2 = x1 + Math.sign(dx) * size; y2 = y1 + Math.sign(dy) * size; } } const width = Math.abs(x1 - x2); const height = Math.abs(y1 - y2); const cx = (x1+x2)/2, cy = (y1+y2)/2; const rx = width / 2; const ry = height / 2; const generatePolygon = (sides) => ({ ...common, type: 'polygon', points: generatePolygonPoints(cx, cy, rx, ry, sides) }); switch (state.currentTool) { case 'pen': return { ...common, type: 'path', points: [start] }; case 'line': return { ...common, type: 'line', points: [{x:x1, y:y1}, {x:x2, y:y2}] }; case 'rectangle': return { ...common, type: 'rectangle', x: Math.min(x1, x2), y: Math.min(y1, y2), width, height }; case 'circle': return { ...common, type: 'circle', x: cx, y: cy, radius: Math.hypot(width, height) / 2 }; case 'triangle': return { ...common, type: 'polygon', points: generatePolygonPoints(cx, cy, rx, ry, 3, -Math.PI / 2) }; case 'diamond': return { ...common, type: 'polygon', points: generatePolygonPoints(cx, cy, rx, ry, 4) }; case 'pentagon': return generatePolygon(5); case 'hexagon': return generatePolygon(6); case 'heptagon': return generatePolygon(7); case 'octagon': return generatePolygon(8); case 'star': return { ...common, type: 'polygon', points: generateStarPoints(cx, cy, Math.max(rx, ry), Math.max(rx, ry) / 2, 5) }; case 'star-6': return { ...common, type: 'polygon', points: generateStarPoints(cx, cy, Math.max(rx, ry), Math.max(rx, ry) / 2, 6) }; case 'heart': return { ...common, type: 'polygon', points: generateHeartPoints(cx, cy, width, height) }; case 'cross': return { ...common, type: 'polygon', points: [ {x: cx - rx/3, y: y1}, {x: cx + rx/3, y: y1}, {x: cx + rx/3, y: cy - ry/3}, {x: x2, y: cy - ry/3}, {x: x2, y: cy + ry/3}, {x: cx + rx/3, y: cy + ry/3}, {x: cx + rx/3, y: y2}, {x: cx - rx/3, y: y2}, {x: cx - rx/3, y: cy + ry/3}, {x: x1, y: cy + ry/3}, {x: x1, y: cy - ry/3}, {x: cx - rx/3, y: cy - ry/3} ]}; case 'arrow-right': return { ...common, type: 'polygon', points: [ {x: x1, y: cy - ry/2}, {x: cx, y: cy - ry/2}, {x: cx, y: y1}, {x: x2, y: cy}, {x: cx, y: y2}, {x: cx, y: cy + ry/2}, {x: x1, y: cy + ry/2} ]}; case 'arrow-left': return { ...common, type: 'polygon', points: [ {x: x2, y: cy - ry/2}, {x: cx, y: cy - ry/2}, {x: cx, y: y1}, {x: x1, y: cy}, {x: cx, y: y2}, {x: cx, y: cy + ry/2}, {x: x2, y: cy + ry/2} ]}; default: return null; } }
        function generatePolygonPoints(cx, cy, rx, ry, sides, angleOffset = 0) { const points = []; for (let i = 0; i < sides; i++) { const angle = (i / sides) * 2 * Math.PI + angleOffset; points.push({ x: cx + rx * Math.cos(angle), y: cy + ry * Math.sin(angle) }); } return points; }
        function generateStarPoints(cx, cy, outerRadius, innerRadius, numPoints) { const points = []; const angleStep = Math.PI / numPoints; for (let i = 0; i < 2 * numPoints; i++) { const radius = i % 2 === 0 ? outerRadius : innerRadius; const angle = i * angleStep - Math.PI / 2; points.push({ x: cx + radius * Math.cos(angle), y: cy + radius * Math.sin(angle) }); } return points; }
        function generateHeartPoints(cx, cy, w, h) { const points = []; for(let i = 0; i < 100; i++) { const angle = (i/100) * 2 * Math.PI; const x = cx + w/2 * (16 * Math.pow(Math.sin(angle), 3)); const y = cy - h/2 * (13 * Math.cos(angle) - 5 * Math.cos(2*angle) - 2 * Math.cos(3*angle) - Math.cos(4*angle)); points.push({x, y}); } return points; }
        function findClickedObject(x, y) { for (let i = state.sortedDrawings.length - 1; i >= 0; i--) { const obj = state.sortedDrawings[i]; const center = getObjectCenter(obj); const angle = -(obj.rotation || 0); const localClick = rotatePoint({x,y}, center, angle); const bounds = getObjectBounds(obj); if (!bounds) continue; const fuzz = (obj.lineWidth || 2) / 2 + 5; if (localClick.x >= bounds.x - fuzz && localClick.x <= bounds.x + bounds.width + fuzz && localClick.y >= bounds.y - fuzz && localClick.y <= bounds.y + bounds.height + fuzz) { return obj.id; } } return null; }
        function moveObjectTo(obj, newCenterX, newCenterY) { const bounds = getObjectBounds(obj); if (!bounds) return; const oldCenterX = bounds.x + bounds.width / 2; const oldCenterY = bounds.y + bounds.height / 2; const dx = newCenterX - oldCenterX; const dy = newCenterY - oldCenterY; if (obj.points) { obj.points = obj.points.map(p => ({ x: p.x + dx, y: p.y + dy })); } else { obj.x += dx; obj.y += dy; } }
        
        // --- TEXT INPUT ---
        function startTextEntry(pos) {
            state.isTexting = true; eventCaptureLayer.style.pointerEvents = 'none';
            textInputContainer.style.left = `${pos.x}px`; textInputContainer.style.top = `${pos.y}px`; textInputContainer.style.display = 'block';
            textInput.style.color = state.currentColor; textInput.style.fontSize = `${state.currentBrushSize * 5 + 12}px`; textInput.value = ''; textInput.focus();
            const finish = async (shouldAddText) => {
                if (!state.isTexting) return; state.isTexting = false; eventCaptureLayer.style.pointerEvents = 'auto';
                document.removeEventListener('mousedown', handleClickOutside, true);
                if (shouldAddText) {
                    const text = textInput.value.trim();
                    if (text) {
                        const fontSize = state.currentBrushSize * 5 + 12;
                        const textData = { type: 'text', text, x: pos.x, y: pos.y, color: state.currentColor, fontSize: fontSize, author: userId, epoch: state.currentEpoch, rotation: 0 };
                        const newDocRef = await addObjectToFirestore(textData);
                        if (newDocRef) { pushToUndoStack({type: 'add', payload: { id: newDocRef.id, data: textData }}); }
                    }
                }
                textInput.value = ''; textInputContainer.style.display = 'none';
            };
            const handleClickOutside = (event) => { if (!textInputContainer.contains(event.target)) { finish(true); } };
            textInput.onkeydown = (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); finish(true); } else if (e.key === 'Escape') { finish(false); } };
            setTimeout(() => { document.addEventListener('mousedown', handleClickOutside, true); }, 0);
        }

        async function addObjectToFirestore(objData) { if (!userId) { console.error("Cannot add object: User not authenticated."); return null; } try { const docRef = await addDoc(collection(db, `artifacts/${whiteboardId}/public/data/drawings`), { ...objData, timestamp: serverTimestamp() }); return docRef; } catch (error) { console.error("Error adding document: ", error); return null;} }
        async function updateObjectInFirestore(docId, updatedData, originalData) { if(originalData) { pushToUndoStack({ type: 'update', payload: { id: docId, before: originalData, after: {...originalData, ...updatedData} }}); } try { await updateDoc(doc(db, `artifacts/${whiteboardId}/public/data/drawings`, docId), { ...updatedData, timestamp: serverTimestamp() }); } catch (error) { console.error("Error updating document: ", error); } }
        async function deleteSelectedObject() { if (!state.selectedObjectId) return; const objectToDelete = state.allDrawings.get(state.selectedObjectId); if(objectToDelete) { pushToUndoStack({ type: 'delete', payload: objectToDelete }); } try { await deleteDoc(doc(db, `artifacts/${whiteboardId}/public/data/drawings`, state.selectedObjectId)); state.selectedObjectId = null; redrawCanvas(); } catch (error) { console.error("Error deleting document: ", error); } }
        async function bringToFront() { if (!state.selectedObjectId) return; await updateObjectInFirestore(state.selectedObjectId, {}, state.allDrawings.get(state.selectedObjectId)); }
        async function duplicateSelectedObject() { if (!state.selectedObjectId) return; const original = state.allDrawings.get(state.selectedObjectId); const { id, timestamp, ...cloneData } = original; const center = getObjectCenter(cloneData); moveObjectTo(cloneData, center.x + 20, center.y + 20); const newDocRef = await addObjectToFirestore(cloneData); if (newDocRef) { pushToUndoStack({type: 'add', payload: { id: newDocRef.id, data: cloneData }}); state.selectedObjectId = newDocRef.id; drawOverlay(); } }
        function updateUndoRedoButtons() { undoBtn.disabled = state.undoStack.length === 0; redoBtn.disabled = state.redoStack.length === 0; }
        function pushToUndoStack(action) { state.undoStack.push(action); state.redoStack = []; updateUndoRedoButtons(); }
        async function handleUndo() { if (state.undoStack.length === 0) return; const action = state.undoStack.pop(); state.redoStack.push(action); state.selectedObjectId = null; switch (action.type) { case 'add': await deleteDoc(doc(db, `artifacts/${whiteboardId}/public/data/drawings`, action.payload.id)); break; case 'delete': const { id: delId, ...delData } = action.payload; await setDoc(doc(db, `artifacts/${whiteboardId}/public/data/drawings`, delId), delData); break; case 'update': const { id: updId, before: beforeData } = action.payload; const { id: ignoredId, ...updData } = beforeData; await updateDoc(doc(db, `artifacts/${whiteboardId}/public/data/drawings`, updId), updData); break; } updateUndoRedoButtons(); redrawCanvas(); }
        async function handleRedo() { if (state.redoStack.length === 0) return; const action = state.redoStack.pop(); state.undoStack.push(action); state.selectedObjectId = null; switch (action.type) { case 'add': const { id: addId, data: addData } = action.payload; await setDoc(doc(db, `artifacts/${whiteboardId}/public/data/drawings`, addId), addData); break; case 'delete': await deleteDoc(doc(db, `artifacts/${whiteboardId}/public/data/drawings`, action.payload.id)); break; case 'update': const { id: updId, after: afterData } = action.payload; const { id: ignoredId, ...updData } = afterData; await updateDoc(doc(db, `artifacts/${whiteboardId}/public/data/drawings`, updId), updData); break; } updateUndoRedoButtons(); redrawCanvas(); }
        function showModal(modal) { modal.classList.add('visible'); }
        function hideModal(modal) { modal.classList.remove('visible'); }
        function getMousePos(evt) { const rect = eventCaptureLayer.getBoundingClientRect(); return { x: evt.clientX - rect.left, y: evt.clientY - rect.top }; }
        function snapToGrid(pos) { if (!state.isSnapEnabled) return pos; return { x: Math.round(pos.x / state.gridSize) * state.gridSize, y: Math.round(pos.y / state.gridSize) * state.gridSize, }; }
        function updateCursor(pos) { let newCursor = ''; switch (state.currentTool) { case 'select': newCursor = 'grab'; break; case 'text': newCursor = 'text'; break; default: newCursor = 'crosshair'; } if (state.currentTool === 'select' && state.selectedObjectId) { const selectedObject = state.allDrawings.get(state.selectedObjectId); const handles = getTransformHandles(selectedObject); let handleFound = false; if (handles && pos) { for (const key in handles) { const handle = handles[key]; if (handle.type && Math.hypot(pos.x - handle.x, pos.y - handle.y) < 10) { newCursor = handle.cursor; handleFound = true; break; } } } } if (isEyedropperActive) { newCursor = 'crosshair'; } eventCaptureLayer.style.cursor = newCursor; }
        function showConfirmationModal(title, text, onConfirm) { confirmModalTitle.textContent = title; confirmModalText.textContent = text; confirmCallback = onConfirm; showModal(confirmModalOverlay); }
        async function clearAllDrawings() { const drawingsCollectionPath = `artifacts/${whiteboardId}/public/data/drawings`; const q = query(collection(db, drawingsCollectionPath)); const querySnapshot = await getDocs(q); if (querySnapshot.empty) return; const batch = writeBatch(db); querySnapshot.forEach((doc) => batch.delete(doc.ref)); await batch.commit(); await setDoc(doc(db, `artifacts/${whiteboardId}/public/data/state/main`), { epoch: Date.now() }, { merge: true }); }
        
        async function sendChatMessage(text, type = 'text', url = null) {
            if (!userId) return;
            const content = text ? text.trim() : '';
            if (content || url) {
                try {
                    const messageData = { author: userId, timestamp: serverTimestamp(), type: type };
                    if (content) messageData.text = content;
                    if (url) messageData.url = url;
                    await addDoc(collection(db, `artifacts/${whiteboardId}/public/data/chat`), messageData);
                    chatInput.value = '';
                } catch (error) { console.error("Error sending chat message:", error); }
            }
        }

        // --- Firebase Listeners ---
        function setupStateListener() { const stateDocPath = `artifacts/${whiteboardId}/public/data/state/main`; if(unsubscribeFromState) unsubscribeFromState(); unsubscribeFromState = onSnapshot(doc(db, stateDocPath), (docSnapshot) => { const boardState = docSnapshot.data() || {}; const newEpoch = boardState.epoch || Date.now(); if (newEpoch > state.currentEpoch) { state.currentEpoch = newEpoch; state.undoStack = []; state.redoStack = []; updateUndoRedoButtons(); setupDrawingsListener(); } }); }
        function setupDrawingsListener() { if (state.currentEpoch === 0) return; if (unsubscribeFromDrawings) unsubscribeFromDrawings(); state.allDrawings.clear(); state.selectedObjectId = null; redrawCanvas(); const drawingsCollectionPath = `artifacts/${whiteboardId}/public/data/drawings`; const q = query(collection(db, drawingsCollectionPath), where("epoch", "==", state.currentEpoch)); unsubscribeFromDrawings = onSnapshot(q, (snapshot) => { snapshot.docChanges().forEach((change) => { const docData = change.doc.data(); if (change.type === 'removed' || docData.isDeleted) { state.allDrawings.delete(change.doc.id); } else { state.allDrawings.set(change.doc.id, { id: change.doc.id, ...docData }); } }); redrawCanvas(); }, error => console.error("Drawings listener error:", error)); }
        
        async function setupChatListener() {
            const chatCollectionPath = `artifacts/${whiteboardId}/public/data/chat`;
            if (unsubscribeFromChat) unsubscribeFromChat();
            chatMessages.innerHTML = '';
            const q = query(collection(db, chatCollectionPath), orderBy("timestamp"));
            
            unsubscribeFromChat = onSnapshot(q, async (snapshot) => {
                for (const change of snapshot.docChanges()) {
                    if (change.type === "added") {
                        const msg = { id: change.doc.id, ...change.doc.data() };
                        if (document.querySelector(`[data-message-id="${msg.id}"]`)) { continue; }

                        const profile = await getUserProfile(msg.author);
                        const displayName = profile?.name || 'Anonymous';
                        const avatarUrl = profile?.avatar || `https://placehold.co/40x40/4b5563/FFFFFF?text=${displayName.charAt(0)}`;

                        const messageEl = document.createElement('div');
                        messageEl.className = 'chat-message';
                        messageEl.dataset.messageId = msg.id;

                        let textHtml = '', mediaHtml = '';
                        if (msg.text) { textHtml = `<div class="chat-text">${msg.text.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</div>`; }
                        if (msg.type === 'gif' || msg.type === 'image') { mediaHtml = `<img src="${msg.url}" class="chat-image" data-full-src="${msg.url}" alt="User-sent image">`; }
                        
                        messageEl.innerHTML = `
                            <img src="${avatarUrl}" class="chat-avatar" onerror="this.onerror=null;this.src='https://placehold.co/40x40/4b5563/FFFFFF?text=${displayName.charAt(0)}';">
                            <div class="chat-content">
                                <div class="chat-author">${displayName}</div>
                                ${textHtml}${mediaHtml}
                            </div>
                        `;
                        chatMessages.appendChild(messageEl);
                    }
                }
                if (snapshot.docChanges().length > 0) { chatMessages.scrollTop = chatMessages.scrollHeight; }
            }, error => {
                console.error("Chat listener error:", error);
                if (error.code === 'failed-precondition') { console.error("Firestore error suggests a missing index for the chat. Please create an index for the 'chat' collection on the 'timestamp' field (ascending)."); }
            });
        }


        function setDailyContent() { 
            const today = new Date(); 
            const dayOfYear = Math.floor((today - new Date(today.getFullYear(), 0, 0)) / (1000 * 60 * 60 * 24)); 
            const titleIndex = dayOfYear % dailyTitles.length; 
            const quoteIndex = dayOfYear % dailyQuotes.length; 
            whiteboardTitleEl.textContent = dailyTitles[titleIndex]; 
            whiteboardDescriptionEl.textContent = dailyQuotes[quoteIndex]; 
        }

        async function searchTenorGifs() {
            const query = gifSearchInput.value.trim();
            if (!query || !tenorApiKey) { gifSearchResults.innerHTML = `<p class="col-span-full text-center text-red-400">Tenor API key is not configured or query is empty.</p>`; return; }
            gifSearchExecuteBtn.disabled = true;
            gifSearchResults.innerHTML = `<div class="col-span-full flex justify-center items-center gap-2"><div class="loader"></div><span>Searching...</span></div>`;
            const clientKey = "collaborative-whiteboard-app"; const limit = 24; const apiUrl = `https://tenor.googleapis.com/v2/search?q=${encodeURIComponent(query)}&key=${tenorApiKey}&client_key=${clientKey}&limit=${limit}`;
            try {
                const response = await fetch(apiUrl);
                if (!response.ok) throw new Error(`Tenor API error! Status: ${response.status}.`);
                const result = await response.json();
                gifSearchResults.innerHTML = '';
                if (result.results?.length > 0) {
                    result.results.forEach(gif => {
                        const previewUrl = gif.media_formats.tinygif.url; const fullUrl = gif.media_formats.gif.url;
                        const img = document.createElement('img'); img.src = previewUrl; img.alt = gif.content_description; img.dataset.fullUrl = fullUrl;
                        img.addEventListener('click', () => { sendChatMessage(null, 'gif', fullUrl); hideModal(gifSearchModalOverlay); });
                        gifSearchResults.appendChild(img);
                    });
                } else { gifSearchResults.innerHTML = `<p class="col-span-full text-center text-gray-400">No GIFs found.</p>`; }
            } catch (error) { console.error("Error searching for GIFs:", error); gifSearchResults.innerHTML = `<p class="col-span-full text-center text-red-400">Failed to load GIFs.</p>`;
            } finally { gifSearchExecuteBtn.disabled = false; }
        }
        
        // --- Authentication Functions ---
        const signInWithGoogle = async () => {
            const googleProvider = new GoogleAuthProvider();
            try { await signInWithPopup(auth, googleProvider);
            } catch (error) { console.error("Google Sign-In failed:", error); userIdEl.textContent = 'Auth Error'; alert('Could not sign in with Google. Please check your Firebase project configuration and ensure Google authentication is enabled.'); }
        };

        const signOutUser = async () => {
            try { await signOut(auth); userProfiles.clear();
            } catch (error) { console.error("Sign-Out failed:", error); }
        };

        // --- AI Feature Functions ---
        async function summarizeChat() {
            if (!firebaseApiKey) { alert("Google AI API key is not configured."); return; }
            showModal(chatSummaryModalOverlay);
            chatSummaryContent.innerHTML = '<div class="flex justify-center items-center"><div class="loader"></div></div>';
            try {
                const chatCollection = collection(db, `artifacts/${whiteboardId}/public/data/chat`);
                const q = query(chatCollection, orderBy("timestamp"));
                const chatSnapshot = await getDocs(q);
                if (chatSnapshot.empty) { chatSummaryContent.innerHTML = '<p>The chat is empty. Nothing to summarize!</p>'; return; }
                let chatHistory = [];
                for (const doc of chatSnapshot.docs) { const msg = doc.data(); const profile = await getUserProfile(msg.author); const authorName = profile?.name || 'Anonymous'; if (msg.text) { chatHistory.push({ role: "user", parts: [{ text: `${authorName}: ${msg.text}` }] }); } }
                const prompt = "Please provide a concise summary of the following chat conversation. Identify key decisions, action items, and any unresolved questions. Format the output using Markdown headings for each section (e.g., ## Key Decisions).";
                chatHistory.unshift({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${firebaseApiKey}`;
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) { const errorBody = await response.json(); throw new Error(`API Error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`); }
                const result = await response.json();
                if (result.candidates && result.candidates.length > 0) { const text = result.candidates[0].content.parts[0].text; let html = text.replace(/## (.*)/g, '<h2 class="text-xl font-bold mt-4 mb-2">$1</h2>').replace(/\* \*(.*)\*\*/g, '<strong>$1</strong>').replace(/\* (.*)/g, '<li class="ml-4 list-disc">$1</li>').replace(/\n/g, '<br>'); chatSummaryContent.innerHTML = html;
                } else { throw new Error("No content returned from the AI."); }
            } catch (error) { console.error("Error summarizing chat:", error); chatSummaryContent.innerHTML = `<p class="text-red-400">Failed to generate summary. ${error.message}</p>`; }
        }

        async function generateAiIcon() {
            const prompt = aiIconPromptInput.value.trim();
            if (!prompt || !firebaseApiKey) { alert("Prompt or API key is missing."); return; }
            aiIconGenerateBtn.disabled = true;
            aiIconResults.innerHTML = '<div class="col-span-full flex justify-center items-center"><div class="loader"></div></div>';
            const fullPrompt = `A simple, modern, vector-style, flat, monochrome icon of ${prompt}. The icon should be on a transparent background, using only white lines or shapes. It should be easily recognizable and suitable for a whiteboard application.`;
            try {
                const payload = { instances: [{ prompt: fullPrompt }], parameters: { "sampleCount": 4 } };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${firebaseApiKey}`;
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) { const errorBody = await response.json(); throw new Error(`API Error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`); }
                const result = await response.json();
                aiIconResults.innerHTML = '';
                if (result.predictions && result.predictions.length > 0) {
                    result.predictions.forEach(prediction => {
                        if (prediction.bytesBase64Encoded) {
                            const imageUrl = `data:image/png;base64,${prediction.bytesBase64Encoded}`;
                            const item = document.createElement('div'); item.className = 'ai-result-item';
                            item.innerHTML = `<img src="${imageUrl}" alt="AI generated icon for '${prompt}'">`;
                            item.addEventListener('click', () => { addImageToCanvas(imageUrl, 100, 100); hideModal(aiIconModalOverlay); });
                            aiIconResults.appendChild(item);
                        }
                    });
                } else { throw new Error("No images were generated by the AI."); }
            } catch (error) { console.error("Error generating AI icon:", error); aiIconResults.innerHTML = `<p class="col-span-full text-center text-red-400">Failed to generate icon. ${error.message}</p>`;
            } finally { aiIconGenerateBtn.disabled = false; }
        }

        async function addImageToCanvas(url, width, height) {
            const rect = main_content.getBoundingClientRect();
            const centerPos = { x: rect.width / 2, y: rect.height / 2 };
            const imageData = { type: 'image', url: url, x: centerPos.x, y: centerPos.y, width: width, height: height, author: userId, epoch: state.currentEpoch, rotation: 0 };
            const newDocRef = await addObjectToFirestore(imageData);
            if (newDocRef) { pushToUndoStack({ type: 'add', payload: { id: newDocRef.id, data: imageData } }); state.selectedObjectId = newDocRef.id; redrawCanvas(); }
        }
        
        async function checkForBeautify(docId, drawingData) {
            if (!firebaseApiKey || drawingData.points.length < 10) return;
            const prompt = `Analyze the following sequence of 2D points and determine if it represents a simple geometric shape (like a circle, rectangle, line, or triangle). The points are: ${JSON.stringify(drawingData.points)}. If it is one of these shapes, respond with a JSON object describing the shape. For a 'circle', provide 'centerX', 'centerY', and 'radius'. For a 'rectangle', provide 'x', 'y', 'width', 'height'. For a 'line', provide 'startX', 'startY', 'endX', 'endY'. For a 'triangle', provide the three corner points 'p1', 'p2', 'p3'. If it's not a clear shape, respond with {\"shape\": \"none\"}.`;
            try {
                const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }], generationConfig: { responseMimeType: "application/json" } };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${firebaseApiKey}`;
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) return;
                const result = await response.json();
                if (result.candidates && result.candidates.length > 0) {
                    const jsonText = result.candidates[0].content.parts[0].text;
                    const shapeInfo = JSON.parse(jsonText);
                    if (shapeInfo.shape && shapeInfo.shape !== 'none') { state.beautifyCandidate = { originalId: docId, originalData: drawingData, newShapeInfo: shapeInfo }; showBeautifySuggestion(drawingData); }
                }
            } catch (error) { console.error("Error during shape beautification check:", error); }
        }

        function showBeautifySuggestion(originalDrawing) { const bounds = getObjectBounds(originalDrawing); if (!bounds) return; beautifySuggestion.style.left = `${bounds.x + bounds.width + 10}px`; beautifySuggestion.style.top = `${bounds.y}px`; beautifySuggestion.style.display = 'flex'; }
        function hideBeautifySuggestion() { beautifySuggestion.style.display = 'none'; state.beautifyCandidate = null; }

        async function applyBeautification() {
            if (!state.beautifyCandidate) return;
            const { originalId, originalData, newShapeInfo } = state.beautifyCandidate; let newObjectData;
            const common = { color: originalData.color, lineWidth: originalData.lineWidth, author: originalData.author, epoch: originalData.epoch, rotation: 0 };
            switch (newShapeInfo.shape) {
                case 'circle': newObjectData = { ...common, type: 'circle', x: newShapeInfo.centerX, y: newShapeInfo.centerY, radius: newShapeInfo.radius }; break;
                case 'rectangle': newObjectData = { ...common, type: 'rectangle', x: newShapeInfo.x, y: newShapeInfo.y, width: newShapeInfo.width, height: newShapeInfo.height }; break;
                case 'line': newObjectData = { ...common, type: 'line', points: [{x: newShapeInfo.startX, y: newShapeInfo.startY}, {x: newShapeInfo.endX, y: newShapeInfo.endY}] }; break;
                case 'triangle': newObjectData = { ...common, type: 'triangle', points: [newShapeInfo.p1, newShapeInfo.p2, newShapeInfo.p3] }; break;
                default: hideBeautifySuggestion(); return;
            }
            await updateObjectInFirestore(originalId, newObjectData, originalData);
            hideBeautifySuggestion();
        }

        // --- NEW: AI Image Generation & Library Functions ---
        function resetImageGenModal() {
            aiImageModalTitle.textContent = "Create an Image with AI";
            aiImagePromptInput.value = '';
            aiImageResults.innerHTML = '';
            aiImageActions.classList.add('hidden');
            aiImageGenerateBtn.disabled = false;
            aiImageGenerateBtn.classList.remove('hidden');
            aiImageGenerationArea.classList.remove('hidden');
            state.currentGeneratedImage = null;
            state.editingImageId = null;
        }

        async function generateAiImage() {
            const prompt = aiImagePromptInput.value.trim();
            if (!prompt) { alert("Please enter a prompt."); return; }
            if (!firebaseApiKey) { alert("Google AI API key is not configured."); return; }

            aiImageGenerateBtn.disabled = true;
            aiImageResults.innerHTML = '<div class="loader"></div>';
            aiImageActions.classList.add('hidden');

            try {
                const payload = { instances: [{ prompt: prompt }], parameters: { "sampleCount": 1, "aspectRatio": aiImageAspectRatio.value } };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${firebaseApiKey}`;
                
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) { const errorBody = await response.json(); throw new Error(`API Error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`); }
                
                const result = await response.json();
                if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                    const imageUrl = `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                    aiImageResults.innerHTML = `<img src="${imageUrl}" class="max-h-[50vh] rounded-lg" alt="AI generated image for '${prompt}'">`;
                    aiImageActions.classList.remove('hidden');
                    aiImageGenerateBtn.classList.add('hidden');
                    aiImageGenerationArea.classList.add('hidden');
                    state.currentGeneratedImage = { url: imageUrl, prompt: prompt, aspectRatio: aiImageAspectRatio.value };
                } else { throw new Error("No image was generated by the AI."); }
            } catch (error) {
                console.error("Error generating AI image:", error);
                aiImageResults.innerHTML = `<p class="text-red-400">Failed to generate image. ${error.message}</p>`;
                aiImageGenerateBtn.disabled = false;
            }
        }

        async function saveImageToLibrary() {
            if (!state.currentGeneratedImage || !userId) return;
            aiImageSaveBtn.disabled = true;
            aiImageSaveBtn.innerHTML = '<div class="loader !w-4 !h-4 !border-2"></div> &nbsp; Saving...';
            try {
                const imageData = {
                    ...state.currentGeneratedImage,
                    author: userId,
                    createdAt: serverTimestamp()
                };
                const collectionPath = `artifacts/${whiteboardId}/users/${userId}/images`;
                if (state.editingImageId) {
                    await setDoc(doc(db, collectionPath, state.editingImageId), imageData);
                } else {
                    await addDoc(collection(db, collectionPath), imageData);
                }
                hideModal(aiImageModalOverlay);
            } catch (error) {
                console.error("Error saving image to library:", error);
                alert("Could not save image to library. Please try again.");
            } finally {
                aiImageSaveBtn.disabled = false;
                aiImageSaveBtn.innerHTML = '<i class="fa-solid fa-save"></i> &nbsp; Save to Library';
            }
        }

        async function openImageLibrary() {
            if (!userId) { alert("Please sign in to use the image library."); return; }
            showModal(imageLibraryModalOverlay);
            imageLibraryGallery.innerHTML = '<div class="col-span-full flex justify-center items-center"><div class="loader"></div></div>';
            
            try {
                const collectionPath = `artifacts/${whiteboardId}/users/${userId}/images`;
                const q = query(collection(db, collectionPath), orderBy("createdAt", "desc"));
                const querySnapshot = await getDocs(q);
                
                imageLibraryGallery.innerHTML = '';
                if (querySnapshot.empty) {
                    imageLibraryGallery.innerHTML = '<p class="col-span-full text-center text-gray-400">Your library is empty. Create some images!</p>';
                    return;
                }

                querySnapshot.forEach(doc => {
                    const imageData = { id: doc.id, ...doc.data() };
                    const item = document.createElement('div');
                    item.className = 'library-item';
                    item.innerHTML = `
                        <img src="${imageData.url}" alt="AI generated image: ${imageData.prompt}">
                        <div class="library-item-overlay">
                            <p class="library-item-prompt">${imageData.prompt}</p>
                            <div class="library-item-actions">
                                <button title="Insert to Whiteboard"><i class="fa-solid fa-plus-square"></i></button>
                                <button title="Send in Chat"><i class="fa-solid fa-paper-plane"></i></button>
                                <button title="Edit Prompt"><i class="fa-solid fa-pen"></i></button>
                                <button title="Delete"><i class="fa-solid fa-trash"></i></button>
                            </div>
                        </div>
                    `;
                    const actions = item.querySelector('.library-item-actions');
                    actions.children[0].addEventListener('click', () => { addImageToCanvas(imageData.url, 300, 300); hideModal(imageLibraryModalOverlay); });
                    actions.children[1].addEventListener('click', () => { sendChatMessage(null, 'image', imageData.url); hideModal(imageLibraryModalOverlay); });
                    actions.children[2].addEventListener('click', () => editImageFromLibrary(imageData));
                    actions.children[3].addEventListener('click', () => deleteImageFromLibrary(imageData.id, item));
                    imageLibraryGallery.appendChild(item);
                });

            } catch (error) {
                console.error("Error opening image library:", error);
                imageLibraryGallery.innerHTML = '<p class="col-span-full text-center text-red-400">Could not load your image library.</p>';
            }
        }

        function editImageFromLibrary(imageData) {
            hideModal(imageLibraryModalOverlay);
            resetImageGenModal();
            state.editingImageId = imageData.id;
            aiImageModalTitle.textContent = "Edit Image Prompt";
            aiImagePromptInput.value = imageData.prompt;
            aiImageAspectRatio.value = imageData.aspectRatio || '1:1';
            showModal(aiImageModalOverlay);
        }

        async function deleteImageFromLibrary(imageId, itemElement) {
            showConfirmationModal("Delete Image?", "This will permanently delete the image from your library.", async () => {
                try {
                    await deleteDoc(doc(db, `artifacts/${whiteboardId}/users/${userId}/images`, imageId));
                    itemElement.remove();
                    if (imageLibraryGallery.children.length === 0) {
                        imageLibraryGallery.innerHTML = '<p class="col-span-full text-center text-gray-400">Your library is empty.</p>';
                    }
                } catch (error) {
                    console.error("Error deleting image:", error);
                    alert("Failed to delete image.");
                }
            });
        }

        // --- Main App Initialization ---
        function initializeAppLogic(fKey, tKey) {
            firebaseApiKey = fKey; 
            tenorApiKey = tKey;
            const firebaseConfig = { apiKey: firebaseApiKey, authDomain: "whiteboard-00.firebaseapp.com", projectId: "whiteboard-00", storageBucket: "whiteboard-00.appspot.com", messagingSenderId: "34696279859", appId: "1:34696279859:web:a01addc7e57a8d06947046", };
            
            try {
                const app = initializeApp(firebaseConfig);
                auth = getAuth(app); 
                db = getFirestore(app); 
                setLogLevel('debug');
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                alert("Firebase initialization failed, likely due to an invalid API key. Please re-enter your key.");
                localStorage.removeItem('firebaseApiKey');
                if(localStorage.getItem('tenorApiKey')) localStorage.removeItem('tenorApiKey');
                showModal(apiKeyModalOverlay);
                return;
            }

            hideModal(apiKeyModalOverlay);
            
            onAuthStateChanged(auth, async (user) => { 
                if (user) { 
                    userId = user.uid;
                    const displayName = user.displayName || 'Anonymous';
                    userIdEl.textContent = userId;
                    userDisplayNameEl.textContent = displayName;
                    googleSignInBtn.classList.add('hidden');
                    signOutBtn.classList.remove('hidden');
                    chatInput.disabled = false;
                    chatSendBtn.disabled = false;
                    summarizeChatBtn.disabled = false;
                    gifSearchBtn.disabled = !tenorApiKey;
                    aiImageBtn.disabled = false;
                    imageLibraryBtn.disabled = false;
                    chatInput.placeholder = 'Say something...';
                    const userDocRef = doc(db, `artifacts/${whiteboardId}/public/data/users`, user.uid);
                    await setDoc(userDocRef, { name: displayName, avatar: user.photoURL }, { merge: true });
                    setupStateListener(); 
                    setupDrawingsListener(); 
                    setupChatListener();
                } else { 
                    userId = null;
                    userIdEl.textContent = 'Not Signed In';
                    userDisplayNameEl.textContent = '';
                    googleSignInBtn.classList.remove('hidden');
                    signOutBtn.classList.add('hidden');
                    chatInput.disabled = true;
                    chatSendBtn.disabled = true;
                    summarizeChatBtn.disabled = true;
                    gifSearchBtn.disabled = true;
                    aiImageBtn.disabled = true;
                    imageLibraryBtn.disabled = true;
                    chatInput.placeholder = 'Sign in to use the chat.';
                    if(unsubscribeFromDrawings) unsubscribeFromDrawings();
                    if(unsubscribeFromState) unsubscribeFromState();
                    if(unsubscribeFromChat) unsubscribeFromChat();
                    state.allDrawings.clear();
                    chatMessages.innerHTML = '';
                    redrawCanvas();
                } 
            });

            // Setup Event Listeners for UI
            googleSignInBtn.addEventListener('click', signInWithGoogle);
            signOutBtn.addEventListener('click', signOutUser);
            document.querySelectorAll('#toolbar .tool-btn[data-tool]').forEach(button => button.addEventListener('click', (e) => selectTool(e.currentTarget.dataset.tool)));
            document.querySelectorAll('.dropdown').forEach(dropdown => { const button = dropdown.querySelector('.tool-btn, .size-btn'); button.addEventListener('click', (e) => { e.stopPropagation(); dropdown.classList.toggle('open'); }); });
            document.addEventListener('click', () => document.querySelectorAll('.dropdown.open').forEach(d => d.classList.remove('open')));
            document.querySelectorAll('#brush-size-dropdown .size-btn').forEach(button => { button.addEventListener('click', (e) => { state.currentBrushSize = parseInt(e.currentTarget.dataset.size, 10); document.querySelectorAll('#brush-size-dropdown .size-btn').forEach(b => b.classList.remove('selected')); e.currentTarget.classList.add('selected'); }); });
            undoBtn.addEventListener('click', handleUndo);
            redoBtn.addEventListener('click', handleRedo);
            deleteBtn.addEventListener('click', deleteSelectedObject);
            frontBtn.addEventListener('click', bringToFront);
            duplicateBtn.addEventListener('click', duplicateSelectedObject);
            toggleGridBtn.addEventListener('click', () => { state.isGridVisible = !state.isGridVisible; toggleGridBtn.classList.toggle('selected', state.isGridVisible); redrawCanvas(); });
            toggleSnapBtn.addEventListener('click', () => { state.isSnapEnabled = !state.isSnapEnabled; toggleSnapBtn.classList.toggle('selected', state.isSnapEnabled); });
            clearCanvasBtn.addEventListener('click', () => showConfirmationModal("Clear Canvas?", "This will clear the canvas for everyone and cannot be undone.", clearAllDrawings));
            helpBtn.addEventListener('click', () => { showModal(commandPaletteOverlay); commandInput.focus(); commandInput.select(); });
            confirmModalConfirmBtn.addEventListener('click', () => { if (typeof confirmCallback === 'function') { confirmCallback(); } hideModal(confirmModalOverlay); confirmCallback = null; });
            confirmModalCancelBtn.addEventListener('click', () => { hideModal(confirmModalOverlay); confirmCallback = null; });
            toggleChatBtn.addEventListener('click', () => { chatContainer.classList.add('hidden'); showChatBtn.classList.remove('hidden'); setTimeout(redrawCanvas, 310); });
            showChatBtn.addEventListener('click', () => { chatContainer.classList.remove('hidden'); showChatBtn.classList.add('hidden'); setTimeout(redrawCanvas, 310); });
            chatSendBtn.addEventListener('click', () => sendChatMessage(chatInput.value));
            chatInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendChatMessage(chatInput.value); } });
            gifSearchBtn.addEventListener('click', () => { showModal(gifSearchModalOverlay); gifSearchInput.focus(); });
            closeGifSearchBtn.addEventListener('click', () => hideModal(gifSearchModalOverlay));
            gifSearchExecuteBtn.addEventListener('click', searchTenorGifs);
            gifSearchInput.addEventListener('keydown', (e) => { if(e.key === 'Enter') searchTenorGifs(); });
            imageViewerOverlay.addEventListener('click', () => hideModal(imageViewerOverlay));
            chatMessages.addEventListener('click', (e) => { if(e.target.classList.contains('chat-image')) { document.getElementById('image-viewer-content').src = e.target.dataset.fullSrc; showModal(imageViewerOverlay); } });

            // AI Feature Listeners
            summarizeChatBtn.addEventListener('click', summarizeChat);
            closeChatSummaryBtn.addEventListener('click', () => hideModal(chatSummaryModalOverlay));
            closeAiIconBtn.addEventListener('click', () => hideModal(aiIconModalOverlay));
            aiIconGenerateBtn.addEventListener('click', generateAiIcon);
            aiIconPromptInput.addEventListener('keydown', (e) => { if(e.key === 'Enter') generateAiIcon(); });
            beautifyConfirmBtn.addEventListener('click', applyBeautification);
            beautifyCancelBtn.addEventListener('click', hideBeautifySuggestion);

            // NEW: AI Image Gen & Library Listeners
            aiImageBtn.addEventListener('click', () => { resetImageGenModal(); showModal(aiImageModalOverlay); });
            closeAiImageBtn.addEventListener('click', () => hideModal(aiImageModalOverlay));
            aiImageGenerateBtn.addEventListener('click', generateAiImage);
            aiImageSaveBtn.addEventListener('click', saveImageToLibrary);
            aiImageInsertWhiteboardBtn.addEventListener('click', () => { if(state.currentGeneratedImage) addImageToCanvas(state.currentGeneratedImage.url, 300, 300); hideModal(aiImageModalOverlay); });
            aiImageSendChatBtn.addEventListener('click', () => { if(state.currentGeneratedImage) sendChatMessage(null, 'image', state.currentGeneratedImage.url); hideModal(aiImageModalOverlay); });
            aiImageEditPromptBtn.addEventListener('click', () => {
                aiImageActions.classList.add('hidden');
                aiImageGenerateBtn.classList.remove('hidden');
                aiImageGenerationArea.classList.remove('hidden');
                aiImageResults.innerHTML = '';
                aiImagePromptInput.focus();
            });
            imageLibraryBtn.addEventListener('click', openImageLibrary);
            closeImageLibraryBtn.addEventListener('click', () => hideModal(imageLibraryModalOverlay));


            eventCaptureLayer.addEventListener('mousedown', handleMouseDown); 
            window.addEventListener('mousemove', handleMouseMove); 
            window.addEventListener('mouseup', handleMouseUp); 
            window.addEventListener('resize', redrawCanvas, { passive: true });
            
            window.addEventListener('keydown', (e) => {
                state.isShiftDown = e.shiftKey;
                const isModalOpen = document.querySelector('.modal-overlay.visible');
                const isTextInputActive = [textInput, chatInput, commandInput, aiIconPromptInput, aiImagePromptInput].includes(document.activeElement);
                if (isModalOpen || isTextInputActive) return;

                if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); handleUndo(); }
                if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); handleRedo(); }
                if ((e.ctrlKey || e.metaKey) && e.key === 'd') { e.preventDefault(); duplicateSelectedObject(); }
                if ((e.key === 'Delete' || e.key === 'Backspace') && state.selectedObjectId) { e.preventDefault(); deleteSelectedObject(); }
                if ((e.ctrlKey || e.metaKey) && e.key === 'k') { e.preventDefault(); showModal(commandPaletteOverlay); commandInput.focus(); commandInput.select(); }
                
                const toolShortcut = commands.find(c => c.shortcut && c.shortcut.toLowerCase() === e.key.toLowerCase());
                if (toolShortcut) { e.preventDefault(); toolShortcut.action(); }
            });
            window.addEventListener('keyup', (e) => { state.isShiftDown = e.shiftKey; });
            
            redrawCanvas();
        }

        function populateShapes() {
            const shapes = [
                { tool: 'line', icon: 'fa-minus', name: 'Line' }, { tool: 'rectangle', icon: 'fa-square', name: 'Rectangle' },
                { tool: 'circle', icon: 'fa-circle', name: 'Circle' }, { tool: 'triangle', icon: 'fa-play fa-rotate-270', name: 'Triangle' },
                { tool: 'diamond', icon: 'fa-gem', name: 'Diamond' }, { tool: 'pentagon', icon: 'fa-draw-polygon', name: 'Pentagon' },
                { tool: 'hexagon', icon: 'fa-draw-polygon', name: 'Hexagon' }, { tool: 'octagon', icon: 'fa-draw-polygon', name: 'Octagon' },
                { tool: 'star', icon: 'fa-star', name: 'Star' }, { tool: 'star-6', icon: 'fa-star-of-david', name: '6-Star' },
                { tool: 'heart', icon: 'fa-heart', name: 'Heart' }, { tool: 'cross', icon: 'fa-plus', name: 'Cross' },
                { tool: 'arrow-right', icon: 'fa-arrow-right', name: 'Arrow R' }, { tool: 'arrow-left', icon: 'fa-arrow-left', name: 'Arrow L' },
            ];
            const shapesContainer = document.querySelector('#shapes-dropdown .dropdown-content');
            shapesContainer.innerHTML = '';
            shapes.forEach(shape => {
                const button = document.createElement('button');
                button.dataset.tool = shape.tool; button.className = 'tool-btn shape-btn'; button.title = shape.name;
                button.innerHTML = `<i class="fa-solid ${shape.icon}"></i><span>${shape.name}</span>`;
                shapesContainer.appendChild(button);
            });
            shapesContainer.querySelectorAll('.tool-btn').forEach(button => { button.addEventListener('click', (e) => { selectTool(e.currentTarget.dataset.tool); document.querySelectorAll('.dropdown.open').forEach(d => d.classList.remove('open')); }); });
        }

        window.addEventListener('load', () => {
            setDailyContent();
            populateShapes();
            setupColorPicker(); 
            setupCommandPalette();
            colorPickerBtn.style.backgroundColor = state.currentColor;
            document.querySelector('#brush-size-dropdown .size-btn[data-size="5"]').classList.add('selected');

            eyedropperBtn.addEventListener('click', () => {
                if (isEyedropperActive) deactivateEyedropper();
                else activateEyedropper();
            });

            saveApiKeysBtn.addEventListener('click', () => {
                const fKey = firebaseInput.value.trim(); 
                const tKey = tenorInput.value.trim();
                if (fKey) {
                    localStorage.setItem('firebaseApiKey', fKey);
                    if(tKey) localStorage.setItem('tenorApiKey', tKey);
                    initializeAppLogic(fKey, tKey);
                } else {
                    alert("Please provide the Firebase & Google AI API key to continue."); 
                }
            });

            const storedFirebaseKey = localStorage.getItem('firebaseApiKey');
            const storedTenorKey = localStorage.getItem('tenorApiKey');

            if (storedFirebaseKey) {
                initializeAppLogic(storedFirebaseKey, storedTenorKey);
            } else {
                showModal(apiKeyModalOverlay);
            }
        });
    </script>
</body>
</html>
