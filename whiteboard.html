<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-900">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Whiteboard & Chat</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts & Font Awesome -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Base styles */
        body { font-family: 'Inter', sans-serif; }
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }

        /* Main Layout */
        #main-layout { display: flex; height: 100vh; width: 100vw; }
        #chat-container { width: 350px; flex-shrink: 0; background-color: #1f2937; display: flex; flex-direction: column; padding: 1rem; border-right: 2px solid #374151; }
        #whiteboard-wrapper { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }
        
        /* Chat Box Styles */
        #chat-header { font-size: 1.5rem; font-weight: bold; color: white; margin-bottom: 1rem; text-align: center; border-bottom: 1px solid #4b5563; padding-bottom: 0.5rem;}
        #chat-messages { flex-grow: 1; overflow-y: auto; font-family: Arial, sans-serif; font-size: 16px; line-height: 1.15; color: white;}
        .chat-message { margin-bottom: 1rem; display: flex; align-items: flex-start; }
        .chat-avatar { width: 40px; height: 40px; border-radius: 50%; margin-right: 10px; background-color: #4b5563; object-fit: cover;}
        .chat-content { display: flex; flex-direction: column; max-width: calc(100% - 50px); }
        .chat-author { font-weight: bold; color: #a5b4fc; font-size: 0.8rem; margin-bottom: 2px;  word-break: break-all; }
        .chat-text { word-wrap: break-word; white-space: pre-wrap; }
        .chat-image { max-width: 100%; border-radius: 0.5rem; cursor: pointer; }
        #chat-input-area { display: flex; margin-top: 1rem; flex-wrap: wrap; }
        #chat-input {
            flex-grow: 1; background: #374151; border: 1px solid #4b5563;
            color: white; padding: 0.5rem; border-radius: 0.5rem; 
            outline: none; resize: none; height: 8rem; /* Increased height */
            width: 100%; margin-bottom: 0.5rem;
        }
        #chat-input:disabled { background-color: #4b5563; cursor: not-allowed; }
        .chat-btn { background: #4f46e5; color: white; padding: 0 1rem; border-radius: 0.5rem; border: none; cursor: pointer; height: 2.5rem; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s; }
        .chat-btn:hover { background: #4338ca; }
        .chat-btn:disabled { background: #374151; opacity: 0.5; cursor: not-allowed; }
        
        /* Whiteboard Styles */
        #app-container { width: 100%; height: 100%; display: flex; flex-direction: column; background-color: #111827; padding: 1rem; }
        #main-content { position: relative; flex-grow: 1; background-color: #1f2937; } /* bg-gray-800 equivalent */
        #whiteboard, #overlay-canvas, #event-capture-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #whiteboard { z-index: 1; }
        #overlay-canvas { z-index: 2; pointer-events: none; }
        #event-capture-layer { z-index: 3; }
        .tool-btn, .color-swatch, .size-btn { transition: all 0.1s ease-in-out; }
        .tool-btn.selected, .size-btn.selected { background-color: #4f46e5; color: white; transform: scale(1.1); }
        .tool-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .color-swatch.parent-selected { box-shadow: 0 0 0 2px white, 0 0 0 4px var(--tw-color-ring); }
        .shade-swatch.selected { box-shadow: 0 0 0 2px white, 0 0 0 4px #4f46e5; transform: scale(1.1); }
        #text-input-container { position: absolute; display: none; z-index: 20; }
        #text-input { background: #1f2937; border: 1px dashed #6b7280; color: white; outline: none; padding: 4px; border-radius: 4px; }
        #delete-btn:disabled, #front-btn:disabled, #duplicate-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        #whiteboard-title, #whiteboard-description { cursor: default; }
        
        /* Dropdown menus */
        .dropdown { position: relative; }
        .dropdown-content { visibility: hidden; opacity: 0; transform: translateY(-10px); transition: all 0.2s ease-out; position: absolute; top: 115%; left: 50%; transform: translateX(-50%) translateY(0px); z-index: 50; }
        .dropdown:hover .dropdown-content { visibility: visible; opacity: 1; transform: translateX(-50%) translateY(0); }
        .dropdown-content .tool-btn { white-space: nowrap; }
        .dropdown-content .tool-btn:hover { background-color: #4b5563; transform: scale(1.1); }

        /* Effects & Modals */
        #flash-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9998; pointer-events: none; opacity: 0; animation: flash-animation 0.8s ease-out forwards; }
        @keyframes flash-animation { 0% { opacity: 0; } 25% { opacity: 0.7; } 50% { opacity: 0; } 75% { opacity: 0.7; } 100% { opacity: 0; } }
        .effect-particle { position: absolute; pointer-events: none; z-index: 9999; animation: float-up 5s linear forwards; font-size: 2rem; background-color: transparent !important; }
        @keyframes float-up { from { transform: translateY(0); opacity: 1; } to { transform: translateY(-100vh); opacity: 0; } }
        
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; display: flex; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        .modal-overlay.visible { opacity: 1; pointer-events: auto; }
        .modal { background-color: #1f2937; color: white; padding: 2rem; border-radius: 1rem; width: 90%; max-width: 600px; max-height: 80vh; overflow-y: auto; position: relative; display: flex; flex-direction: column; }
        #image-viewer-modal img { max-width: 90vw; max-height: 90vh; }
        
        /* GIF Search Modal */
        #gif-search-results { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.5rem; margin-top: 1rem; overflow-y: auto; max-height: 60vh; }
        #gif-search-results img { width: 100%; height: 100px; object-fit: cover; border-radius: 0.5rem; cursor: pointer; transition: transform 0.2s; }
        #gif-search-results img:hover { transform: scale(1.05); }

    </style>
</head>
<body class="bg-gray-900 text-white antialiased">
    <div id="main-layout">
        <!-- Chat Column -->
        <div id="chat-container">
            <div class="flex justify-between items-center mb-4">
                <h2 id="chat-header" class="flex-grow text-center">Live Chat</h2>
                <div class="flex gap-2">
                     <button id="save-chat-btn" class="chat-btn" title="Save Chat History"><i class="fa-solid fa-save"></i></button>
                     <button id="clear-chat-btn" class="chat-btn" title="Clear Chat History"><i class="fa-solid fa-trash"></i></button>
                </div>
            </div>
            <div id="chat-messages" class="flex-grow"></div>
            <div id="chat-input-area">
                <textarea id="chat-input" placeholder="Connecting to chat..." disabled></textarea>
                <div class="flex justify-between w-full">
                    <button id="gif-search-btn" class="chat-btn" disabled><i class="fa-solid fa-photo-film"></i> &nbsp; GIF</button>
                    <button id="chat-send-btn" class="chat-btn" disabled><i class="fa-solid fa-paper-plane"></i> &nbsp; Send</button>
                </div>
            </div>
        </div>

        <!-- Whiteboard Column -->
        <div id="whiteboard-wrapper">
            <div id="app-container">
                <!-- Header -->
                <header class="flex flex-col md:flex-row justify-between items-start mb-4 pb-4 border-b border-gray-700">
                    <div>
                        <h1 id="whiteboard-title" class="text-2xl font-bold text-white rounded px-1"></h1>
                        <p id="whiteboard-description" class="text-sm text-gray-400 rounded px-1"></p>
                    </div>
                     <div class="flex flex-col items-end mt-2 md:mt-0 text-xs text-gray-500 space-y-2">
                        <div>User: <span id="userId" class="font-mono bg-gray-700 px-2 py-1 rounded">Loading...</span></div>
                        <div>Version: <span id="version-number" class="font-mono bg-gray-700 px-2 py-1 rounded">1.41</span></div>
                         <button id="help-btn" class="p-2 text-blue-400 hover:text-blue-500 text-2xl" title="Help"><i class="fa-solid fa-circle-question"></i></button>
                    </div>
                </header>
                <!-- Toolbar -->
                <div id="toolbar" class="flex flex-wrap items-center justify-center gap-x-4 gap-y-2 mb-4">
                     <div id="tool-selector" class="flex items-center gap-2 bg-gray-700 p-1 rounded-lg">
                        <button data-tool="select" class="tool-btn p-2" title="Select & Move"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 3l7 19 2.5-7.5L22 3z"/></svg></button>
                        <button data-tool="pen" class="tool-btn selected p-2" title="Pen"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg></button>
                        <div class="dropdown">
                             <button class="tool-btn p-2" title="Shapes"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path></svg></button>
                             <div class="dropdown-content flex flex-col items-start gap-1 p-2 rounded-md bg-gray-600 shadow-lg">
                                <button data-tool="line" class="tool-btn p-2" title="Line"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="19" x2="19" y2="5"></line></svg></button>
                                <button data-tool="rectangle" class="tool-btn p-2" title="Rectangle"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/></svg></button>
                                <button data-tool="circle" class="tool-btn p-2" title="Circle"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/></svg></button>
                                <button data-tool="triangle" class="tool-btn p-2" title="Triangle"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 20h18L12 4z"/></svg></button>
                             </div>
                        </div>
                        <button data-tool="text" class="tool-btn p-2" title="Text"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg></button>
                    </div>
                     <div class="flex items-center gap-2 bg-gray-700 p-1 rounded-lg">
                        <button id="undo-btn" class="tool-btn p-2" title="Undo" disabled><i class="fa-solid fa-undo"></i></button>
                        <button id="redo-btn" class="tool-btn p-2" title="Redo" disabled><i class="fa-solid fa-redo"></i></button>
                    </div>
                     <div class="flex items-center gap-2 bg-gray-700 p-1 rounded-lg">
                        <button id="duplicate-btn" class="tool-btn p-2 text-green-400 hover:text-green-500" title="Duplicate Selected" disabled><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button>
                        <button id="front-btn" class="tool-btn p-2 text-blue-400 hover:text-blue-500" title="Bring to Front" disabled><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg></button>
                        <button id="delete-btn" class="tool-btn p-2 text-red-400 hover:text-red-500" title="Delete Selected" disabled><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg></button>
                    </div>
                     <div class="flex items-center gap-2 bg-gray-700 p-1 rounded-lg">
                        <button id="toggle-grid-btn" class="tool-btn p-2 selected" title="Toggle Grid"><i class="fa-solid fa-border-all"></i></button>
                        <button id="toggle-snap-btn" class="tool-btn p-2 selected" title="Toggle Snapping"><i class="fa-solid fa-magnet"></i></button>
                    </div>
                    <div id="brush-size-selector" class="flex items-center gap-2 bg-gray-700 p-1 rounded-lg">
                         <button data-size="2" class="size-btn selected p-2" title="Small"><div class="w-1.5 h-1.5 bg-white rounded-full"></div></button>
                         <button data-size="5" class="size-btn p-2" title="Medium"><div class="w-2.5 h-2.5 bg-white rounded-full"></div></button>
                         <button data-size="10" class="size-btn p-2" title="Large"><div class="w-4 h-4 bg-white rounded-full"></div></button>
                    </div>
                    <div id="color-palette" class="flex items-end gap-2"></div>
                    <div class="flex items-center gap-2">
                        <div class="dropdown">
                            <button class="p-2 bg-purple-600 hover:bg-purple-700 rounded-lg text-white" title="Screen Effects"><i class="fa-solid fa-wand-magic-sparkles"></i></button>
                            <div id="effects-dropdown" class="dropdown-content flex flex-col items-start gap-1 p-2 rounded-md bg-gray-600 shadow-lg">
                                <button data-effect="random-flash" class="tool-btn p-2 w-full text-left">Random Flash</button>
                                <button data-effect="hearts" class="tool-btn p-2 w-full text-left">Hearts</button>
                                <button data-effect="rain" class="tool-btn p-2 w-full text-left">Rain</button>
                                <button data-effect="pickles" class="tool-btn p-2 w-full text-left">Pickles</button>
                            </div>
                        </div>
                        <button id="save-btn" class="p-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-white" title="Save as PNG"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg></button>
                        <button id="clear-canvas-btn" class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg font-semibold">Clear Canvas</button>
                    </div>
                </div>
                <!-- Main Content Area -->
                <main id="main-content" class="flex-grow w-full h-full min-h-0 relative">
                    <canvas id="whiteboard" class="shadow-inner rounded-lg"></canvas>
                    <canvas id="overlay-canvas" class="rounded-lg"></canvas>
                    <div id="event-capture-layer" class="rounded-lg"></div>
                    <div id="text-input-container"><input type="text" id="text-input" /></div>
                </main>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="help-modal-overlay" class="modal-overlay">
        <div id="help-modal" class="modal">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">Whiteboard Help</h2>
                <button id="close-help-btn" class="text-2xl">&times;</button>
            </div>
            <h3>Core Concepts</h3>
            <p>Welcome to a space of inspiration! The title and description of this board change daily to provide a new creative spark.</p>
            <h4 class="font-bold mt-4 mb-2">Features</h4>
            <ul class="list-disc list-inside space-y-2">
                <li><b>Real-time Whiteboard:</b> Draw freely with various tools (pen, shapes, text), colors, and brush sizes. The pen tool uses smoothing for better results.</li>
                <li><b>Grid & Snapping:</b> Toggle a background grid and snap-to-grid for precise alignment of objects.</li>
                <li><b>Undo/Redo:</b> Easily undo and redo your actions on the canvas using the dedicated buttons.</li>
                <li><b>Live Chat:</b> Communicate with others on the board in real-time.</li>
                <li><b>GIF Search:</b> Click the "GIF" button to search for and share GIFs from Tenor directly into the chat.</li>
                <li><b>Object Manipulation:</b> Select objects to move, duplicate, delete, or bring to the front. Use the corner handles to resize and the top handle to rotate.</li>
                <li><b>Save & Export:</b> Save the whiteboard canvas as a PNG image and export the chat history as a text file.</li>
                <li><b>Fun Effects:</b> Add some visual flair with screen effects like "random flash", "abundance of hearts", "wet for you", and "big pickles".</li>
                <li><b>Daily Inspiration:</b> The board's title and description change daily to spark creativity.</li>
            </ul>
            <p class="mt-4 text-xs text-gray-400">Version: 1.41</p>
        </div>
    </div>

    <div id="gif-search-modal-overlay" class="modal-overlay">
        <div id="gif-search-modal" class="modal">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">Search for a GIF</h2>
                <button id="close-gif-search-btn" class="text-2xl">&times;</button>
            </div>
            <p class="text-gray-400 mb-4">Find the perfect GIF to share in the chat.</p>
            <div id="gif-search-area">
                <div class="flex gap-2">
                    <input type="text" id="gif-search-input" class="w-full bg-gray-700 p-2 rounded" placeholder="e.g., happy cat">
                    <button id="gif-search-execute-btn" class="chat-btn">Search</button>
                </div>
            </div>
            <div id="gif-search-results" class="mt-4"></div>
        </div>
    </div>

     <div id="image-viewer-overlay" class="modal-overlay">
        <img id="image-viewer-content" src="" alt="Full size image" />
    </div>
    <!-- Confirmation Modal -->
    <div id="confirm-modal-overlay" class="modal-overlay">
        <div id="confirm-modal" class="modal">
            <h2 id="confirm-modal-title" class="text-xl font-bold mb-4">Are you sure?</h2>
            <p id="confirm-modal-text" class="mb-6">This action cannot be undone.</p>
            <div class="flex justify-end gap-4">
                <button id="confirm-modal-cancel-btn" class="px-4 py-2 bg-gray-500 hover:bg-gray-600 rounded-lg font-semibold">Cancel</button>
                <button id="confirm-modal-confirm-btn" class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg font-semibold">Confirm</button>
            </div>
        </div>
    </div>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, onSnapshot, collection, addDoc, doc, setDoc, getDoc, query, where, updateDoc, serverTimestamp, writeBatch, getDocs, deleteDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- App Configuration ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'whiteboard-00-default';
        const apiKey = "AIzaSyA29N25PG96j0NURl1m-Hn8ydX9P_X97kY"; // User-provided API key
        const tenorApiKey = "AIzaSyA29N25PG96j0NURl1m-Hn8ydX9P_X97kY"; // Using the same key for Tenor as per user request
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : { apiKey: apiKey, authDomain: "whiteboard-00.firebaseapp.com", projectId: "whiteboard-00", storageBucket: "whiteboard-00.appspot.com", messagingSenderId: "34696279859", appId: "1:34696279859:web:a01addc7e57a8d06947046" };
        const whiteboardId = appId;

        // --- DOM Elements ---
        const whiteboardTitleEl = document.getElementById('whiteboard-title');
        const whiteboardDescriptionEl = document.getElementById('whiteboard-description');
        const eventCaptureLayer = document.getElementById('event-capture-layer');
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        const overlayCanvas = document.getElementById('overlay-canvas');
        const overlayCtx = overlayCanvas.getContext('2d');
        const textInputContainer = document.getElementById('text-input-container');
        const textInput = document.getElementById('text-input');
        const helpModalOverlay = document.getElementById('help-modal-overlay');
        const chatMessagesContainer = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');
        const deleteBtn = document.getElementById('delete-btn');
        const frontBtn = document.getElementById('front-btn');
        const duplicateBtn = document.getElementById('duplicate-btn');
        const clearCanvasBtn = document.getElementById('clear-canvas-btn');
        const clearChatBtn = document.getElementById('clear-chat-btn');
        const saveChatBtn = document.getElementById('save-chat-btn');
        const gifSearchBtn = document.getElementById('gif-search-btn');
        const gifSearchModalOverlay = document.getElementById('gif-search-modal-overlay');
        const closeGifSearchBtn = document.getElementById('close-gif-search-btn');
        const gifSearchInput = document.getElementById('gif-search-input');
        const gifSearchExecuteBtn = document.getElementById('gif-search-execute-btn');
        const gifSearchResults = document.getElementById('gif-search-results');
        const imageViewerOverlay = document.getElementById('image-viewer-overlay');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const toggleGridBtn = document.getElementById('toggle-grid-btn');
        const toggleSnapBtn = document.getElementById('toggle-snap-btn');
        const confirmModalOverlay = document.getElementById('confirm-modal-overlay');
        const confirmModalTitle = document.getElementById('confirm-modal-title');
        const confirmModalText = document.getElementById('confirm-modal-text');
        const confirmModalCancelBtn = document.getElementById('confirm-modal-cancel-btn');
        const confirmModalConfirmBtn = document.getElementById('confirm-modal-confirm-btn');

        // --- Firebase & State Globals ---
        let db, userId, auth;
        let unsubscribeFromDrawings, unsubscribeFromState, unsubscribeFromEvents, unsubscribeFromChat;
        let localChatHistory = [];
        let confirmCallback = null;
        const userAvatars = new Map();
        let areGenAiFeaturesEnabled = true; // For avatar generation
        const state = {
            action: 'none', startPos: null, currentTool: 'pen', currentColor: '#FFFFFF', currentBrushSize: 2, currentEpoch: 0,
            allDrawings: new Map(), sortedDrawings: [], selectedObjectId: null, dragOffset: { x: 0, y: 0 },
            tempDrawing: null, transformHandle: null, isTexting: false, isShiftDown: false,
            undoStack: [], redoStack: [],
            isGridVisible: true, isSnapEnabled: true, gridSize: 20,
            originalObjectState: null,
        };
        
        const dailyTitles = ["Flow", "Clarity", "Presence", "Intention", "Balance", "Growth", "Stillness", "Awareness", "Release", "Connect"];
        const dailyQuotes = [
            "The body benefits from movement, and the mind benefits from stillness.", "Yoga is the journey of the self, through the self, to the self.", "In the midst of movement and chaos, keep stillness inside of you.", "The longest journey of any person is the journey inward.", "Be where you are, not where you think you should be.", "The nature of yoga is to shine the light of awareness into the darkest corners of the body.", "We are not trying to escape our lives, but to return to them.", "Your task is not to seek for love, but merely to seek and find all the barriers within yourself that you have built against it.", "Let your practice be a celebration of life.", "The goal of yoga is not to be perfect, but to be whole."
        ];
        
        const userNicknames = {
            'lALY0TmTtaNdbtSjkt8o96NbS4z2': 'Sexy Honey Bee',
            '4Kgf667MeLODXTwhfBkhIWERQdG3': 'White Stallion'
        };

        // --- Avatar & Name Generation ---
        function getUserDisplayName(uid) { return userNicknames[uid] || uid; }

        async function getOrGenerateAvatar(uid) {
            if (!areGenAiFeaturesEnabled) return null;
            if (userAvatars.has(uid) && userAvatars.get(uid).url) {
                return userAvatars.get(uid).url;
            }

            const avatarDocRef = doc(db, `artifacts/${whiteboardId}/public/data/avatars`, uid);
            try {
                const avatarDoc = await getDoc(avatarDocRef);
                const oneDayAgo = Date.now() - 24 * 60 * 60 * 1000;

                if (avatarDoc.exists() && avatarDoc.data().generatedAt?.toMillis() > oneDayAgo) {
                    const url = avatarDoc.data().imageUrl;
                    userAvatars.set(uid, { url });
                    return url;
                }
            } catch (error) {
                console.error("Error fetching avatar from Firestore:", error);
                // Continue to generation
            }


            const nickname = getUserDisplayName(uid);
            const prompt = `Create a unique, simple, modern, abstract, and colorful SVG avatar for a user named '${nickname}'. The SVG must be exactly 100x100 pixels. Use clean geometric shapes and interesting color palettes. Do not include any text, raster images, or font dependencies. The background should be a solid color. Return ONLY the raw SVG code, starting with "<svg" and ending with "</svg>".`;

            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: {
                    temperature: 0.8,
                    topK: 40,
                    topP: 0.95,
                    maxOutputTokens: 2048,
                }
            };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorBody = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, details: ${errorBody}`);
                }

                const result = await response.json();
                
                const candidate = result.candidates && result.candidates[0];
                if (!candidate) {
                    throw new Error("No candidates in API response.");
                }

                if (candidate.finishReason && candidate.finishReason !== "STOP") {
                    throw new Error(`Avatar generation failed: ${candidate.finishReason}`);
                }
                
                if (candidate.content?.parts?.[0]?.text) {
                    let svgText = candidate.content.parts[0].text.replace(/```svg/g, '').replace(/```/g, '').trim();
                    const svgDataUrl = `data:image/svg+xml;base64,${btoa(svgText)}`;
                    await setDoc(avatarDocRef, { imageUrl: svgDataUrl, generatedAt: serverTimestamp() });
                    userAvatars.set(uid, { url: svgDataUrl });
                    return svgDataUrl;
                } else {
                    throw new Error("Invalid or empty content in API response.");
                }
            } catch (error) {
                console.error(`Failed to generate avatar for ${uid}.`, error);
                if (error.message.includes("403")) {
                    if (areGenAiFeaturesEnabled) {
                        console.warn("Avatar generation has been disabled due to a permission error. To fix this, enable the 'Generative Language API' in your Google Cloud project.");
                        areGenAiFeaturesEnabled = false;
                    }
                }
                return null; // Return null to use fallback
            }
        }


        // --- Firebase Listeners ---
        function setupStateListener() { 
            const stateDocPath = `artifacts/${whiteboardId}/public/data/state/main`; 
            if(unsubscribeFromState) unsubscribeFromState(); 
            unsubscribeFromState = onSnapshot(doc(db, stateDocPath), (docSnapshot) => { 
                const boardState = docSnapshot.data() || {};
                const newEpoch = boardState.epoch || Date.now();
                if (newEpoch !== state.currentEpoch) { 
                    state.currentEpoch = newEpoch; 
                    setupDrawingsListener(); 
                } 
            }); 
        }
        function setupDrawingsListener() { if (state.currentEpoch === 0) return; if (unsubscribeFromDrawings) unsubscribeFromDrawings(); state.allDrawings.clear(); state.selectedObjectId = null; redrawCanvas(); const drawingsCollectionPath = `artifacts/${whiteboardId}/public/data/drawings`; const q = query(collection(db, drawingsCollectionPath), where("epoch", "==", state.currentEpoch)); unsubscribeFromDrawings = onSnapshot(q, (snapshot) => { let shouldRedraw = false; snapshot.docChanges().forEach((change) => { shouldRedraw = true; const docData = change.doc.data(); if (change.type === 'removed' || docData.isDeleted) { state.allDrawings.delete(change.doc.id); } else { state.allDrawings.set(change.doc.id, { id: change.doc.id, ...docData }); } }); if(shouldRedraw) { state.sortedDrawings = Array.from(state.allDrawings.values()).sort((a, b) => (a.timestamp?.seconds || 0) - (b.timestamp?.seconds || 0)); redrawCanvas(); } }); }
        function setupEventsListener() { const eventsCollectionPath = `artifacts/${whiteboardId}/public/data/events`; const q = query(collection(db, eventsCollectionPath), where("timestamp", ">", new Date(Date.now() - 10000))); if(unsubscribeFromEvents) unsubscribeFromEvents(); unsubscribeFromEvents = onSnapshot(q, (snapshot) => { snapshot.docChanges().forEach((change) => { if (change.type === "added") { const eventData = change.doc.data(); if (eventData.author !== userId) { triggerEffect(eventData.type); } } }); }); }
        
        async function setupChatListener() {
            const chatCollectionPath = `artifacts/${whiteboardId}/public/data/chat`;
            const q = query(collection(db, chatCollectionPath));
            if (unsubscribeFromChat) unsubscribeFromChat();
            unsubscribeFromChat = onSnapshot(q, async (snapshot) => {
                const messages = snapshot.docs.map(doc => ({id: doc.id, ...doc.data()}));
                messages.sort((a, b) => (a.timestamp?.seconds || 0) - (b.timestamp?.seconds || 0));
                localChatHistory = messages;
                 let messagesHtml = '';
                for(const msg of messages) {
                    const avatarUrl = await getOrGenerateAvatar(msg.author);
                    const displayName = getUserDisplayName(msg.author);
                    let textHtml = '';
                    let mediaHtml = '';

                    if (msg.text) {
                        const sanitizedText = msg.text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        textHtml = `<div class="chat-text">${sanitizedText}</div>`;
                    }
                    
                    const mediaMargin = msg.text ? 'mt-2' : '';
                    if (msg.type === 'image') {
                        mediaHtml = `<img src="${msg.url}" class="chat-image ${mediaMargin}" data-full-src="${msg.url}" alt="AI generated image">`;
                    } else if (msg.type === 'gif') {
                        mediaHtml = `<img src="${msg.url}" class="chat-image ${mediaMargin}" data-full-src="${msg.url}" alt="User-selected GIF">`;
                    }
                    
                    const contentHtml = textHtml + mediaHtml;
                    const finalAvatarUrl = avatarUrl || 'https://placehold.co/40x40/4b5563/FFFFFF?text=?';

                    messagesHtml += `
                        <div class="chat-message" data-message-id="${msg.id}">
                            <img src="${finalAvatarUrl}" class="chat-avatar">
                            <div class="chat-content">
                                <div class="chat-author">${displayName}</div>
                                ${contentHtml}
                            </div>
                        </div>
                    `;
                };
                chatMessagesContainer.innerHTML = messagesHtml;
                chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
            });
        }
        
        // --- Drawing & Core Logic ---
        function drawGrid() { if (!state.isGridVisible) return; ctx.save(); ctx.strokeStyle = '#374151'; /* gray-700 */ ctx.lineWidth = 0.5; for (let x = 0; x < canvas.width; x += state.gridSize) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); } for (let y = 0; y < canvas.height; y += state.gridSize) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); } ctx.restore(); }
        function redrawCanvas() { const dpr = window.devicePixelRatio || 1; const rect = document.getElementById('main-content').getBoundingClientRect(); if (rect.width === 0 || rect.height === 0) return; [canvas, overlayCanvas].forEach(c => { const targetWidth = rect.width * dpr; const targetHeight = rect.height * dpr; if (c.width !== targetWidth || c.height !== targetHeight) { c.width = targetWidth; c.height = targetHeight; if (c.style) { c.style.width = `${rect.width}px`; c.style.height = `${rect.height}px`; } c.getContext('2d').scale(dpr, dpr); } }); ctx.clearRect(0, 0, canvas.width, canvas.height); drawGrid(); state.sortedDrawings.forEach(data => drawObject(ctx, data)); drawOverlay(); }
        function drawOverlay() { overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height); if (state.tempDrawing) { drawObject(overlayCtx, state.tempDrawing); } const selectedObject = state.allDrawings.get(state.selectedObjectId); if (selectedObject) { drawSelectionBox(selectedObject); deleteBtn.disabled = false; frontBtn.disabled = false; duplicateBtn.disabled = false; } else { deleteBtn.disabled = true; frontBtn.disabled = true; duplicateBtn.disabled = true; } }
        
        function drawObject(context, data) {
            if (!data) return;
            context.save();

            const center = getObjectCenter(data);
            context.translate(center.x, center.y);
            context.rotate(data.rotation || 0);

            context.strokeStyle = data.color;
            context.fillStyle = data.color;
            context.lineWidth = data.lineWidth || 2;
            context.lineCap = 'round';
            context.lineJoin = 'round';

            switch(data.type) {
                case 'path':
                    if (!data.points || data.points.length < 1) break;
                    const pathCenter = getObjectCenter({type:'path', points: data.points});
                    context.translate(-pathCenter.x, -pathCenter.y);
                    context.beginPath();
                    if (data.points.length < 3) {
                        context.moveTo(data.points[0].x, data.points[0].y);
                        for (let i = 1; i < data.points.length; i++) context.lineTo(data.points[i].x, data.points[i].y);
                    } else {
                        context.moveTo(data.points[0].x, data.points[0].y);
                        for (var i = 1; i < data.points.length - 2; i++) {
                            var c = (data.points[i].x + data.points[i + 1].x) / 2;
                            var d = (data.points[i].y + data.points[i + 1].y) / 2;
                            context.quadraticCurveTo(data.points[i].x, data.points[i].y, c, d);
                        }
                        context.quadraticCurveTo(data.points[i].x, data.points[i].y, data.points[i + 1].x, data.points[i + 1].y);
                    }
                    context.stroke();
                    break;
                case 'line':
                    if (!data.points || data.points.length < 2) break;
                    const halfWidth = (data.points[1].x - data.points[0].x) / 2;
                    const halfHeight = (data.points[1].y - data.points[0].y) / 2;
                    context.beginPath();
                    context.moveTo(-halfWidth, -halfHeight);
                    context.lineTo(halfWidth, halfHeight);
                    context.stroke();
                    break;
                case 'rectangle':
                    context.strokeRect(-data.width / 2, -data.height / 2, data.width, data.height);
                    break;
                case 'circle':
                    context.beginPath();
                    context.arc(0, 0, data.radius, 0, 2 * Math.PI);
                    context.stroke();
                    break;
                case 'triangle':
                    if (!data.points || data.points.length < 3) break;
                    const triCenter = getObjectCenter({ type: 'triangle', points: data.points });
                    const p1 = { x: data.points[0].x - triCenter.x, y: data.points[0].y - triCenter.y };
                    const p2 = { x: data.points[1].x - triCenter.x, y: data.points[1].y - triCenter.y };
                    const p3 = { x: data.points[2].x - triCenter.x, y: data.points[2].y - triCenter.y };
                    context.beginPath();
                    context.moveTo(p1.x, p1.y);
                    context.lineTo(p2.x, p2.y);
                    context.lineTo(p3.x, p3.y);
                    context.closePath();
                    context.stroke();
                    break;
                case 'text':
                    context.font = `${data.fontSize}px Inter`;
                    context.textBaseline = 'middle';
                    context.textAlign = 'center';
                    context.fillText(data.text, 0, 0);
                    break;
            }
            context.restore();
        }
        
        function drawSelectionBox(obj) {
            const handles = getTransformHandles(obj);
            if (!handles) return;
            overlayCtx.save();
            
            overlayCtx.strokeStyle = '#4f46e5';
            overlayCtx.lineWidth = 1;
            overlayCtx.setLineDash([4, 4]);
            overlayCtx.beginPath();
            overlayCtx.moveTo(handles.tl.x, handles.tl.y);
            overlayCtx.lineTo(handles.tr.x, handles.tr.y);
            overlayCtx.lineTo(handles.br.x, handles.br.y);
            overlayCtx.lineTo(handles.bl.x, handles.bl.y);
            overlayCtx.closePath();
            overlayCtx.stroke();
            overlayCtx.setLineDash([]);
            
            overlayCtx.beginPath();
            overlayCtx.moveTo(handles.tm.x, handles.tm.y);
            overlayCtx.lineTo(handles.rot.x, handles.rot.y);
            overlayCtx.stroke();
            overlayCtx.fillStyle = '#4f46e5';
            overlayCtx.beginPath();
            overlayCtx.arc(handles.rot.x, handles.rot.y, 6, 0, 2*Math.PI);
            overlayCtx.fill();

            Object.values(handles).forEach(handle => {
                if(handle.type === 'resize'){
                    overlayCtx.fillStyle = 'white';
                    overlayCtx.strokeStyle = '#4f46e5';
                    overlayCtx.lineWidth = 2;
                    overlayCtx.fillRect(handle.x - 5, handle.y - 5, 10, 10);
                    overlayCtx.strokeRect(handle.x - 5, handle.y - 5, 10, 10);
                }
            });
            overlayCtx.restore();
        }

        // --- Geometry & Transformation Helpers ---
        function getObjectBounds(obj) { let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; if(!obj) return null; switch (obj.type) { case 'rectangle': return { x: obj.x, y: obj.y, width: obj.width, height: obj.height }; case 'circle': return { x: obj.x - obj.radius, y: obj.y - obj.radius, width: obj.radius * 2, height: obj.radius * 2 }; case 'text': ctx.font = `${obj.fontSize}px Inter`; const metrics = ctx.measureText(obj.text); const height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent; return { x: obj.x - metrics.width / 2, y: obj.y - height / 2, width: metrics.width, height: height || obj.fontSize }; case 'path': case 'line': case 'triangle': if (!obj.points || obj.points.length === 0) return {x:0,y:0,width:0,height:0}; obj.points.forEach(p => { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); }); return { x: minX, y: minY, width: maxX - minX, height: maxY - minY }; default: return null; } }
        function getObjectCenter(obj) { const bounds = getObjectBounds(obj); if (!bounds) return {x: 0, y: 0}; return { x: bounds.x + bounds.width / 2, y: bounds.y + bounds.height / 2 }; }
        function rotatePoint(point, center, angle) { const dx = point.x - center.x; const dy = point.y - center.y; const sin = Math.sin(angle); const cos = Math.cos(angle); return { x: center.x + dx * cos - dy * sin, y: center.y + dx * sin + dy * cos }; }
        function getTransformHandles(obj) {
            const bounds = getObjectBounds(obj);
            if (!bounds) return null;
            const center = getObjectCenter(obj);
            const w = bounds.width;
            const h = bounds.height;
            const angle = obj.rotation || 0;

            const corners = {
                tl: {x: center.x - w/2, y: center.y - h/2},
                tr: {x: center.x + w/2, y: center.y - h/2},
                bl: {x: center.x - w/2, y: center.y + h/2},
                br: {x: center.x + w/2, y: center.y + h/2}
            };
            
            const rotationHandleOffset = 30;
            const topMid = { x: center.x, y: center.y - h/2 };
            const rotationPoint = { x: topMid.x, y: topMid.y - rotationHandleOffset };

            const rotateCursorURL = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"/><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/></svg>`;

            return {
                tl:  {...rotatePoint(corners.tl, center, angle), type: 'resize', cursor: 'nwse-resize'},
                tr:  {...rotatePoint(corners.tr, center, angle), type: 'resize', cursor: 'nesw-resize'},
                bl:  {...rotatePoint(corners.bl, center, angle), type: 'resize', cursor: 'nesw-resize'},
                br:  {...rotatePoint(corners.br, center, angle), type: 'resize', cursor: 'nwse-resize'},
                tm: rotatePoint(topMid, center, angle), 
                rot: {...rotatePoint(rotationPoint, center, angle), type: 'rotate', cursor: `url('${rotateCursorURL}') 12 12, auto`}
            };
        }
        
        // --- UI & Event Functions ---
        async function sendChatMessage(text, type = 'text', url = null) {
            if (!userId) {
                console.error("Chat message not sent: User not authenticated.");
                return;
            }
            const content = text ? text.trim() : '';
            if (content || url) {
                try {
                    const messageData = { author: userId, timestamp: serverTimestamp(), type: type };
                    if (content) messageData.text = content;
                    if (url) messageData.url = url;
                    await addDoc(collection(db, `artifacts/${whiteboardId}/public/data/chat`), messageData);
                    chatInput.value = '';
                } catch (error) { console.error("Error sending chat message:", error); }
            }
        }
        async function sendEffectToFirestore(effectType) { if(!userId) return; await addDoc(collection(db, `artifacts/${whiteboardId}/public/data/events`), { type: effectType, author: userId, timestamp: new Date() }); triggerEffect(effectType); }
        function triggerEffect(type) { const container = document.getElementById('whiteboard-wrapper'); if (type === 'random-flash') { const flash = document.createElement('div'); flash.id = 'flash-overlay'; const randomColor = `rgba(${Math.floor(Math.random() * 156) + 100}, ${Math.floor(Math.random() * 156) + 100}, ${Math.floor(Math.random() * 156) + 100}, 0.7)`; flash.style.backgroundColor = randomColor; document.body.appendChild(flash); setTimeout(() => flash.remove(), 800); } else if (['hearts', 'rain', 'pickles'].includes(type)) { let emoji = '‚ù§Ô∏è'; if (type === 'rain') emoji = 'üíß'; if (type === 'pickles') emoji = 'ü•í'; for (let i = 0; i < 25; i++) { const particle = document.createElement('div'); particle.className = 'effect-particle'; particle.textContent = emoji; particle.style.left = `${Math.random() * 100}%`; particle.style.animationDelay = `${Math.random() * 2}s`; container.appendChild(particle); setTimeout(() => particle.remove(), 5000); } } }
        async function clearAllDrawings() { await setDoc(doc(db, `artifacts/${whiteboardId}/public/data/state/main`), { epoch: Date.now() }, {merge: true}); }
        async function clearAllChat() { const batch = writeBatch(db); localChatHistory.forEach(msg => { const docRef = doc(db, `artifacts/${whiteboardId}/public/data/chat`, msg.id); batch.delete(docRef); }); await batch.commit(); }
        function saveChatHistory() { let chatText = `Chat History for Whiteboard: ${whiteboardTitleEl.textContent}\nSaved on: ${new Date().toLocaleString()}\n\n`; localChatHistory.forEach(msg => { const time = msg.timestamp ? new Date(msg.timestamp.seconds * 1000).toLocaleTimeString() : '...'; const author = getUserDisplayName(msg.author); let content = msg.text || ''; if (msg.type === 'image' || msg.type === 'gif') { content += ` [Media: ${msg.url}]`; } chatText += `[${time}] ${author}: ${content.trim()}\n`; }); const blob = new Blob([chatText], { type: 'text/plain' }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = 'chat-history.txt'; link.click(); }
        function setDailyContent() { const today = new Date(); const dayOfYear = Math.floor((today - new Date(today.getFullYear(), 0, 0)) / (1000 * 60 * 60 * 24)); const titleIndex = dayOfYear % dailyTitles.length; const quoteIndex = dayOfYear % dailyQuotes.length; whiteboardTitleEl.textContent = dailyTitles[titleIndex]; whiteboardDescriptionEl.textContent = dailyQuotes[quoteIndex]; }
        
        // --- Mouse and Event Handlers ---
        function snapToGrid(pos) { if (!state.isSnapEnabled) return pos; return { x: Math.round(pos.x / state.gridSize) * state.gridSize, y: Math.round(pos.y / state.gridSize) * state.gridSize, }; }
        function getMousePos(evt) { const rect = eventCaptureLayer.getBoundingClientRect(); return { x: evt.clientX - rect.left, y: evt.clientY - rect.top }; }
        
        function handleMouseDown(e) {
            if (state.isTexting) return;
            if (!userId) {
                console.warn("Cannot draw: User not authenticated.");
                return;
            }
            const pos = getMousePos(e);
            state.startPos = pos;
            state.action = 'none';

            if (state.currentTool === 'select') {
                const selectedObject = state.allDrawings.get(state.selectedObjectId);
                if (selectedObject) {
                    const handles = getTransformHandles(selectedObject);
                    for (const key in handles) {
                        const handle = handles[key];
                        if (handle.type && Math.hypot(pos.x - handle.x, pos.y - handle.y) < 10) { 
                            state.action = handle.type; 
                            state.transformHandle = key;
                            state.originalObjectState = JSON.parse(JSON.stringify(selectedObject));
                            state.originalObjectState.center = getObjectCenter(selectedObject);
                            return;
                        }
                    }
                }
                
                const clickedObjectId = findClickedObject(pos.x, pos.y);
                if (clickedObjectId) {
                    state.selectedObjectId = clickedObjectId;
                    state.action = 'moving';
                    const obj = state.allDrawings.get(clickedObjectId);
                    const center = getObjectCenter(obj);
                    state.dragOffset = { x: pos.x - center.x, y: pos.y - center.y };
                    state.originalObjectState = JSON.parse(JSON.stringify(obj));

                } else {
                    state.selectedObjectId = null;
                }
                drawOverlay();
            } else if (state.currentTool === 'text') {
                startTextEntry(snapToGrid(pos));
            } else {
                state.action = 'drawing';
                state.tempDrawing = createPreviewObject(snapToGrid(state.startPos), snapToGrid(pos));
            }
        }
        
        function handleMouseMove(e) {
            let pos = getMousePos(e);
            
            // Set cursor style based on context
            let cursor = 'default';
            if (state.action !== 'none') {
                if(state.action === 'moving') cursor = 'grabbing';
                const selObj = state.allDrawings.get(state.selectedObjectId);
                if (selObj) {
                   const handles = getTransformHandles(selObj);
                   if (handles[state.transformHandle] && state.action === 'rotating') cursor = handles.rot.cursor;
                   if (handles[state.transformHandle] && state.action === 'resizing') cursor = handles[state.transformHandle].cursor;
                }
            } else if (state.currentTool === 'select') {
                 const selectedObject = state.allDrawings.get(state.selectedObjectId);
                 if (selectedObject) {
                     const handles = getTransformHandles(selectedObject);
                     let onHandle = false;
                     for (const key in handles) {
                        const handle = handles[key];
                        if (handle.type && Math.hypot(pos.x - handle.x, pos.y - handle.y) < 10) {
                            cursor = handle.cursor;
                            onHandle = true;
                            break;
                        }
                     }
                     if(!onHandle && findClickedObject(pos.x, pos.y)) cursor = 'grab';
                 } else if(findClickedObject(pos.x, pos.y)) {
                     cursor = 'grab';
                 }
            } else if (state.currentTool !== 'select') {
                cursor = state.currentTool === 'text' ? 'text' : 'crosshair';
            }
            eventCaptureLayer.style.cursor = cursor;
            
            if (!state.startPos) return;

            if (state.action === 'drawing') {
                if (state.currentTool === 'pen') {
                    state.tempDrawing.points.push(pos); 
                } else {
                    state.tempDrawing = createPreviewObject(snapToGrid(state.startPos), snapToGrid(pos));
                }
                drawOverlay();
            } else if (state.action === 'moving' && state.selectedObjectId) {
                const selectedObject = state.allDrawings.get(state.selectedObjectId);
                const newCenter = { x: pos.x - state.dragOffset.x, y: pos.y - state.dragOffset.y };
                const snappedCenter = snapToGrid(newCenter);
                moveObjectTo(selectedObject, snappedCenter.x, snappedCenter.y);
                drawOverlay();
            } else if (state.action === 'rotating' && state.selectedObjectId) {
                const selectedObject = state.allDrawings.get(state.selectedObjectId);
                const center = state.originalObjectState.center;
                const originalAngle = Math.atan2(state.startPos.y - center.y, state.startPos.x - center.x);
                const newAngle = Math.atan2(pos.y - center.y, pos.x - center.x);
                selectedObject.rotation = (state.originalObjectState.rotation || 0) + (newAngle - originalAngle);
                drawOverlay();
            } else if (state.action === 'resizing' && state.selectedObjectId) {
                const selectedObject = state.allDrawings.get(state.selectedObjectId);
                const center = state.originalObjectState.center;
                
                const angle = -state.originalObjectState.rotation || 0;
                const localPos = rotatePoint(pos, center, angle);

                const origBounds = getObjectBounds(state.originalObjectState);
                let newWidth = Math.abs(localPos.x - center.x) * 2;
                let newHeight = Math.abs(localPos.y - center.y) * 2;
                
                if (selectedObject.type === 'rectangle') {
                    selectedObject.width = newWidth;
                    selectedObject.height = newHeight;
                    selectedObject.x = center.x - newWidth / 2;
                    selectedObject.y = center.y - newHeight / 2;
                } else if (selectedObject.type === 'circle') {
                    selectedObject.radius = Math.hypot(localPos.x - center.x, localPos.y - center.y);
                } else if (selectedObject.type === 'text') {
                    const localStartPos = rotatePoint(state.startPos, center, angle);
                    const origFontSize = state.originalObjectState.fontSize;
                    const origDist = Math.hypot(localStartPos.x - center.x, localStartPos.y - center.y);
                    const newDist = Math.hypot(localPos.x - center.x, localPos.y - center.y);
                    if(origDist > 0.1) {
                       const scale = newDist / origDist;
                       selectedObject.fontSize = Math.max(5, origFontSize * scale);
                    }
                }
                drawOverlay();
            }
        }

        async function handleMouseUp(e) {
            if (!state.startPos) return;
            const objToUpdate = state.allDrawings.get(state.selectedObjectId);

            if (state.action === 'drawing' && state.tempDrawing) {
                if (state.currentTool !== 'pen' || state.tempDrawing.points.length >= 2) {
                    const newDocRef = await addObjectToFirestore(state.tempDrawing);
                    if (newDocRef) { pushToUndoStack({type: 'add', payload: { id: newDocRef.id, data: state.tempDrawing }}); }
                }
            } else if (['moving', 'resizing', 'rotating'].includes(state.action) && objToUpdate) {
                const {id, ...data} = objToUpdate; 
                updateObjectInFirestore(id, data, state.originalObjectState);
            }
            state.action = 'none';
            state.startPos = null;
            state.tempDrawing = null;
            state.transformHandle = null;
            state.originalObjectState = null;
            redrawCanvas(); 
        }

        function createPreviewObject(start, end) { 
            const common = { color: state.currentColor, lineWidth: state.currentBrushSize, author: userId, epoch: state.currentEpoch, rotation: 0 }; 
            const x1 = start.x, y1 = start.y, x2 = end.x, y2 = end.y; 
            const width = Math.abs(x1 - x2); 
            const height = Math.abs(y1 - y2); 
            const cx = (x1+x2)/2, cy = (y1+y2)/2; 
            switch (state.currentTool) { 
                case 'pen': return { ...common, type: 'path', points: [start] }; 
                case 'line': return { ...common, type: 'line', points: [start, end] }; 
                case 'rectangle': return { ...common, type: 'rectangle', x: Math.min(x1, x2), y: Math.min(y1, y2), width, height }; 
                case 'circle': return { ...common, type: 'circle', x: cx, y: cy, radius: Math.hypot(width, height) / 2 }; 
                case 'triangle': return { ...common, type: 'triangle', points: [ {x: x1, y: y2}, {x: cx, y: y1}, {x: x2, y: y2} ] }; 
                default: return null; 
            } 
        }
        
        function findClickedObject(x, y) {
            for (let i = state.sortedDrawings.length - 1; i >= 0; i--) {
                const obj = state.sortedDrawings[i];
                const center = getObjectCenter(obj);
                const angle = -(obj.rotation || 0);
                
                const localClick = rotatePoint({x,y}, center, angle);
                
                const bounds = getObjectBounds(obj);
                if (!bounds) continue;

                const fuzz = (obj.lineWidth || 2) / 2 + 5; // Use half line width + buffer
                if (localClick.x >= bounds.x - fuzz && localClick.x <= bounds.x + bounds.width + fuzz &&
                    localClick.y >= bounds.y - fuzz && localClick.y <= bounds.y + bounds.height + fuzz) {
                    // More precise check for non-rectangular objects can be added here if needed
                    return obj.id;
                }
            }
            return null;
        }

        function moveObjectTo(obj, newCenterX, newCenterY) {
            const bounds = getObjectBounds(obj);
            if (!bounds) return;
            const oldCenterX = bounds.x + bounds.width / 2;
            const oldCenterY = bounds.y + bounds.height / 2;
            const dx = newCenterX - oldCenterX;
            const dy = newCenterY - oldCenterY;

            if (obj.points) {
                obj.points = obj.points.map(p => ({ x: p.x + dx, y: p.y + dy }));
            } else { 
                obj.x += dx;
                obj.y += dy;
            }
        }
        
        function startTextEntry(pos) {
            state.isTexting = true;
            textInputContainer.style.left = `${pos.x}px`;
            textInputContainer.style.top = `${pos.y}px`;
            textInputContainer.style.display = 'block';
            textInput.style.color = state.currentColor;
            textInput.style.fontSize = `${state.currentBrushSize * 5 + 12}px`;
            textInput.value = '';
            textInput.focus();

            const finish = async (shouldAddText) => {
                if (!state.isTexting) return;
                state.isTexting = false;
                
                document.removeEventListener('mousedown', handleClickOutside, true);

                if (shouldAddText) {
                    const text = textInput.value.trim();
                    if (text) {
                        const fontSize = state.currentBrushSize * 5 + 12;
                        const textData = { type: 'text', text, x: pos.x, y: pos.y, color: state.currentColor, fontSize: fontSize, author: userId, epoch: state.currentEpoch, rotation: 0 };
                        const newDocRef = await addObjectToFirestore(textData);
                        if (newDocRef) { pushToUndoStack({type: 'add', payload: { id: newDocRef.id, data: textData }}); }
                    }
                }
                textInput.value = '';
                textInputContainer.style.display = 'none';
            }
            
            const handleClickOutside = (event) => { if (!textInputContainer.contains(event.target)) { finish(true); } };
            textInput.onkeydown = (e) => { if (e.key === 'Enter') { e.preventDefault(); finish(true); } else if (e.key === 'Escape') { finish(false); } };
            setTimeout(() => { document.addEventListener('mousedown', handleClickOutside, true); }, 0);
        }

        // --- Firestore Actions ---
        async function addObjectToFirestore(objData) { if (!userId) { console.error("Cannot add object: User not authenticated."); return null; } try { const docRef = await addDoc(collection(db, `artifacts/${whiteboardId}/public/data/drawings`), { ...objData, timestamp: serverTimestamp() }); return docRef; } catch (error) { console.error("Error adding document: ", error); return null;} }
        async function updateObjectInFirestore(docId, updatedData, originalData) { if(originalData) { pushToUndoStack({ type: 'update', payload: { id: docId, before: originalData, after: {...originalData, ...updatedData} }}); } try { await updateDoc(doc(db, `artifacts/${whiteboardId}/public/data/drawings`, docId), { ...updatedData, timestamp: serverTimestamp() }); } catch (error) { console.error("Error updating document: ", error); } }
        async function deleteSelectedObject() { if (!state.selectedObjectId) return; const objectToDelete = state.allDrawings.get(state.selectedObjectId); if(objectToDelete) { pushToUndoStack({ type: 'delete', payload: objectToDelete }); } try { await deleteDoc(doc(db, `artifacts/${whiteboardId}/public/data/drawings`, state.selectedObjectId)); state.selectedObjectId = null; redrawCanvas(); } catch (error) { console.error("Error deleting document: ", error); } }
        async function bringToFront() { if (!state.selectedObjectId) return; await updateObjectInFirestore(state.selectedObjectId, {}, state.allDrawings.get(state.selectedObjectId)); }
        async function duplicateSelectedObject() { if (!state.selectedObjectId) return; const original = state.allDrawings.get(state.selectedObjectId); const { id, timestamp, ...cloneData } = original; const center = getObjectCenter(cloneData); moveObjectTo(cloneData, center.x + 10, center.y + 10); const newDocRef = await addObjectToFirestore(cloneData); if (newDocRef) { pushToUndoStack({type: 'add', payload: { id: newDocRef.id, data: cloneData }}); state.selectedObjectId = newDocRef.id; drawOverlay(); } }
        
        // --- Undo/Redo Logic ---
        function updateUndoRedoButtons() { undoBtn.disabled = state.undoStack.length === 0; redoBtn.disabled = state.redoStack.length === 0; }
        function pushToUndoStack(action) { state.undoStack.push(action); state.redoStack = []; updateUndoRedoButtons(); }
        async function handleUndo() { if (state.undoStack.length === 0) return; const action = state.undoStack.pop(); state.redoStack.push(action); state.selectedObjectId = null; switch (action.type) { case 'add': await deleteDoc(doc(db, `artifacts/${whiteboardId}/public/data/drawings`, action.payload.id)); break; case 'delete': const { id: delId, ...delData } = action.payload; await setDoc(doc(db, `artifacts/${whiteboardId}/public/data/drawings`, delId), delData); break; case 'update': const { id: updId, before: beforeData } = action.payload; const { id: ignoredId, ...updData } = beforeData; await updateDoc(doc(db, `artifacts/${whiteboardId}/public/data/drawings`, updId), updData); break; } updateUndoRedoButtons(); }
        async function handleRedo() { if (state.redoStack.length === 0) return; const action = state.redoStack.pop(); state.undoStack.push(action); state.selectedObjectId = null; switch (action.type) { case 'add': const { id: addId, data: addData } = action.payload; await setDoc(doc(db, `artifacts/${whiteboardId}/public/data/drawings`, addId), addData); break; case 'delete': await deleteDoc(doc(db, `artifacts/${whiteboardId}/public/data/drawings`, action.payload.id)); break; case 'update': const { id: updId, after: afterData } = action.payload; const { id: ignoredId, ...updData } = afterData; await updateDoc(doc(db, `artifacts/${whiteboardId}/public/data/drawings`, updId), updData); break; } updateUndoRedoButtons(); }

        // --- Modal Functions ---
        function showModal(modal) { modal.classList.add('visible'); }
        function hideModal(modal) { modal.classList.remove('visible'); }
        function resetGifModal() { gifSearchResults.innerHTML = ''; gifSearchInput.value = ''; }
        
        function showConfirmationModal(title, text, onConfirm) {
            confirmModalTitle.textContent = title;
            confirmModalText.textContent = text;
            confirmCallback = onConfirm;
            showModal(confirmModalOverlay);
        }

        async function searchTenorGifs() {
            const query = gifSearchInput.value.trim();
            if (!query) return;

            if(!tenorApiKey) {
                 gifSearchResults.innerHTML = `<p class="col-span-full text-center text-red-400">Tenor API key is not configured.</p>`;
                 return;
            }

            gifSearchExecuteBtn.disabled = true;
            gifSearchResults.innerHTML = `<div class="col-span-full flex justify-center items-center gap-2"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div><span>Searching...</span></div>`;

            const clientKey = "collaborative-whiteboard-app";
            const limit = 24;
            const apiUrl = `https://tenor.googleapis.com/v2/search?q=${encodeURIComponent(query)}&key=${tenorApiKey}&client_key=${clientKey}&limit=${limit}`;
            
            try {
                const response = await fetch(apiUrl);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Tenor API error! Status: ${response.status}. Details: ${errorText}`);
                }
                const result = await response.json();

                gifSearchResults.innerHTML = '';
                if (result.results && result.results.length > 0) {
                    result.results.forEach(gif => {
                        const previewUrl = gif.media_formats.tinygif.url;
                        const fullUrl = gif.media_formats.gif.url;
                        
                        const img = document.createElement('img');
                        img.src = previewUrl;
                        img.alt = gif.content_description;
                        img.dataset.fullUrl = fullUrl;
                        
                        img.addEventListener('click', () => {
                            sendChatMessage(null, 'gif', fullUrl);
                            hideModal(gifSearchModalOverlay);
                        });
                        gifSearchResults.appendChild(img);
                    });
                } else {
                    gifSearchResults.innerHTML = `<p class="col-span-full text-center text-gray-400">No GIFs found for "${query}".</p>`;
                }

            } catch (error) {
                console.error("Error searching for GIFs:", error);
                gifSearchResults.innerHTML = `<p class="col-span-full text-center text-red-400">Failed to load GIFs. Please check the API key and console for errors.</p>`;
            } finally {
                gifSearchExecuteBtn.disabled = false;
            }
        }


        // --- App Initialization ---
        window.addEventListener('load', () => {
            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            setLogLevel('debug');
            setDailyContent();

            onAuthStateChanged(auth, async (user) => { 
                if (user) { 
                    userId = user.uid; 
                    document.getElementById('userId').textContent = getUserDisplayName(userId); 

                    // --- Enable Chat Controls ---
                    chatInput.disabled = false;
                    chatSendBtn.disabled = false;
                    gifSearchBtn.disabled = false;
                    chatInput.placeholder = 'Say something... (Shift+Enter for new line)';

                    await getOrGenerateAvatar(userId); 
                    setupStateListener(); 
                    setupEventsListener(); 
                    setupChatListener(); 
                } else { 
                    console.log("No user signed in. Attempting anonymous sign-in.");
                    try { 
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            await signInWithCustomToken(auth, __initial_auth_token);
                        } else {
                            await signInAnonymously(auth); 
                        }
                    } catch (error) { 
                        console.error("Sign-in error", error); 
                        document.getElementById('userId').textContent = 'Auth Error';
                        chatInput.placeholder = 'Chat disabled due to authentication error.';
                    } 
                } 
            });
            
            // --- Event Listeners Setup ---
            const allToolButtons = document.querySelectorAll('#tool-selector .tool-btn, #tool-selector .dropdown-content .tool-btn');
            allToolButtons.forEach(button => { button.addEventListener('click', (e) => { const clickedButton = e.currentTarget; const tool = clickedButton.dataset.tool; if (!tool) return; state.currentTool = tool; eventCaptureLayer.style.cursor = tool === 'select' ? 'default' : (tool === 'text' ? 'text' : 'crosshair'); document.querySelectorAll('#tool-selector .tool-btn').forEach(b => b.classList.remove('selected')); const parentDropdownBtn = clickedButton.closest('.dropdown')?.querySelector('.tool-btn'); if (parentDropdownBtn) { parentDropdownBtn.classList.add('selected'); } else { clickedButton.classList.add('selected'); } state.selectedObjectId = null; drawOverlay(); }); });
            document.querySelectorAll('#brush-size-selector .size-btn').forEach(btn => { btn.addEventListener('click', (e) => { document.querySelectorAll('#brush-size-selector .size-btn').forEach(b => b.classList.remove('selected')); const clickedBtn = e.currentTarget; clickedBtn.classList.add('selected'); state.currentBrushSize = parseInt(clickedBtn.dataset.size, 10); }); });
            const colors = ['#FFFFFF', '#EF4444', '#F97316', '#EAB308', '#22C55E', '#3B82F6', '#8B5CF6', '#EC4899'];
            const colorPalette = document.getElementById('color-palette');
            colors.forEach((color, index) => { const swatch = document.createElement('button'); swatch.className = 'color-swatch w-8 h-8 rounded-full border-2 border-gray-500 hover:scale-110'; swatch.style.backgroundColor = color; if(index === 0) swatch.classList.add('parent-selected'); swatch.addEventListener('click', () => { state.currentColor = color; document.querySelectorAll('#color-palette .color-swatch').forEach(s => s.classList.remove('parent-selected')); swatch.classList.add('parent-selected'); }); colorPalette.appendChild(swatch); });
            
            chatSendBtn.addEventListener('click', () => sendChatMessage(chatInput.value));
            chatInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendChatMessage(chatInput.value); }});
            
            clearCanvasBtn.addEventListener('click', () => showConfirmationModal("Clear Canvas?", "This will clear the canvas for everyone and cannot be undone.", clearAllDrawings));
            clearChatBtn.addEventListener('click', () => showConfirmationModal("Clear Chat?", "This will delete the chat history for everyone and cannot be undone.", clearAllChat));
            saveChatBtn.addEventListener('click', saveChatHistory);
            
            helpModalOverlay.addEventListener('click', (e) => { if(e.target === helpModalOverlay) hideModal(helpModalOverlay); });
            document.getElementById('close-help-btn').addEventListener('click', () => hideModal(helpModalOverlay));
            document.getElementById('help-btn').addEventListener('click', () => showModal(helpModalOverlay));

            // GIF Search Modal Listeners
            gifSearchBtn.addEventListener('click', () => { resetGifModal(); showModal(gifSearchModalOverlay); });
            closeGifSearchBtn.addEventListener('click', () => hideModal(gifSearchModalOverlay));
            gifSearchModalOverlay.addEventListener('click', (e) => { if(e.target === gifSearchModalOverlay) hideModal(gifSearchModalOverlay); });
            gifSearchExecuteBtn.addEventListener('click', searchTenorGifs);
            gifSearchInput.addEventListener('keydown', (e) => { if(e.key === 'Enter') searchTenorGifs(); });

            // Confirmation Modal Listeners
            confirmModalConfirmBtn.addEventListener('click', () => { if (typeof confirmCallback === 'function') { confirmCallback(); } hideModal(confirmModalOverlay); confirmCallback = null; });
            confirmModalCancelBtn.addEventListener('click', () => { hideModal(confirmModalOverlay); confirmCallback = null; });
            confirmModalOverlay.addEventListener('click', (e) => { if (e.target === confirmModalOverlay) { hideModal(confirmModalOverlay); confirmCallback = null;} });

            // Image Viewer Listeners
            imageViewerOverlay.addEventListener('click', () => hideModal(imageViewerOverlay));
            chatMessagesContainer.addEventListener('click', (e) => { if(e.target.classList.contains('chat-image')) { document.getElementById('image-viewer-content').src = e.target.dataset.fullSrc; showModal(imageViewerOverlay); } });

            // Whiteboard Listeners
            deleteBtn.addEventListener('click', deleteSelectedObject); frontBtn.addEventListener('click', bringToFront); duplicateBtn.addEventListener('click', duplicateSelectedObject);
            undoBtn.addEventListener('click', handleUndo);
            redoBtn.addEventListener('click', handleRedo);
            toggleGridBtn.addEventListener('click', () => { state.isGridVisible = !state.isGridVisible; toggleGridBtn.classList.toggle('selected', state.isGridVisible); redrawCanvas(); });
            toggleSnapBtn.addEventListener('click', () => { state.isSnapEnabled = !state.isSnapEnabled; toggleSnapBtn.classList.toggle('selected', state.isSnapEnabled); });
            document.querySelectorAll('#effects-dropdown .tool-btn').forEach(btn => { btn.addEventListener('click', (e) => { sendEffectToFirestore(e.currentTarget.dataset.effect); }); });
            document.getElementById('save-btn').addEventListener('click', () => { const link = document.createElement('a'); link.download = `${whiteboardTitleEl.textContent.trim()}-whiteboard.png`; link.href = canvas.toDataURL("image/png"); link.click(); });
            eventCaptureLayer.addEventListener('mousedown', handleMouseDown); 
            window.addEventListener('mousemove', handleMouseMove); 
            window.addEventListener('mouseup', handleMouseUp); 
            window.addEventListener('resize', redrawCanvas, { passive: true }); window.addEventListener('keydown', (e) => { if(e.key === 'Shift') state.isShiftDown = true; }); window.addEventListener('keyup', (e) => { if(e.key === 'Shift') state.isShiftDown = false; });
            redrawCanvas();
        });
    </script>
</body>
</html>
