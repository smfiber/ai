<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-900">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Whiteboard & Chat</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts & Font Awesome -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Base styles */
        body { font-family: 'Inter', sans-serif; }
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }

        /* Main Layout */
        #main-layout { display: flex; height: 100vh; width: 100vw; }
        #chat-container { width: 350px; flex-shrink: 0; background-color: #1f2937; display: flex; flex-direction: column; padding: 1rem; border-right: 2px solid #374151; }
        #whiteboard-wrapper { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }
        
        /* Chat Box Styles */
        #chat-header { font-size: 1.5rem; font-weight: bold; color: white; margin-bottom: 1rem; text-align: center; border-bottom: 1px solid #4b5563; padding-bottom: 0.5rem;}
        #chat-messages { flex-grow: 1; overflow-y: auto; font-family: Arial, sans-serif; font-size: 16px; line-height: 1.15; color: white;}
        .chat-message { margin-bottom: 1rem; display: flex; align-items: flex-start; }
        .chat-avatar { width: 40px; height: 40px; border-radius: 50%; margin-right: 10px; background-color: #4b5563; object-fit: cover;}
        .chat-content { display: flex; flex-direction: column; }
        .chat-author { font-weight: bold; color: #a5b4fc; font-size: 0.8rem; margin-bottom: 2px; }
        .chat-text { word-wrap: break-word; white-space: pre-wrap; }
        #chat-input-area { display: flex; margin-top: 1rem; }
        #chat-input { flex-grow: 1; background: #374151; border: 1px solid #4b5563; color: white; padding: 0.5rem; border-radius: 0.5rem 0 0 0.5rem; outline: none; }
        #chat-send-btn { background: #4f46e5; color: white; padding: 0 1rem; border-radius: 0 0.5rem 0.5rem 0; border: none; cursor: pointer; }
        #chat-send-btn:hover { background: #4338ca; }
        
        /* Whiteboard Styles */
        #app-container { width: 100%; height: 100%; display: flex; flex-direction: column; background-color: #111827; padding: 1rem; }
        #whiteboard, #overlay-canvas, #event-capture-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #whiteboard { z-index: 1; }
        #overlay-canvas { z-index: 2; pointer-events: none; }
        #event-capture-layer { z-index: 3; }
        .tool-btn, .color-swatch, .size-btn { transition: all 0.1s ease-in-out; }
        .tool-btn.selected, .size-btn.selected { background-color: #4f46e5; color: white; transform: scale(1.1); }
        .color-swatch.parent-selected { box-shadow: 0 0 0 2px white, 0 0 0 4px var(--tw-color-ring); }
        .shade-swatch.selected { box-shadow: 0 0 0 2px white, 0 0 0 4px #4f46e5; transform: scale(1.1); }
        #text-input-container { position: absolute; display: none; z-index: 20; }
        #text-input { background: #1f2937; border: 1px dashed #6b7280; color: white; outline: none; padding: 4px; border-radius: 4px; }
        #delete-btn:disabled, #front-btn:disabled, #duplicate-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        [contenteditable="true"]:hover { outline: 1px dashed #4f46e5; cursor: text; }
        [contenteditable="true"]:focus { outline: 2px solid #4f46e5; }
        
        /* Dropdown menus */
        .dropdown { position: relative; }
        .dropdown-content { visibility: hidden; opacity: 0; transform: translateY(-10px); transition: all 0.2s ease-out; position: absolute; top: 115%; left: 50%; transform: translateX(-50%) translateY(0px); z-index: 50; }
        .dropdown:hover .dropdown-content { visibility: visible; opacity: 1; transform: translateX(-50%) translateY(0); }
        .dropdown-content .tool-btn:hover { background-color: #4b5563; transform: scale(1.1); }

        /* Effects */
        #flash-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 0, 0.7); z-index: 9998; pointer-events: none; opacity: 0; animation: flash-animation 0.8s ease-out forwards; }
        @keyframes flash-animation { 0% { opacity: 0; } 25% { opacity: 1; } 50% { opacity: 0; } 75% { opacity: 1; } 100% { opacity: 0; } }
        .effect-particle { position: absolute; pointer-events: none; z-index: 9999; animation: float-up 5s linear forwards; font-size: 2rem; }
        @keyframes float-up { from { transform: translateY(0); opacity: 1; } to { transform: translateY(-100vh); opacity: 0; } }

        /* Help Modal */
        #help-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; display: flex; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        #help-modal-overlay.visible { opacity: 1; pointer-events: auto; }
        #help-modal { background-color: #1f2937; color: white; padding: 2rem; border-radius: 1rem; width: 90%; max-width: 600px; max-height: 80vh; overflow-y: auto; }
        #help-modal h2 { font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem; border-bottom: 1px solid #4b5563; padding-bottom: 0.5rem; }
        #help-modal h3 { font-size: 1.2rem; font-weight: bold; margin-top: 1.5rem; margin-bottom: 0.5rem; color: #a5b4fc; }
        #help-modal p, #help-modal li { color: #d1d5db; }
        #help-modal ul { list-style-type: disc; padding-left: 1.5rem; }
        #help-modal code { background: #374151; padding: 2px 6px; border-radius: 4px; font-family: monospace; }
    </style>
</head>
<body class="bg-gray-900 text-white antialiased">
    <!-- NOTE TO DEVELOPER: Always update the version number and the help modal content when making changes. -->
    <div id="main-layout">
        <!-- Chat Column -->
        <div id="chat-container">
            <h2 id="chat-header">Live Chat</h2>
            <div id="chat-messages"></div>
            <div id="chat-input-area">
                <input type="text" id="chat-input" placeholder="Say something...">
                <button id="chat-send-btn"><i class="fa-solid fa-paper-plane"></i></button>
            </div>
        </div>

        <!-- Whiteboard Column -->
        <div id="whiteboard-wrapper">
            <div id="app-container">
                <!-- Header -->
                <header class="flex flex-col md:flex-row justify-between items-start mb-4 pb-4 border-b border-gray-700">
                    <div>
                        <h1 id="whiteboard-title" contenteditable="true" class="text-2xl font-bold text-white rounded px-1">Collaborative Whiteboard</h1>
                        <p id="whiteboard-description" contenteditable="true" class="text-sm text-gray-400 rounded px-1">Now with full-screen mode and live chat!</p>
                    </div>
                     <div class="flex flex-col items-end mt-2 md:mt-0 text-xs text-gray-500 space-y-2">
                        <div>User ID: <span id="userId" class="font-mono bg-gray-700 px-2 py-1 rounded">Loading...</span></div>
                        <div>Version: <span id="version-number" class="font-mono bg-gray-700 px-2 py-1 rounded">1.10</span></div>
                         <button id="help-btn" class="p-2 text-blue-400 hover:text-blue-500" title="Help"><i class="fa-solid fa-circle-question"></i></button>
                    </div>
                </header>
                <!-- Toolbar -->
                <div id="toolbar" class="flex flex-wrap items-center justify-center gap-x-4 gap-y-2 mb-4">
                     <div id="tool-selector" class="flex items-center gap-2 bg-gray-700 p-1 rounded-lg">
                        <button data-tool="select" class="tool-btn p-2" title="Select & Move"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 3l7 19 2.5-7.5L22 3z"/></svg></button>
                        <button data-tool="pen" class="tool-btn selected p-2" title="Pen"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg></button>
                        <div class="dropdown">
                             <button class="tool-btn p-2" title="Shapes"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path></svg></button>
                             <div class="dropdown-content flex flex-col items-center gap-1 p-2 rounded-md bg-gray-600 shadow-lg">
                                <button data-tool="line" class="tool-btn p-2" title="Line"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="19" x2="19" y2="5"></line></svg></button>
                                <button data-tool="rectangle" class="tool-btn p-2" title="Rectangle"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/></svg></button>
                                <button data-tool="circle" class="tool-btn p-2" title="Circle"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/></svg></button>
                                <button data-tool="triangle" class="tool-btn p-2" title="Triangle"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 20h18L12 4z"/></svg></button>
                                <button data-tool="arrow" class="tool-btn p-2" title="Arrow"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></button>
                                <button data-tool="star" class="tool-btn p-2" title="Star"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg></button>
                                <button data-tool="speechBubble" class="tool-btn p-2" title="Speech Bubble"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg></button>
                                <button data-tool="heart" class="tool-btn p-2" title="Heart"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></button>
                            </div>
                        </div>
                        <button data-tool="text" class="tool-btn p-2" title="Text"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg></button>
                    </div>
                     <div class="flex items-center gap-2 bg-gray-700 p-1 rounded-lg">
                        <button id="duplicate-btn" class="p-2 text-green-400 hover:text-green-500" title="Duplicate Selected" disabled><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button>
                        <button id="front-btn" class="p-2 text-blue-400 hover:text-blue-500" title="Bring to Front" disabled><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg></button>
                        <button id="delete-btn" class="p-2 text-red-400 hover:text-red-500" title="Delete Selected" disabled><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg></button>
                    </div>
                    <div id="brush-size-selector" class="flex items-center gap-2 bg-gray-700 p-1 rounded-lg">
                         <button data-size="2" class="size-btn selected p-2" title="Small"><div class="w-1.5 h-1.5 bg-white rounded-full"></div></button>
                         <button data-size="5" class="size-btn p-2" title="Medium"><div class="w-2.5 h-2.5 bg-white rounded-full"></div></button>
                         <button data-size="10" class="size-btn p-2" title="Large"><div class="w-4 h-4 bg-white rounded-full"></div></button>
                    </div>
                    <div id="color-palette" class="flex items-end gap-2"></div>
                    <div class="flex items-center gap-2">
                        <div class="dropdown">
                            <button class="p-2 bg-purple-600 hover:bg-purple-700 rounded-lg text-white" title="Screen Effects"><i class="fa-solid fa-wand-magic-sparkles"></i></button>
                            <div id="effects-dropdown" class="dropdown-content flex flex-col items-center gap-1 p-2 rounded-md bg-gray-600 shadow-lg">
                                <button data-effect="flash" class="tool-btn p-2 w-full text-left">Flash Screen</button>
                                <button data-effect="hearts" class="tool-btn p-2 w-full text-left">Hearts Abound</button>
                                <button data-effect="wet" class="tool-btn p-2 w-full text-left">wet for you</button>
                                <button data-effect="hard" class="tool-btn p-2 w-full text-left">hard for you</button>
                            </div>
                        </div>
                        <button id="save-btn" class="p-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-white" title="Save as PNG"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg></button>
                        <button id="clear-button" disable-hosting-zip="true" class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg font-semibold">Clear</button>
                    </div>
                </div>
                <!-- Main Content Area -->
                <main id="main-content" class="flex-grow w-full h-full min-h-0 relative">
                    <canvas id="whiteboard" class="bg-gray-800 shadow-inner rounded-lg"></canvas>
                    <canvas id="overlay-canvas" class="rounded-lg"></canvas>
                    <div id="event-capture-layer" class="rounded-lg"></div>
                    <div id="text-input-container"><input type="text" id="text-input" /></div>
                </main>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="help-modal-overlay">
        <div id="help-modal">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">Whiteboard Help</h2>
                <button id="close-help-btn" class="text-2xl">&times;</button>
            </div>
            <h3>Core Concepts</h3>
            <p>This is a real-time collaborative whiteboard with integrated live chat. Your drawings, text, and messages will be seen by everyone instantly.</p>
            <h3>Live Chat</h3>
            <p>Use the panel on the left to chat with other users on the board. Each user is assigned a unique "meme" avatar.</p>
            <h3>Tools & Editing</h3>
            <p>The tools for drawing (Pen, Shapes, Text) and editing (Select, Move, Resize, Rotate, Duplicate, Delete) work the same as before.</p>
            <h3>NEW! Screen Effects</h3>
            <ul>
                <li>Click the magic wand icon to open the effects menu. These effects are visible to everyone on the board.</li>
                <li><code>Flash Screen</code>: A bright yellow flash to get attention.</li>
                <li><code>Hearts Abound</code>: Fills the screen with floating hearts.</li>
                <li><code>wet for you</code>: Shows falling teardrops.</li>
                <li><code>hard for you</code>: Unleashes a volley of eggplants.</li>
            </ul>
             <p class="mt-4 text-xs text-gray-400">Version: 1.10</p>
        </div>
    </div>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, onSnapshot, collection, addDoc, doc, setDoc, query, where, updateDoc, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- App Configuration ---
        const firebaseConfig = { apiKey: "AIzaSyAGO0CRIL44bj9-y5k2ARi2qGqZaZ7vLPc", authDomain: "whiteboard-00.firebaseapp.com", projectId: "whiteboard-00", storageBucket: "whiteboard-00.appspot.com", messagingSenderId: "34696279859", appId: "1:34696279859:web:a01addc7e57a8d06947046" };
        const whiteboardId = "google-sites-whiteboard-advanced";

        // --- DOM Elements ---
        const eventCaptureLayer = document.getElementById('event-capture-layer');
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        const overlayCanvas = document.getElementById('overlay-canvas');
        const overlayCtx = overlayCanvas.getContext('2d');
        const textInput = document.getElementById('text-input');
        const helpModalOverlay = document.getElementById('help-modal-overlay');
        const chatMessagesContainer = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');

        // --- Firebase & State Globals ---
        let db, userId;
        let unsubscribeFromDrawings, unsubscribeFromState, unsubscribeFromEvents, unsubscribeFromChat;
        const state = {
            action: 'none', startPos: null, currentTool: 'pen', currentColor: '#FFFFFF', currentBrushSize: 2, currentEpoch: 0,
            allDrawings: new Map(), sortedDrawings: [], selectedObjectId: null, dragOffset: { x: 0, y: 0 },
            tempDrawing: null, resizeHandle: null, isTexting: false, isShiftDown: false,
        };
        const userAvatars = {};
        const memeAvatarUrls = [
            'https://www.vhv.rs/dpng/d/4-47450_troll-face-png-transparent-png.png',
            'https://www.nicepng.com/png/detail/1-12932_doge-png-doge-meme-transparent-background.png',
            'https://toppng.com/uploads/preview/forever-alone-png-1155371561131t5md2znd.png',
            'https://www.pngmart.com/files/10/Yao-Ming-Meme-Face-PNG-Transparent-Image.png',
            'https://w7.pngwing.com/pngs/423/918/png-transparent-rage-comic-internet-meme-pepe-the-frog-feels-good-man-meme-comics-white-face.png'
        ];

        // --- Firebase Listeners ---
        function setupStateListener() { /* ... unchanged ... */ const stateDocPath = `whiteboards/${whiteboardId}/state/main`; if(unsubscribeFromState) unsubscribeFromState(); unsubscribeFromState = onSnapshot(doc(db, stateDocPath), (doc) => { const boardState = doc.data() || {}; const newEpoch = boardState.epoch || 1; if (boardState.title && document.getElementById('whiteboard-title').innerText !== boardState.title) { document.getElementById('whiteboard-title').innerText = boardState.title; } if (boardState.description && document.getElementById('whiteboard-description').innerText !== boardState.description) { document.getElementById('whiteboard-description').innerText = boardState.description; } if (newEpoch !== state.currentEpoch) { state.currentEpoch = newEpoch; setupDrawingsListener(); } }); }
        function setupDrawingsListener() { /* ... unchanged ... */ if (state.currentEpoch === 0) return; if (unsubscribeFromDrawings) unsubscribeFromDrawings(); state.allDrawings.clear(); state.selectedObjectId = null; redrawCanvas(); const drawingsCollectionPath = `whiteboards/${whiteboardId}/drawings`; const q = query(collection(db, drawingsCollectionPath), where("epoch", "==", state.currentEpoch)); unsubscribeFromDrawings = onSnapshot(q, (snapshot) => { snapshot.docChanges().forEach((change) => { const docData = change.doc.data(); if (docData.isDeleted) { state.allDrawings.delete(change.doc.id); } else { state.allDrawings.set(change.doc.id, { id: change.doc.id, ...docData }); } }); state.sortedDrawings = Array.from(state.allDrawings.values()).sort((a, b) => (a.timestamp?.seconds || 0) - (b.timestamp?.seconds || 0)); redrawCanvas(); }); }
        function setupEventsListener() { /* ... unchanged ... */ const eventsCollectionPath = `whiteboards/${whiteboardId}/events`; const q = query(collection(db, eventsCollectionPath), where("timestamp", ">", new Date(Date.now() - 10000))); if(unsubscribeFromEvents) unsubscribeFromEvents(); unsubscribeFromEvents = onSnapshot(q, (snapshot) => { snapshot.docChanges().forEach((change) => { if (change.type === "added") { const eventData = change.doc.data(); if (eventData.author !== userId) { triggerEffect(eventData.type); } } }); }); }
        function setupChatListener() {
            const chatCollectionPath = `whiteboards/${whiteboardId}/chat`;
            const q = query(collection(db, chatCollectionPath), orderBy("timestamp", "desc"), where("timestamp", ">", new Date(Date.now() - 3600 * 1000))); // last hour
            if(unsubscribeFromChat) unsubscribeFromChat();
            unsubscribeFromChat = onSnapshot(q, (snapshot) => {
                let messagesHtml = '';
                // Reverse snapshot docs because query is descending
                const docs = snapshot.docs.reverse();
                docs.forEach(doc => {
                    const msg = doc.data();
                    if (!userAvatars[msg.author]) {
                        const avatarIndex = Object.keys(userAvatars).length % memeAvatarUrls.length;
                        userAvatars[msg.author] = memeAvatarUrls[avatarIndex];
                    }
                    messagesHtml += `
                        <div class="chat-message">
                            <img src="${userAvatars[msg.author]}" class="chat-avatar" onerror="this.style.display='none'">
                            <div class="chat-content">
                                <div class="chat-author">${msg.author.substring(0, 8)}...</div>
                                <div class="chat-text">${msg.text}</div>
                            </div>
                        </div>
                    `;
                });
                chatMessagesContainer.innerHTML = messagesHtml;
                chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
            });
        }
        
        // --- Drawing & Rendering (mostly unchanged, just check resize) ---
        function redrawCanvas() { const dpr = window.devicePixelRatio || 1; const rect = document.getElementById('main-content').getBoundingClientRect(); [canvas, overlayCanvas, eventCaptureLayer].forEach(c => { if (c.width !== rect.width * dpr || c.height !== rect.height * dpr) { c.width = rect.width * dpr; c.height = rect.height * dpr; if (c.style) { c.style.width = `${rect.width}px`; c.style.height = `${rect.height}px`; } if(c.getContext) c.getContext('2d').scale(dpr, dpr); } }); ctx.clearRect(0, 0, canvas.width, canvas.height); state.sortedDrawings.forEach(data => drawObject(ctx, data)); drawOverlay(); }
        function drawOverlay() { overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height); if (state.tempDrawing) drawObject(overlayCtx, state.tempDrawing); const selectedObject = state.allDrawings.get(state.selectedObjectId); if (selectedObject) { drawSelectionBox(selectedObject); document.getElementById('delete-btn').disabled = false; document.getElementById('front-btn').disabled = false; document.getElementById('duplicate-btn').disabled = false; } else { document.getElementById('delete-btn').disabled = true; document.getElementById('front-btn').disabled = true; document.getElementById('duplicate-btn').disabled = true; } }
        function drawObject(context, data) { if (!data) return; context.save(); const bounds = getObjectBounds(data); if(!bounds) { context.restore(); return; } const centerX = bounds.x + bounds.width / 2; const centerY = bounds.y + bounds.height / 2; context.translate(centerX, centerY); context.rotate(data.angle || 0); context.translate(-centerX, -centerY); context.strokeStyle = data.color; context.fillStyle = data.color; context.lineWidth = data.lineWidth || 2; context.lineCap = 'round'; context.lineJoin = 'round'; switch(data.type) { case 'path': if (!data.points || data.points.length < 1) break; context.beginPath(); context.moveTo(data.points[0].x, data.points[0].y); for (let i = 1; i < data.points.length; i++) context.lineTo(data.points[i].x, data.points[i].y); context.stroke(); break; case 'line': if (!data.points || data.points.length < 2) break; context.beginPath(); context.moveTo(data.points[0].x, data.points[0].y); context.lineTo(data.points[1].x, data.points[1].y); context.stroke(); break; case 'rectangle': context.strokeRect(data.x, data.y, data.width, data.height); break; case 'circle': context.beginPath(); context.arc(data.cx, data.cy, data.radius, 0, 2 * Math.PI); context.stroke(); break; case 'triangle': case 'star': case 'speechBubble': case 'heart': if (!data.points || data.points.length < 3) break; context.beginPath(); context.moveTo(data.points[0].x, data.points[0].y); for(let i = 1; i < data.points.length; i++) { context.lineTo(data.points[i].x, data.points[i].y); } context.closePath(); context.stroke(); break; case 'text': context.font = `${data.fontSize}px Inter`; context.textBaseline = 'top'; context.fillText(data.text, data.x, data.y); break; case 'arrow': drawArrow(context, data); break; } context.restore(); }
        
        // --- Hit Detection & Bounding Box (Unchanged) ---
        function getResizeHandles(bounds) { return { tl: { x: bounds.x, y: bounds.y }, tr: { x: bounds.x + bounds.width, y: bounds.y }, bl: { x: bounds.x, y: bounds.y + bounds.height }, br: { x: bounds.x + bounds.width, y: bounds.y + bounds.height }, }; }
        function getRotationHandle(bounds) { return { x: bounds.x + bounds.width / 2, y: bounds.y - 30, radius: 8 }; }
        function drawSelectionBox(obj) { const bounds = getObjectBounds(obj); if (!bounds) return; overlayCtx.save(); const centerX = bounds.x + bounds.width / 2; const centerY = bounds.y + bounds.height / 2; overlayCtx.translate(centerX, centerY); overlayCtx.rotate(obj.angle || 0); overlayCtx.translate(-centerX, -centerY); overlayCtx.strokeStyle = '#007bff'; overlayCtx.lineWidth = 1; overlayCtx.setLineDash([5, 5]); overlayCtx.strokeRect(bounds.x - 5, bounds.y - 5, bounds.width + 10, bounds.height + 10); overlayCtx.setLineDash([]); const rotationHandle = getRotationHandle(bounds); overlayCtx.beginPath(); overlayCtx.arc(rotationHandle.x, rotationHandle.y, rotationHandle.radius, 0, 2 * Math.PI); overlayCtx.fillStyle = '#007bff'; overlayCtx.fill(); const resizeHandles = getResizeHandles(bounds); overlayCtx.fillStyle = '#fff'; overlayCtx.strokeStyle = '#007bff'; for (const handle in resizeHandles) { overlayCtx.beginPath(); overlayCtx.rect(resizeHandles[handle].x - 4, resizeHandles[handle].y - 4, 8, 8); overlayCtx.fill(); overlayCtx.stroke(); } overlayCtx.restore(); }
        function getEventPosition(e) { const rect = eventCaptureLayer.getBoundingClientRect(); const clientX = e.clientX ?? e.touches[0].clientX; const clientY = e.clientY ?? e.touches[0].clientY; return { x: clientX - rect.left, y: clientY - rect.top }; }
        function isPointInObject(pos, obj) { const transformedPos = getTransformedPoint(pos, obj); const bounds = getObjectBounds(obj); if (!bounds) return false; const tolerance = Math.max(5, (obj.lineWidth || 2) / 2); const isWithinBounds = transformedPos.x >= bounds.x - tolerance && transformedPos.x <= bounds.x + bounds.width + tolerance && transformedPos.y >= bounds.y - tolerance && transformedPos.y <= bounds.y + bounds.height + tolerance; if (!isWithinBounds) return false; switch (obj.type) { case 'circle': return isPointInCircle(transformedPos, {x: obj.cx, y: obj.cy, radius: obj.radius + tolerance}); case 'rectangle': return true; case 'path': case 'line': case 'arrow': case 'triangle': case 'star': case 'speechBubble': case 'heart': const points = obj.points; if (!points || points.length < 2) return false; if (['triangle', 'star', 'speechBubble', 'heart'].includes(obj.type)) { ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y); for(let i=1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y); ctx.closePath(); if (ctx.isPointInPath(transformedPos.x, transformedPos.y)) return true; } for (let i = 0; i < points.length - 1; i++) { if (isPointNearLine(transformedPos, points[i], points[i+1], tolerance)) return true; } if (['triangle', 'star', 'speechBubble', 'heart'].includes(obj.type)) { if (isPointNearLine(transformedPos, points[points.length - 1], points[0], tolerance)) return true; } if (obj.type === 'arrow') { const fromx = points[0].x, fromy = points[0].y, tox = points[1].x, toy = points[1].y; const headlen = 10; const angle = Math.atan2(toy-fromy, tox-fromx); const p1 = { x: tox - headlen * Math.cos(angle - Math.PI / 6), y: toy - headlen * Math.sin(angle - Math.PI / 6) }; const p2 = { x: tox - headlen * Math.cos(angle + Math.PI / 6), y: toy - headlen * Math.sin(angle + Math.PI / 6) }; if (isPointNearLine(transformedPos, {x: tox, y: toy}, p1, tolerance) || isPointNearLine(transformedPos, {x: tox, y: toy}, p2, tolerance)) return true; } return false; case 'text': return true; default: return false; } }
        function getObjectBounds(obj) { let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; if(!obj) return null; switch (obj.type) { case 'rectangle': return { x: obj.x, y: obj.y, width: obj.width, height: obj.height }; case 'circle': return { x: obj.cx - obj.radius, y: obj.cy - obj.radius, width: obj.radius * 2, height: obj.radius * 2 }; case 'text': ctx.font = `${obj.fontSize}px Inter`; return { x: obj.x, y: obj.y, width: ctx.measureText(obj.text).width, height: obj.fontSize }; case 'path': case 'line': case 'triangle': case 'arrow': case 'star': case 'speechBubble': case 'heart': if (!obj.points || obj.points.length === 0) return null; obj.points.forEach(p => { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); }); return { x: minX, y: minY, width: maxX - minX, height: maxY - minY }; default: return null; } }
        function getTransformedPoint(pos, obj) { const bounds = getObjectBounds(obj); if(!bounds) return pos; const centerX = bounds.x + bounds.width / 2; const centerY = bounds.y + bounds.height / 2; const angle = -(obj.angle || 0); const dx = pos.x - centerX; const dy = pos.y - centerY; return { x: dx * Math.cos(angle) - dy * Math.sin(angle) + centerX, y: dx * Math.sin(angle) + dy * Math.cos(angle) + centerY, }; }
        function isPointInCircle(point, circle) { const dx = point.x - circle.x; const dy = point.y - circle.y; return dx * dx + dy * dy <= circle.radius * circle.radius; }
        function isPointNearLine(p, a, b, tolerance) { const L2 = (b.x - a.x) ** 2 + (b.y - a.y) ** 2; if (L2 === 0) return Math.sqrt((p.x - a.x) ** 2 + (p.y - a.y) ** 2) < tolerance; let t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / L2; t = Math.max(0, Math.min(1, t)); const dx = p.x - (a.x + t * (b.x - a.x)); const dy = p.y - (a.y + t * (b.y - a.y)); return (dx ** 2 + dy ** 2) < (tolerance ** 2); }
        // The rest of the functions (handleMouseDown, handleMouseMove, handleMouseUp, createPreviewObject, etc.) are largely unchanged
        // They will work correctly within the new layout because getEventPosition uses getBoundingClientRect on the eventCaptureLayer.
        function handleMouseDown(event) { const pos = getEventPosition(event); if (state.isTexting) saveAndHideTextInput(); if (state.currentTool === 'text') { showTextInput(pos); return; } state.startPos = pos; state.action = 'none'; if (state.currentTool === 'select') { const selectedObject = state.allDrawings.get(state.selectedObjectId); if (selectedObject) { const bounds = getObjectBounds(selectedObject); const transformedPos = getTransformedPoint(pos, selectedObject); const rotationHandle = getRotationHandle(bounds); const resizeHandles = getResizeHandles(bounds); if (isPointInCircle(transformedPos, rotationHandle)) { state.action = 'rotating'; } else { for(const handleName in resizeHandles) { if(isPointInCircle(transformedPos, {...resizeHandles[handleName], radius: 8})) { state.action = 'resizing'; state.resizeHandle = handleName; break; } } } } if (state.action === 'none') { const clickedObject = getObjectAtPosition(pos); state.selectedObjectId = clickedObject ? clickedObject.id : null; if (state.selectedObjectId) { state.action = 'dragging'; const selected = state.allDrawings.get(state.selectedObjectId); const bounds = getObjectBounds(selected); state.dragOffset.x = pos.x - bounds.x; state.dragOffset.y = pos.y - bounds.y; } } } else { state.action = 'drawing'; state.selectedObjectId = null; } if(state.action !== 'none') state.drawing = true; drawOverlay(); }
        function handleMouseMove(event) { if (!state.drawing) return; const pos = getEventPosition(event); const selectedObject = state.allDrawings.get(state.selectedObjectId); if (state.action === 'dragging' && selectedObject) { const bounds = getObjectBounds(selectedObject); const newBoundsX = pos.x - state.dragOffset.x; const newBoundsY = pos.y - state.dragOffset.y; const dx = newBoundsX - bounds.x; const dy = newBoundsY - bounds.y; state.tempDrawing = JSON.parse(JSON.stringify(selectedObject)); if (['path', 'triangle', 'line', 'arrow', 'star', 'speechBubble', 'heart'].includes(state.tempDrawing.type)) { state.tempDrawing.points = selectedObject.points.map(p => ({ x: p.x + dx, y: p.y + dy })); } else if (state.tempDrawing.type === 'circle') { state.tempDrawing.cx += dx; state.tempDrawing.cy += dy; } else { state.tempDrawing.x += dx; state.tempDrawing.y += dy; } } else if (state.action === 'rotating' && selectedObject) { const bounds = getObjectBounds(selectedObject); const centerX = bounds.x + bounds.width / 2; const centerY = bounds.y + bounds.height / 2; const angle = Math.atan2(pos.y - centerY, pos.x - centerX) + Math.PI / 2; state.tempDrawing = { ...selectedObject, angle }; } else if (state.action === 'resizing' && selectedObject) { state.tempDrawing = resizeObject(selectedObject, pos, state.resizeHandle, state.isShiftDown); } else if (state.action === 'drawing') { state.tempDrawing = createPreviewObject(pos); } drawOverlay(); }
        function handleMouseUp() { if (!state.drawing) return; state.drawing = false; if (state.action === 'dragging' || state.action === 'rotating' || state.action === 'resizing') { if (state.tempDrawing) { updateObjectInFirestore(state.selectedObjectId, state.tempDrawing); state.allDrawings.set(state.selectedObjectId, state.tempDrawing); } } else if (state.action === 'drawing' && state.tempDrawing) { sendObjectToFirestore(state.tempDrawing); } state.action = 'none'; state.tempDrawing = null; state.resizeHandle = null; if (state.currentTool !== 'select') state.selectedObjectId = null; drawOverlay(); }
        function resizeObject(obj, pos, handle, keepAspectRatio = false) { const newObj = JSON.parse(JSON.stringify(obj)); const oldBounds = getObjectBounds(obj); if (!oldBounds) return newObj; const transformedPos = getTransformedPoint(pos, obj); const anchor = { x: handle.includes('l') ? oldBounds.x + oldBounds.width : oldBounds.x, y: handle.includes('t') ? oldBounds.y + oldBounds.height : oldBounds.y }; let newWidth = Math.abs(transformedPos.x - anchor.x); let newHeight = Math.abs(transformedPos.y - anchor.y); if(keepAspectRatio && oldBounds.width > 0 && oldBounds.height > 0) { const aspectRatio = oldBounds.width / oldBounds.height; if (newWidth / oldBounds.width > newHeight / oldBounds.height) { newHeight = newWidth / aspectRatio; } else { newWidth = newHeight * aspectRatio; } } newWidth = Math.max(10, newWidth); newHeight = Math.max(10, newHeight); const scaleX = newWidth / (oldBounds.width || 1); const scaleY = newHeight / (oldBounds.height || 1); newObj.x = handle.includes('l') ? anchor.x - newWidth : oldBounds.x; newObj.y = handle.includes('t') ? anchor.y - newHeight : oldBounds.y; if (newObj.type === 'rectangle') { newObj.width = newWidth; newObj.height = newHeight; } else if (newObj.type === 'circle') { newObj.radius = Math.max(5, (newWidth + newHeight) / 4); newObj.cx = newObj.x + newObj.radius; newObj.cy = newObj.y + newObj.radius; } else if (newObj.type === 'text') { newObj.fontSize = Math.max(8, newObj.fontSize * scaleY); } else if (['path', 'triangle', 'line', 'arrow', 'star', 'speechBubble', 'heart'].includes(obj.type)) { newObj.points = obj.points.map(p => ({ x: newObj.x + (p.x - oldBounds.x) * scaleX, y: newObj.y + (p.y - oldBounds.y) * scaleY, })); } return newObj; }
        function createPreviewObject(pos) { const common = { color: state.currentColor, lineWidth: state.currentBrushSize, angle: 0 }; let finalPos = pos; if (state.isShiftDown && ['line', 'arrow'].includes(state.currentTool)) { const dx = pos.x - state.startPos.x; const dy = pos.y - state.startPos.y; const angle = Math.atan2(dy, dx); const snappedAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4); const dist = Math.sqrt(dx * dx + dy * dy); finalPos = { x: state.startPos.x + dist * Math.cos(snappedAngle), y: state.startPos.y + dist * Math.sin(snappedAngle), }; } const width = Math.abs(state.startPos.x - finalPos.x); const height = Math.abs(state.startPos.y - finalPos.y); const left = Math.min(state.startPos.x, finalPos.x); const top = Math.min(state.startPos.y, finalPos.y); switch (state.currentTool) { case 'pen': if(!state.tempDrawing) { state.tempDrawing = { type: 'path', points: [state.startPos], ...common }; } state.tempDrawing.points.push(pos); return state.tempDrawing; case 'line': return { type: 'line', points: [state.startPos, finalPos], ...common }; case 'rectangle': return { type: 'rectangle', x: left, y: top, width, height, ...common }; case 'circle': const radius = Math.sqrt(Math.pow(finalPos.x - state.startPos.x, 2) + Math.pow(finalPos.y - state.startPos.y, 2)); return { type: 'circle', cx: state.startPos.x, cy: state.startPos.y, radius, ...common }; case 'triangle': return { type: 'triangle', points: [ { x: state.startPos.x, y: finalPos.y }, { x: finalPos.x, y: finalPos.y }, { x: (state.startPos.x + finalPos.x) / 2, y: state.startPos.y } ], ...common }; case 'arrow': return { type: 'arrow', points: [state.startPos, finalPos], ...common }; case 'star': return { type: 'star', points: getStarPoints(left, top, width, height), ...common }; case 'speechBubble': return { type: 'speechBubble', points: getSpeechBubblePoints(left, top, width, height), ...common }; case 'heart': return { type: 'heart', points: getHeartPoints(left, top, width, height), ...common }; default: return null; } }
        function getFontSize() { if (state.currentBrushSize <= 2) return 16; if (state.currentBrushSize <= 5) return 24; return 40; }
        function showTextInput(pos) { state.isTexting = true; document.getElementById('text-input-container').style.left = `${pos.x}px`; document.getElementById('text-input-container').style.top = `${pos.y}px`; document.getElementById('text-input-container').style.display = 'block'; textInput.style.color = state.currentColor; textInput.style.fontSize = `${getFontSize()}px`; textInput.value = ''; setTimeout(() => textInput.focus(), 0); }
        function saveAndHideTextInput() { if (!state.isTexting) return; const text = textInput.value.trim(); if (text) { const rect = document.getElementById('text-input-container').getBoundingClientRect(); const canvasRect = canvas.getBoundingClientRect(); sendObjectToFirestore({ type: 'text', text, x: rect.left - canvasRect.left, y: rect.top - canvasRect.top, color: state.currentColor, fontSize: getFontSize() }); } textInput.value = ''; document.getElementById('text-input-container').style.display = 'none'; state.isTexting = false; }
        
        // --- Firebase & UI Actions ---
        async function sendChatMessage() {
            const text = chatInput.value.trim();
            if (text && userId) {
                try {
                    await addDoc(collection(db, `whiteboards/${whiteboardId}/chat`), {
                        text: text,
                        author: userId,
                        timestamp: new Date()
                    });
                    chatInput.value = '';
                } catch (error) {
                    console.error("Error sending chat message:", error);
                }
            }
        }
        async function sendObjectToFirestore(object) { if (!userId || state.currentEpoch === 0) return; const newDocRef = await addDoc(collection(db, `whiteboards/${whiteboardId}/drawings`), { ...object, author: userId, timestamp: new Date(), epoch: state.currentEpoch, isDeleted: false, angle: 0 }); return newDocRef.id; }
        async function updateObjectInFirestore(id, updatedObject) { const docRef = doc(db, `whiteboards/${whiteboardId}/drawings`, id); const finalUpdate = { ...updatedObject }; delete finalUpdate.id; await updateDoc(docRef, finalUpdate); }
        async function sendEffectToFirestore(effectType) { if(!userId) return; await addDoc(collection(db, `whiteboards/${whiteboardId}/events`), { type: effectType, author: userId, timestamp: new Date() }); triggerEffect(effectType); }
        function triggerEffect(type) {
            const container = document.getElementById('app-container');
            if (type === 'flash') {
                const flash = document.createElement('div'); flash.id = 'flash-overlay'; document.body.appendChild(flash); setTimeout(() => flash.remove(), 800);
            } else if (type === 'hearts' || type === 'wet' || type === 'hard') {
                let emoji = '❤️';
                if (type === 'wet') emoji = ' ';
                if (type === 'hard') emoji = '🍆';
                for (let i = 0; i < 20; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'effect-particle';
                    particle.textContent = emoji;
                    particle.style.left = `${Math.random() * 100}%`;
                    particle.style.animationDelay = `${Math.random() * 2}s`;
                    container.appendChild(particle);
                    setTimeout(() => particle.remove(), 5000);
                }
            }
        }
        // Other actions (bringToFront, etc.) are unchanged
        async function bringToFront() { if (!state.selectedObjectId) return; await updateObjectInFirestore(state.selectedObjectId, { timestamp: new Date() }); }
        async function duplicateSelectedObject() { if (!state.selectedObjectId) return; const originalObject = state.allDrawings.get(state.selectedObjectId); if (!originalObject) return; const newObject = JSON.parse(JSON.stringify(originalObject)); delete newObject.id; const dx = 10, dy = 10; if (['path', 'triangle', 'line', 'arrow', 'star', 'speechBubble', 'heart'].includes(newObject.type)) { newObject.points = newObject.points.map(p => ({ x: p.x + dx, y: p.y + dy })); } else if (newObject.type === 'circle') { newObject.cx += dx; newObject.cy += dy; } else { newObject.x += dx; newObject.y += dy; } const newId = await sendObjectToFirestore(newObject); state.selectedObjectId = newId; }
        async function deleteSelectedObject() { if (!state.selectedObjectId) return; await updateObjectInFirestore(state.selectedObjectId, { isDeleted: true }); state.selectedObjectId = null; drawOverlay(); }
        async function clearAllDrawings() { await setDoc(doc(db, `whiteboards/${whiteboardId}/state/main`), { epoch: Date.now() }); }
        function handleHeaderEdit(e) { const el = e.target; const key = el.id === 'whiteboard-title' ? 'title' : 'description'; updateDoc(doc(db, `whiteboards/${whiteboardId}/state/main`), { [key]: el.innerText }); }
        function handleKeyDown(e) { state.isShiftDown = e.shiftKey; if (document.activeElement === chatInput) return; if (!state.selectedObjectId) return; let dx = 0, dy = 0; const nudgeAmount = e.shiftKey ? 10 : 1; switch (e.key) { case 'ArrowUp': dy = -nudgeAmount; break; case 'ArrowDown': dy = nudgeAmount; break; case 'ArrowLeft': dx = -nudgeAmount; break; case 'ArrowRight': dx = nudgeAmount; break; default: return; } e.preventDefault(); const selectedObject = state.allDrawings.get(state.selectedObjectId); if (!selectedObject) return; const movedObject = JSON.parse(JSON.stringify(selectedObject)); if (['path', 'triangle', 'line', 'arrow', 'star', 'speechBubble', 'heart'].includes(movedObject.type)) { movedObject.points = selectedObject.points.map(p => ({ x: p.x + dx, y: p.y + dy })); } else if (movedObject.type === 'circle') { movedObject.cx += dx; movedObject.cy += dy; } else { movedObject.x += dx; movedObject.y += dy; } updateObjectInFirestore(state.selectedObjectId, movedObject); }

        // --- Shape Drawing Helpers (Unchanged) ---
        function drawArrow(ctx, data) { const headlen = 10; const fromx = data.points[0].x; const fromy = data.points[0].y; const tox = data.points[1].x; const toy = data.points[1].y; const angle = Math.atan2(toy - fromy, tox - fromx); ctx.beginPath(); ctx.moveTo(fromx, fromy); ctx.lineTo(tox, toy); ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6)); ctx.moveTo(tox, toy); ctx.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6)); ctx.stroke(); }
        function getStarPoints(x, y, w, h) { let pts = []; const outerRadius = w / 2; const innerRadius = w / 4; const rot = Math.PI / 2 * 3; const cx = x + w / 2; const cy = y + h / 2; for (let i = 0; i < 5; i++) { pts.push({x: cx + outerRadius * Math.cos(rot + i * Math.PI / 2.5), y: cy + outerRadius * Math.sin(rot + i * Math.PI / 2.5)}); pts.push({x: cx + innerRadius * Math.cos(rot + (i + 0.5) * Math.PI / 2.5), y: cy + innerRadius * Math.sin(rot + (i + 0.5) * Math.PI / 2.5)}); } return pts; }
        function getSpeechBubblePoints(x, y, w, h) { const r = w * 0.1; return [ {x: x + r, y: y}, {x: x + w - r, y: y}, {x: x + w, y: y + r}, {x: x + w, y: y + h - r}, {x: x + w - r, y: y + h}, {x: x + r, y: y+h}, {x: x+r, y: y+h+r}, {x: x, y: y+h-r}, {x: x, y: y+r}, {x: x+r, y:y} ]; }
        function getHeartPoints(x, y, w, h) { let pts = []; for (let i = 0; i < 2 * Math.PI; i+=0.1) { const x_ = x + w / 2 + 16 * Math.pow(Math.sin(i), 3) * (w/40); const y_ = y + h / 2 - (13 * Math.cos(i) - 5 * Math.cos(2*i) - 2*Math.cos(3*i) - Math.cos(4*i)) * (h/40); pts.push({x:x_, y:y_}); } return pts; }

        // --- App Initialization ---
        window.addEventListener('load', () => {
            const app = initializeApp(firebaseConfig);
            const auth = getAuth(app);
            db = getFirestore(app);
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    document.getElementById('userId').textContent = userId.substring(0,8) + '...';
                    setupStateListener();
                    setupEventsListener();
                    setupChatListener(); // New listener for chat
                } else {
                    try { await signInAnonymously(auth); } catch (error) { console.error("Sign-in error", error); }
                }
            });
            // --- Event Listeners Setup ---
            eventCaptureLayer.addEventListener('mousedown', handleMouseDown);
            eventCaptureLayer.addEventListener('mousemove', handleMouseMove);
            eventCaptureLayer.addEventListener('mouseup', handleMouseUp);
            window.addEventListener('resize', redrawCanvas);
            textInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); saveAndHideTextInput(); } });
            document.body.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', (e) => { if (e.key === 'Shift') state.isShiftDown = false; });
            document.getElementById('tool-selector').addEventListener('click', (e) => { const button = e.target.closest('.tool-btn'); if(!button || !button.dataset.tool) return; saveAndHideTextInput(); state.currentTool = button.dataset.tool; eventCaptureLayer.style.cursor = state.currentTool === 'select' ? 'default' : (state.currentTool === 'text' ? 'text' : 'crosshair'); document.querySelectorAll('#tool-selector .tool-btn').forEach(b => b.classList.remove('selected')); button.classList.add('selected'); const parentDropdown = button.closest('.dropdown'); if (parentDropdown) { parentDropdown.firstElementChild.classList.add('selected'); } state.selectedObjectId = null; drawOverlay(); });
            document.getElementById('brush-size-selector').addEventListener('click', (e) => { const button = e.target.closest('button'); if(button && button.dataset.size) { state.currentBrushSize = parseInt(button.dataset.size, 10); document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('selected')); button.classList.add('selected'); } });
            
            const paletteContainer = document.getElementById('color-palette');
            const mainColors = [ { hex: '#FFFFFF' }, { hex: '#EF4444' }, { hex: '#F97316' }, { hex: '#EAB308' }, { hex: '#22C55E' }, { hex: '#3B82F6' }, { hex: '#8B5CF6' } ];
            mainColors.forEach((color, index) => {
                const group = document.createElement('div'); group.className = 'relative dropdown';
                const mainSwatch = document.createElement('button'); mainSwatch.className = `color-swatch w-8 h-8 rounded-full border-2 border-gray-400`; mainSwatch.style.backgroundColor = color.hex; mainSwatch.dataset.color = color.hex; mainSwatch.style.setProperty('--tw-color-ring', color.hex); if (index === 0) mainSwatch.classList.add('parent-selected'); group.appendChild(mainSwatch);
                const shadePalette = document.createElement('div'); shadePalette.className = 'dropdown-content absolute flex flex-col items-center gap-1 p-2 rounded-md bg-gray-600 shadow-lg';
                [1, 0.75, 0.5, 0.25].forEach(opacity => {
                    const r = parseInt(color.hex.slice(1,3), 16), g = parseInt(color.hex.slice(3,5), 16), b = parseInt(color.hex.slice(5,7), 16);
                    const rgbaColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                    const shade = document.createElement('button'); shade.style.backgroundColor = rgbaColor; shade.className = 'shade-swatch w-6 h-6 rounded-full border border-gray-400 hover:scale-110'; shade.dataset.color = rgbaColor; if(opacity === 1 && color.hex === '#FFFFFF') shade.classList.add('selected'); shadePalette.appendChild(shade);
                });
                group.appendChild(shadePalette);
                paletteContainer.appendChild(group);
            });
            paletteContainer.addEventListener('click', (e) => {
                const button = e.target.closest('button[data-color]');
                if (button) { state.currentColor = button.dataset.color; document.querySelectorAll('.color-swatch, .shade-swatch').forEach(s => s.classList.remove('selected', 'parent-selected')); button.classList.add('selected'); const parentGroup = button.closest('.dropdown'); if (parentGroup) { parentGroup.querySelector('.color-swatch').classList.add('parent-selected'); } const selectedObject = state.allDrawings.get(state.selectedObjectId); if(selectedObject) { updateObjectInFirestore(state.selectedObjectId, {...selectedObject, color: state.currentColor}); } }
            });

            // New/updated listeners
            document.getElementById('effects-dropdown').addEventListener('click', (e) => { const button = e.target.closest('button[data-effect]'); if (button) { sendEffectToFirestore(button.dataset.effect); } });
            chatSendBtn.addEventListener('click', sendChatMessage);
            chatInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); sendChatMessage(); }});
            document.getElementById('clear-button').addEventListener('click', () => { if(confirm("Are you sure you want to clear the entire whiteboard for everyone? This cannot be undone.")) { clearAllDrawings(); } });
            document.getElementById('delete-btn').addEventListener('click', deleteSelectedObject);
            document.getElementById('front-btn').addEventListener('click', bringToFront);
            document.getElementById('duplicate-btn').addEventListener('click', duplicateSelectedObject);
            document.getElementById('save-btn').addEventListener('click', () => { const tempCanvas = document.createElement('canvas'); const tempCtx = tempCanvas.getContext('2d'); const dpr = window.devicePixelRatio || 1; tempCanvas.width = canvas.width; tempCanvas.height = canvas.height; tempCtx.fillStyle = '#111827'; tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height); tempCtx.drawImage(canvas, 0, 0); const link = document.createElement('a'); link.download = 'whiteboard.png'; link.href = tempCanvas.toDataURL('image/png'); link.click(); });
            document.getElementById('whiteboard-title').addEventListener('blur', handleHeaderEdit);
            document.getElementById('whiteboard-description').addEventListener('blur', handleHeaderEdit);
            document.getElementById('whiteboard-title').addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); e.target.blur(); } });
            document.getElementById('whiteboard-description').addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); e.target.blur(); } });
            document.getElementById('help-btn').addEventListener('click', () => helpModalOverlay.classList.add('visible'));
            document.getElementById('close-help-btn').addEventListener('click', () => helpModalOverlay.classList.remove('visible'));
            helpModalOverlay.addEventListener('click', (e) => { if(e.target === helpModalOverlay) helpModalOverlay.classList.remove('visible'); });
        });
    </script>
</body>
</html>
 
