<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Whiteboard</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; touch-action: none; }
        #whiteboard, #overlay-canvas, #event-capture-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 0.75rem; }
        #whiteboard { z-index: 1; }
        #overlay-canvas { z-index: 2; pointer-events: none; }
        #event-capture-layer { z-index: 3; }
        .tool-btn, .color-swatch, .size-btn, #delete-btn { transition: all 0.1s ease-in-out; }
        .tool-btn.selected, .size-btn.selected { background-color: #4f46e5; color: white; transform: scale(1.1); }
        .color-swatch.parent-selected {
            box-shadow: 0 0 0 2px white, 0 0 0 4px var(--tw-color-ring);
        }
        .shade-swatch.selected {
             box-shadow: 0 0 0 2px white, 0 0 0 4px #4f46e5;
             transform: scale(1.1);
        }
        #text-input-container { position: absolute; display: none; z-index: 20; }
        #text-input { background: #1f2937; border: 1px dashed #6b7280; color: white; outline: none; font-family: 'Inter', sans-serif; padding: 4px; border-radius: 4px; }
        #delete-btn:disabled, #front-btn:disabled, #duplicate-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        [contenteditable="true"]:hover { outline: 1px dashed #4f46e5; cursor: text; }
        [contenteditable="true"]:focus { outline: 2px solid #4f46e5; }
        
        /* Styles for dropdown menus (Color & Shape Library) */
        .shade-palette, .shape-library {
            visibility: hidden;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.2s ease-out;
            position: absolute;
            top: 115%;
            left: 50%;
            transform: translateX(-50%) translateY(0px);
            z-index: 50;
        }
        .color-group:hover .shade-palette,
        .shape-library-btn:hover .shape-library {
            visibility: visible;
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
        /* Hover effect for shape library buttons */
        .shape-library .tool-btn:hover {
            background-color: #4b5563; /* gray-600 */
            transform: scale(1.1);
        }
    </style>
</head>
<body class="bg-gray-900 text-white h-full flex flex-col items-center justify-center p-4 antialiased">
    <div id="app-container" class="w-full max-w-7xl h-full flex flex-col bg-gray-800 rounded-2xl shadow-2xl p-4 md:p-6 relative">
        <!-- Header -->
        <header class="flex flex-col md:flex-row justify-between items-start mb-4 pb-4 border-b border-gray-700">
            <div>
                <h1 id="whiteboard-title" contenteditable="true" class="text-2xl font-bold text-white rounded px-1">Collaborative Whiteboard</h1>
                <p id="whiteboard-description" contenteditable="true" class="text-sm text-gray-400 rounded px-1">A real-time, interactive space to brainstorm, plan, and create. All changes are synced live with everyone on the board.</p>
            </div>
             <div class="flex flex-col items-end mt-2 md:mt-0 text-xs text-gray-500 space-y-2">
                <div>User ID: <span id="userId" class="font-mono bg-gray-700 px-2 py-1 rounded">Loading...</span></div>
                <div>Version: <span id="version-number" class="font-mono bg-gray-700 px-2 py-1 rounded">1.08</span></div>
            </div>
        </header>
        <!-- Toolbar -->
        <div id="toolbar" class="flex flex-wrap items-center justify-center gap-x-4 gap-y-2 mb-4">
            <div id="tool-selector" class="flex items-center gap-2 bg-gray-700 p-1 rounded-lg">
                <button data-tool="select" class="tool-btn p-2" title="Select & Move"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 3l7 19 2.5-7.5L22 3z"/></svg></button>
                <button data-tool="pen" class="tool-btn selected p-2" title="Pen"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg></button>
                
                <!-- CONSOLIDATED Shape Library Button -->
                <div class="relative shape-library-btn">
                     <button class="tool-btn p-2" title="Shapes"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path></svg></button>
                     <div class="shape-library flex flex-col items-center gap-1 p-2 rounded-md bg-gray-600 shadow-lg">
                        <button data-tool="line" class="tool-btn p-2" title="Line"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="19" x2="19" y2="5"></line></svg></button>
                        <button data-tool="rectangle" class="tool-btn p-2" title="Rectangle"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/></svg></button>
                        <button data-tool="circle" class="tool-btn p-2" title="Circle"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/></svg></button>
                        <button data-tool="triangle" class="tool-btn p-2" title="Triangle"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 20h18L12 4z"/></svg></button>
                        <button data-tool="arrow" class="tool-btn p-2" title="Arrow"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></button>
                        <button data-tool="star" class="tool-btn p-2" title="Star"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg></button>
                        <button data-tool="speechBubble" class="tool-btn p-2" title="Speech Bubble"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg></button>
                        <button data-tool="heart" class="tool-btn p-2" title="Heart"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></button>
                    </div>
                </div>
                <button data-tool="text" class="tool-btn p-2" title="Text"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg></button>
            </div>
             <div class="flex items-center gap-2 bg-gray-700 p-1 rounded-lg">
                <button id="duplicate-btn" class="p-2 text-green-400 hover:text-green-500" title="Duplicate Selected" disabled><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button>
                <button id="front-btn" class="p-2 text-blue-400 hover:text-blue-500" title="Bring to Front" disabled><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg></button>
                <button id="delete-btn" class="p-2 text-red-400 hover:text-red-500" title="Delete Selected" disabled><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg></button>
            </div>
            <div id="brush-size-selector" class="flex items-center gap-2 bg-gray-700 p-1 rounded-lg">
                 <button data-size="2" class="size-btn selected p-2" title="Small"><div class="w-1.5 h-1.5 bg-white rounded-full"></div></button>
                 <button data-size="5" class="size-btn p-2" title="Medium"><div class="w-2.5 h-2.5 bg-white rounded-full"></div></button>
                 <button data-size="10" class="size-btn p-2" title="Large"><div class="w-4 h-4 bg-white rounded-full"></div></button>
            </div>
            <div id="color-palette" class="flex items-end gap-2">
                 <!-- Colors generated by JS -->
            </div>
            <div class="flex items-center gap-2">
                <button id="save-btn" class="p-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-white" title="Save as PNG"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg></button>
                <button id="clear-button" disable-hosting-zip="true" class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg font-semibold transition-colors shadow-md">Clear</button>
            </div>
        </div>
        <!-- Main Content Area -->
        <main id="main-content" class="flex-grow w-full h-full min-h-0 relative">
            <canvas id="whiteboard" class="bg-gray-900 shadow-inner"></canvas>
            <canvas id="overlay-canvas"></canvas>
            <div id="event-capture-layer"></div>
            <div id="text-input-container"><input type="text" id="text-input" /></div>
        </main>
    </div>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, onSnapshot, collection, addDoc, doc, setDoc, query, where, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        const firebaseConfig = { apiKey: "AIzaSyAGO0CRIL44bj9-y5k2ARi2qGqZaZ7vLPc", authDomain: "whiteboard-00.firebaseapp.com", projectId: "whiteboard-00", storageBucket: "whiteboard-00.appspot.com", messagingSenderId: "34696279859", appId: "1:34696279859:web:a01addc7e57a8d06947046" };
        const whiteboardId = "google-sites-whiteboard-advanced";
        const eventCaptureLayer = document.getElementById('event-capture-layer');
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        const overlayCanvas = document.getElementById('overlay-canvas');
        const overlayCtx = overlayCanvas.getContext('2d');
        const textInputContainer = document.getElementById('text-input-container');
        const textInput = document.getElementById('text-input');
        const deleteBtn = document.getElementById('delete-btn');
        const frontBtn = document.getElementById('front-btn');
        const duplicateBtn = document.getElementById('duplicate-btn');
        const whiteboardTitleEl = document.getElementById('whiteboard-title');
        const whiteboardDescEl = document.getElementById('whiteboard-description');
        
        let db, userId;
        let unsubscribeFromDrawings, unsubscribeFromState;
        
        const state = {
            action: 'none', startPos: null, currentTool: 'pen', currentColor: '#FFFFFF', currentBrushSize: 2, currentEpoch: 0,
            allDrawings: new Map(), sortedDrawings: [], selectedObjectId: null, dragOffset: { x: 0, y: 0 },
            tempDrawing: null, resizeHandle: null, isTexting: false, isShiftDown: false,
        };
        
        function setupStateListener() { const stateDocPath = `whiteboards/${whiteboardId}/state/main`; if(unsubscribeFromState) unsubscribeFromState(); unsubscribeFromState = onSnapshot(doc(db, stateDocPath), (doc) => { const boardState = doc.data() || {}; const newEpoch = boardState.epoch || 1; if (boardState.title && whiteboardTitleEl.innerText !== boardState.title) { whiteboardTitleEl.innerText = boardState.title; } if (boardState.description && whiteboardDescEl.innerText !== boardState.description) { whiteboardDescEl.innerText = boardState.description; } if (newEpoch !== state.currentEpoch) { state.currentEpoch = newEpoch; setupDrawingsListener(); } }); }
        function setupDrawingsListener() { if (state.currentEpoch === 0) return; if (unsubscribeFromDrawings) unsubscribeFromDrawings(); state.allDrawings.clear(); state.selectedObjectId = null; redrawCanvas(); const drawingsCollectionPath = `whiteboards/${whiteboardId}/drawings`; const q = query(collection(db, drawingsCollectionPath), where("epoch", "==", state.currentEpoch)); unsubscribeFromDrawings = onSnapshot(q, (snapshot) => { snapshot.docChanges().forEach((change) => { const docData = change.doc.data(); if (docData.isDeleted) { state.allDrawings.delete(change.doc.id); } else { state.allDrawings.set(change.doc.id, { id: change.doc.id, ...docData }); } }); state.sortedDrawings = Array.from(state.allDrawings.values()).sort((a, b) => (a.timestamp?.seconds || 0) - (b.timestamp?.seconds || 0)); redrawCanvas(); }); }
        function redrawCanvas() { const dpr = window.devicePixelRatio || 1; const rect = canvas.getBoundingClientRect(); [canvas, overlayCanvas, eventCaptureLayer].forEach(c => { if (c.width !== rect.width * dpr || c.height !== rect.height * dpr) { c.width = rect.width * dpr; c.height = rect.height * dpr; if (c.style) { c.style.width = `${rect.width}px`; c.style.height = `${rect.height}px`; } if(c.getContext) c.getContext('2d').scale(dpr, dpr); } }); ctx.clearRect(0, 0, canvas.width, canvas.height); state.sortedDrawings.forEach(data => drawObject(ctx, data)); drawOverlay(); }
        function drawOverlay() { overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height); if (state.tempDrawing) drawObject(overlayCtx, state.tempDrawing); const selectedObject = state.allDrawings.get(state.selectedObjectId); if (selectedObject) { drawSelectionBox(selectedObject); deleteBtn.disabled = false; frontBtn.disabled = false; duplicateBtn.disabled = false; } else { deleteBtn.disabled = true; frontBtn.disabled = true; duplicateBtn.disabled = true; } }
        function drawObject(context, data) { if (!data) return; context.save(); const bounds = getObjectBounds(data); if(!bounds) { context.restore(); return; } const centerX = bounds.x + bounds.width / 2; const centerY = bounds.y + bounds.height / 2; context.translate(centerX, centerY); context.rotate(data.angle || 0); context.translate(-centerX, -centerY); context.strokeStyle = data.color; context.fillStyle = data.color; context.lineWidth = data.lineWidth || 2; context.lineCap = 'round'; switch(data.type) { case 'path': case 'line': if (!data.points || data.points.length < 1) break; context.beginPath(); context.moveTo(data.points[0].x, data.points[0].y); for (let i = 1; i < data.points.length; i++) context.lineTo(data.points[i].x, data.points[i].y); context.stroke(); break; case 'rectangle': context.strokeRect(data.x, data.y, data.width, data.height); break; case 'circle': context.beginPath(); context.arc(data.cx, data.cy, data.radius, 0, 2 * Math.PI); context.stroke(); break; case 'triangle': if (!data.points || data.points.length < 3) break; context.beginPath(); context.moveTo(data.points[0].x, data.points[0].y); context.lineTo(data.points[1].x, data.points[1].y); context.lineTo(data.points[2].x, data.points[2].y); context.closePath(); context.stroke(); break; case 'text': context.font = `${data.fontSize}px Inter`; context.textBaseline = 'top'; context.fillText(data.text, data.x, data.y); break; case 'arrow': drawArrow(context, data); break; case 'star': drawStar(context, data); break; case 'speechBubble': drawSpeechBubble(context, data); break; case 'heart': drawHeart(context, data); break; } context.restore(); }
        function getResizeHandles(bounds) { return { tl: { x: bounds.x, y: bounds.y }, tr: { x: bounds.x + bounds.width, y: bounds.y }, bl: { x: bounds.x, y: bounds.y + bounds.height }, br: { x: bounds.x + bounds.width, y: bounds.y + bounds.height }, }; }
        function getRotationHandle(bounds) { return { x: bounds.x + bounds.width / 2, y: bounds.y - 30, radius: 8 }; }
        function drawSelectionBox(obj) { const bounds = getObjectBounds(obj); if (!bounds) return; overlayCtx.save(); const centerX = bounds.x + bounds.width / 2; const centerY = bounds.y + bounds.height / 2; overlayCtx.translate(centerX, centerY); overlayCtx.rotate(obj.angle || 0); overlayCtx.translate(-centerX, -centerY); overlayCtx.strokeStyle = '#007bff'; overlayCtx.lineWidth = 1; overlayCtx.setLineDash([5, 5]); overlayCtx.strokeRect(bounds.x - 5, bounds.y - 5, bounds.width + 10, bounds.height + 10); overlayCtx.setLineDash([]); const rotationHandle = getRotationHandle(bounds); overlayCtx.beginPath(); overlayCtx.arc(rotationHandle.x, rotationHandle.y, rotationHandle.radius, 0, 2 * Math.PI); overlayCtx.fillStyle = '#007bff'; overlayCtx.fill(); const resizeHandles = getResizeHandles(bounds); overlayCtx.fillStyle = '#fff'; overlayCtx.strokeStyle = '#007bff'; for (const handle in resizeHandles) { overlayCtx.beginPath(); overlayCtx.rect(resizeHandles[handle].x - 4, resizeHandles[handle].y - 4, 8, 8); overlayCtx.fill(); overlayCtx.stroke(); } overlayCtx.restore(); }
        function handleMouseDown(event) { const pos = getEventPosition(event); if (state.isTexting) saveAndHideTextInput(); if (state.currentTool === 'text') { showTextInput(pos); return; } if (state.currentTool === 'line' && state.action === 'drawing') { state.drawing = false; state.action = 'none'; if(state.tempDrawing) sendObjectToFirestore(state.tempDrawing); state.tempDrawing = null; drawOverlay(); return; } state.startPos = pos; state.action = 'none'; if (state.currentTool === 'select') { const selectedObject = state.allDrawings.get(state.selectedObjectId); if (selectedObject) { const bounds = getObjectBounds(selectedObject); const transformedPos = getTransformedPoint(pos, selectedObject); const rotationHandle = getRotationHandle(bounds); const resizeHandles = getResizeHandles(bounds); if (isPointInCircle(transformedPos, rotationHandle)) { state.action = 'rotating'; } else { for(const handleName in resizeHandles) { if(isPointInCircle(transformedPos, {...resizeHandles[handleName], radius: 8})) { state.action = 'resizing'; state.resizeHandle = handleName; break; } } } } if (state.action === 'none') { const clickedObject = getObjectAtPosition(pos); state.selectedObjectId = clickedObject ? clickedObject.id : null; if (state.selectedObjectId) { state.action = 'dragging'; const selected = state.allDrawings.get(state.selectedObjectId); const bounds = getObjectBounds(selected); state.dragOffset.x = pos.x - bounds.x; state.dragOffset.y = pos.y - bounds.y; } } } else { state.action = 'drawing'; state.selectedObjectId = null; } if(state.action !== 'none') state.drawing = true; drawOverlay(); }
        function handleMouseMove(event) { if (!state.drawing && state.currentTool !== 'line' && state.action !== 'drawing') return; const pos = getEventPosition(event); const selectedObject = state.allDrawings.get(state.selectedObjectId); if (state.action === 'dragging' && selectedObject) { const bounds = getObjectBounds(selectedObject); const newBoundsX = pos.x - state.dragOffset.x; const newBoundsY = pos.y - state.dragOffset.y; const dx = newBoundsX - bounds.x; const dy = newBoundsY - bounds.y; state.tempDrawing = JSON.parse(JSON.stringify(selectedObject)); if (['path', 'triangle', 'line', 'arrow', 'star', 'speechBubble', 'heart'].includes(state.tempDrawing.type)) { state.tempDrawing.points = selectedObject.points.map(p => ({ x: p.x + dx, y: p.y + dy })); } else if (state.tempDrawing.type === 'circle') { state.tempDrawing.cx += dx; state.tempDrawing.cy += dy; } else { state.tempDrawing.x += dx; state.tempDrawing.y += dy; } } else if (state.action === 'rotating' && selectedObject) { const bounds = getObjectBounds(selectedObject); const centerX = bounds.x + bounds.width / 2; const centerY = bounds.y + bounds.height / 2; const angle = Math.atan2(pos.y - centerY, pos.x - centerX) + Math.PI / 2; state.tempDrawing = { ...selectedObject, angle }; } else if (state.action === 'resizing' && selectedObject) { state.tempDrawing = resizeObject(selectedObject, pos, state.resizeHandle, state.isShiftDown); } else if (state.action === 'drawing') { state.tempDrawing = createPreviewObject(pos); } drawOverlay(); }
        function handleMouseUp() { if (state.currentTool === 'line' && state.action === 'drawing') return; if (!state.drawing) return; state.drawing = false; if (state.action === 'dragging' || state.action === 'rotating' || state.action === 'resizing') { if (state.tempDrawing) { updateObjectInFirestore(state.selectedObjectId, state.tempDrawing); state.allDrawings.set(state.selectedObjectId, state.tempDrawing); } } else if (state.action === 'drawing' && state.tempDrawing) { sendObjectToFirestore(state.tempDrawing); } state.action = 'none'; state.tempDrawing = null; state.resizeHandle = null; if (state.currentTool !== 'select') state.selectedObjectId = null; drawOverlay(); }
        function resizeObject(obj, pos, handle, keepAspectRatio = false) { const newObj = JSON.parse(JSON.stringify(obj)); const oldBounds = getObjectBounds(obj); if (!oldBounds) return newObj; const transformedPos = getTransformedPoint(pos, obj); const anchor = { x: handle.includes('l') ? oldBounds.x + oldBounds.width : oldBounds.x, y: handle.includes('t') ? oldBounds.y + oldBounds.height : oldBounds.y }; let newWidth = Math.abs(transformedPos.x - anchor.x); let newHeight = Math.abs(transformedPos.y - anchor.y); if(keepAspectRatio && oldBounds.width > 0 && oldBounds.height > 0) { const aspectRatio = oldBounds.width / oldBounds.height; if (newWidth / oldBounds.width > newHeight / oldBounds.height) { newHeight = newWidth / aspectRatio; } else { newWidth = newHeight * aspectRatio; } } newWidth = Math.max(10, newWidth); newHeight = Math.max(10, newHeight); const scaleX = newWidth / (oldBounds.width || 1); const scaleY = newHeight / (oldBounds.height || 1); newObj.x = handle.includes('l') ? anchor.x - newWidth : oldBounds.x; newObj.y = handle.includes('t') ? anchor.y - newHeight : oldBounds.y; if (newObj.type === 'rectangle') { newObj.width = newWidth; newObj.height = newHeight; } else if (newObj.type === 'circle') { newObj.radius = Math.max(5, (newWidth + newHeight) / 4); newObj.cx = newObj.x + newObj.radius; newObj.cy = newObj.y + newObj.radius; } else if (newObj.type === 'text') { newObj.fontSize = Math.max(8, newObj.fontSize * scaleY); } else if (['path', 'triangle', 'line', 'arrow', 'star', 'speechBubble', 'heart'].includes(obj.type)) { newObj.points = obj.points.map(p => ({ x: newObj.x + (p.x - oldBounds.x) * scaleX, y: newObj.y + (p.y - oldBounds.y) * scaleY, })); } return newObj; }
        function createPreviewObject(pos) { const common = { color: state.currentColor, lineWidth: state.currentBrushSize, angle: 0 }; let finalPos = pos; if (state.currentTool === 'line' && state.isShiftDown) { const dx = pos.x - state.startPos.x; const dy = pos.y - state.startPos.y; const angle = Math.atan2(dy, dx); const snappedAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4); const dist = Math.sqrt(dx * dx + dy * dy); finalPos = { x: state.startPos.x + dist * Math.cos(snappedAngle), y: state.startPos.y + dist * Math.sin(snappedAngle), }; } const width = Math.abs(state.startPos.x - finalPos.x); const height = Math.abs(state.startPos.y - finalPos.y); const left = Math.min(state.startPos.x, finalPos.x); const top = Math.min(state.startPos.y, finalPos.y); switch (state.currentTool) { case 'pen': if(!state.tempDrawing) { state.tempDrawing = { type: 'path', points: [state.startPos], ...common }; } state.tempDrawing.points.push(pos); return state.tempDrawing; case 'line': return { type: 'line', points: [state.startPos, finalPos], ...common }; case 'rectangle': return { type: 'rectangle', x: left, y: top, width, height, ...common }; case 'circle': const radius = Math.sqrt(Math.pow(finalPos.x - state.startPos.x, 2) + Math.pow(finalPos.y - state.startPos.y, 2)); return { type: 'circle', cx: state.startPos.x, cy: state.startPos.y, radius, ...common }; case 'triangle': return { type: 'triangle', points: [ { x: state.startPos.x, y: finalPos.y }, { x: finalPos.x, y: finalPos.y }, { x: (state.startPos.x + finalPos.x) / 2, y: state.startPos.y } ], ...common }; case 'arrow': return { type: 'arrow', points: [state.startPos, finalPos], ...common }; case 'star': return { type: 'star', points: getStarPoints(left, top, width, height), ...common }; case 'speechBubble': return { type: 'speechBubble', points: getSpeechBubblePoints(left, top, width, height), ...common }; case 'heart': return { type: 'heart', points: getHeartPoints(left, top, width, height), ...common }; default: return null; } }
        function getFontSize() { if (state.currentBrushSize <= 2) return 16; if (state.currentBrushSize <= 5) return 24; return 40; }
        function showTextInput(pos) { state.isTexting = true; textInputContainer.style.left = `${pos.x}px`; textInputContainer.style.top = `${pos.y}px`; textInputContainer.style.display = 'block'; textInput.style.color = state.currentColor; textInput.style.fontSize = `${getFontSize()}px`; textInput.value = ''; setTimeout(() => textInput.focus(), 0); }
        function saveAndHideTextInput() { if (!state.isTexting) return; const text = textInput.value.trim(); if (text) { const rect = textInputContainer.getBoundingClientRect(); const canvasRect = canvas.getBoundingClientRect(); sendObjectToFirestore({ type: 'text', text, x: rect.left - canvasRect.left, y: rect.top - canvasRect.top, color: state.currentColor, fontSize: getFontSize() }); } textInput.value = ''; textInputContainer.style.display = 'none'; state.isTexting = false; }
        function getEventPosition(e) { const rect = eventCaptureLayer.getBoundingClientRect(); const clientX = e.clientX ?? e.touches[0].clientX; const clientY = e.clientY ?? e.touches[0].clientY; return { x: clientX - rect.left, y: clientY - rect.top }; }
        function getObjectAtPosition(pos) { const reversedObjects = state.sortedDrawings.slice().reverse(); return reversedObjects.find(obj => isPointInObject(pos, obj)) || null; }
        function getTransformedPoint(pos, obj) { const bounds = getObjectBounds(obj); if(!bounds) return pos; const centerX = bounds.x + bounds.width / 2; const centerY = bounds.y + bounds.height / 2; const angle = -(obj.angle || 0); const dx = pos.x - centerX; const dy = pos.y - centerY; return { x: dx * Math.cos(angle) - dy * Math.sin(angle) + centerX, y: dx * Math.sin(angle) + dy * Math.cos(angle) + centerY, }; }
        function isPointInCircle(point, circle) { const dx = point.x - circle.x; const dy = point.y - circle.y; return dx * dx + dy * dy <= circle.radius * circle.radius; }
        function isPointInObject(pos, obj) { const transformedPos = getTransformedPoint(pos, obj); const bounds = getObjectBounds(obj); if (!bounds) return false; if (obj.type === 'circle') return isPointInCircle(transformedPos, {x: obj.cx, y: obj.cy, radius: obj.radius}); if (['path', 'triangle', 'star', 'speechBubble', 'heart', 'arrow'].includes(obj.type)) { ctx.beginPath(); if (obj.points && obj.points.length > 0) { ctx.moveTo(obj.points[0].x, obj.points[0].y); for(let i=1; i < obj.points.length; i++){ ctx.lineTo(obj.points[i].x, obj.points[i].y); } } if(obj.type !== 'arrow' && obj.type !== 'line') ctx.closePath(); return ctx.isPointInPath(transformedPos.x, transformedPos.y); } const tolerance = 5; return transformedPos.x >= bounds.x - tolerance && transformedPos.x <= bounds.x + bounds.width + tolerance && transformedPos.y >= bounds.y - tolerance && transformedPos.y <= bounds.y + bounds.height + tolerance; }
        function getObjectBounds(obj) { let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; if(!obj) return null; switch (obj.type) { case 'rectangle': return { x: obj.x, y: obj.y, width: obj.width, height: obj.height }; case 'circle': return { x: obj.cx - obj.radius, y: obj.cy - obj.radius, width: obj.radius * 2, height: obj.radius * 2 }; case 'text': ctx.font = `${obj.fontSize}px Inter`; return { x: obj.x, y: obj.y, width: ctx.measureText(obj.text).width, height: obj.fontSize }; case 'path': case 'line': case 'triangle': case 'arrow': case 'star': case 'speechBubble': case 'heart': if (!obj.points || obj.points.length === 0) return null; obj.points.forEach(p => { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); }); return { x: minX, y: minY, width: maxX - minX, height: maxY - minY }; default: return null; } }
        async function sendObjectToFirestore(object) { if (!userId || state.currentEpoch === 0) return; const newDocRef = await addDoc(collection(db, `whiteboards/${whiteboardId}/drawings`), { ...object, author: userId, timestamp: new Date(), epoch: state.currentEpoch, isDeleted: false, angle: 0 }); return newDocRef.id; }
        async function updateObjectInFirestore(id, updatedObject) { const docRef = doc(db, `whiteboards/${whiteboardId}/drawings`, id); const finalUpdate = { ...updatedObject }; delete finalUpdate.id; await updateDoc(docRef, finalUpdate); }
        async function bringToFront() { if (!state.selectedObjectId) return; await updateObjectInFirestore(state.selectedObjectId, { timestamp: new Date() }); }
        async function duplicateSelectedObject() { if (!state.selectedObjectId) return; const originalObject = state.allDrawings.get(state.selectedObjectId); if (!originalObject) return; const newObject = JSON.parse(JSON.stringify(originalObject)); delete newObject.id; const dx = 10, dy = 10; if (['path', 'triangle', 'line', 'arrow', 'star', 'speechBubble', 'heart'].includes(newObject.type)) { newObject.points = newObject.points.map(p => ({ x: p.x + dx, y: p.y + dy })); } else if (newObject.type === 'circle') { newObject.cx += dx; newObject.cy += dy; } else { newObject.x += dx; newObject.y += dy; } const newId = await sendObjectToFirestore(newObject); state.selectedObjectId = newId; }
        async function deleteSelectedObject() { if (!state.selectedObjectId) return; await updateObjectInFirestore(state.selectedObjectId, { isDeleted: true }); state.selectedObjectId = null; drawOverlay(); }
        async function clearAllDrawings() { await setDoc(doc(db, `whiteboards/${whiteboardId}/state/main`), { epoch: Date.now() }); }
        function handleHeaderEdit(e) { const el = e.target; const key = el.id === 'whiteboard-title' ? 'title' : 'description'; updateDoc(doc(db, `whiteboards/${whiteboardId}/state/main`), { [key]: el.innerText }); }
        function handleKeyDown(e) { if (!state.selectedObjectId) return; let dx = 0, dy = 0; const nudgeAmount = e.shiftKey ? 10 : 1; switch (e.key) { case 'ArrowUp': dy = -nudgeAmount; break; case 'ArrowDown': dy = nudgeAmount; break; case 'ArrowLeft': dx = -nudgeAmount; break; case 'ArrowRight': dx = nudgeAmount; break; default: return; } e.preventDefault(); const selectedObject = state.allDrawings.get(state.selectedObjectId); if (!selectedObject) return; const movedObject = JSON.parse(JSON.stringify(selectedObject)); if (['path', 'triangle', 'line', 'arrow', 'star', 'speechBubble', 'heart'].includes(movedObject.type)) { movedObject.points = selectedObject.points.map(p => ({ x: p.x + dx, y: p.y + dy })); } else if (movedObject.type === 'circle') { movedObject.cx += dx; movedObject.cy += dy; } else { movedObject.x += dx; movedObject.y += dy; } updateObjectInFirestore(state.selectedObjectId, movedObject); }
        function drawArrow(ctx, data) { const headlen = 10; const fromx = data.points[0].x; const fromy = data.points[0].y; const tox = data.points[1].x; const toy = data.points[1].y; const angle = Math.atan2(toy - fromy, tox - fromx); ctx.beginPath(); ctx.moveTo(fromx, fromy); ctx.lineTo(tox, toy); ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6)); ctx.moveTo(tox, toy); ctx.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6)); ctx.stroke(); }
        function drawStar(ctx, data) { const points = data.points; ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y); for(let i = 1; i < points.length; i++) { ctx.lineTo(points[i].x, points[i].y); } ctx.closePath(); ctx.stroke(); }
        function drawSpeechBubble(ctx, data) { const points = data.points; ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y); for(let i = 1; i < points.length; i++) { ctx.lineTo(points[i].x, points[i].y); } ctx.closePath(); ctx.stroke(); }
        function drawHeart(ctx, data) { const points = data.points; ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y); for(let i = 1; i < points.length; i++) { ctx.lineTo(points[i].x, points[i].y); } ctx.closePath(); ctx.stroke(); }
        function getStarPoints(x, y, w, h) { let pts = []; const outerRadius = w / 2; const innerRadius = w / 4; const rot = Math.PI / 2 * 3; const cx = x + w / 2; const cy = y + h / 2; for (let i = 0; i < 5; i++) { pts.push({x: cx + outerRadius * Math.cos(rot + i * Math.PI / 2.5), y: cy + outerRadius * Math.sin(rot + i * Math.PI / 2.5)}); pts.push({x: cx + innerRadius * Math.cos(rot + (i + 0.5) * Math.PI / 2.5), y: cy + innerRadius * Math.sin(rot + (i + 0.5) * Math.PI / 2.5)}); } return pts; }
        function getSpeechBubblePoints(x, y, w, h) { const r = w * 0.1; return [ {x: x + r, y: y}, {x: x + w - r, y: y}, {x: x + w, y: y + r}, {x: x + w, y: y + h - r}, {x: x + w - r, y: y + h}, {x: x + r, y: y+h}, {x: x+r, y: y+h+r}, {x: x, y: y+h-r}, {x: x, y: y+r}, {x: x+r, y:y} ]; }
        function getHeartPoints(x, y, w, h) { let pts = []; for (let i = 0; i < 2 * Math.PI; i+=0.1) { const x_ = x + w / 2 + 16 * Math.pow(Math.sin(i), 3) * (w/40); const y_ = y + h / 2 - (13 * Math.cos(i) - 5 * Math.cos(2*i) - 2*Math.cos(3*i) - Math.cos(4*i)) * (h/40); pts.push({x:x_, y:y_}); } return pts; }

        window.addEventListener('load', () => {
            const app = initializeApp(firebaseConfig);
            const auth = getAuth(app);
            db = getFirestore(app);
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    document.getElementById('userId').textContent = userId;
                    setupStateListener();
                } else {
                    try { await signInAnonymously(auth); } catch (error) { console.error("Sign-in error", error); }
                }
            });
            eventCaptureLayer.addEventListener('mousedown', handleMouseDown);
            eventCaptureLayer.addEventListener('mousemove', handleMouseMove);
            eventCaptureLayer.addEventListener('mouseup', handleMouseUp);
            window.addEventListener('resize', redrawCanvas);
            textInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); saveAndHideTextInput(); } });
            document.body.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', (e) => { if (e.key === 'Shift') state.isShiftDown = false; });
            document.getElementById('tool-selector').addEventListener('click', (e) => { 
                const button = e.target.closest('.tool-btn'); 
                if(!button || !button.dataset.tool) return; 
                saveAndHideTextInput(); 
                state.currentTool = button.dataset.tool; 
                eventCaptureLayer.style.cursor = state.currentTool === 'select' ? 'default' : (state.currentTool === 'text' ? 'text' : 'crosshair'); 
                
                document.querySelectorAll('#tool-selector .tool-btn').forEach(b => b.classList.remove('selected')); 
                
                button.classList.add('selected'); 
                
                const parentShapeBtnContainer = button.closest('.shape-library-btn');
                if (parentShapeBtnContainer) {
                    parentShapeBtnContainer.firstElementChild.classList.add('selected');
                }
               
                state.selectedObjectId = null; 
                drawOverlay(); 
            });
            document.getElementById('brush-size-selector').addEventListener('click', (e) => { const button = e.target.closest('button'); if(button && button.dataset.size) { state.currentBrushSize = parseInt(button.dataset.size, 10); document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('selected')); button.classList.add('selected'); } });
            
            const paletteContainer = document.getElementById('color-palette');
            const mainColors = [
                { hex: '#FFFFFF' }, { hex: '#EF4444' }, { hex: '#F97316' }, 
                { hex: '#EAB308' }, { hex: '#22C55E' }, { hex: '#3B82F6' }, { hex: '#8B5CF6' }
            ];
            mainColors.forEach((color, index) => {
                const group = document.createElement('div');
                group.className = 'relative color-group';
                const mainSwatch = document.createElement('button');
                mainSwatch.className = `color-swatch w-8 h-8 rounded-full border-2 border-gray-400`;
                mainSwatch.style.backgroundColor = color.hex;
                mainSwatch.dataset.color = color.hex;
                mainSwatch.style.setProperty('--tw-color-ring', color.hex);
                if (index === 0) mainSwatch.classList.add('parent-selected');
                group.appendChild(mainSwatch);
                const shadePalette = document.createElement('div');
                shadePalette.className = 'shade-palette absolute flex flex-col items-center gap-1 p-2 rounded-md bg-gray-600 shadow-lg';
                [1, 0.75, 0.5, 0.25].forEach(opacity => {
                    const r = parseInt(color.hex.slice(1,3), 16);
                    const g = parseInt(color.hex.slice(3,5), 16);
                    const b = parseInt(color.hex.slice(5,7), 16);
                    const rgbaColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                    const shade = document.createElement('button');
                    shade.style.backgroundColor = rgbaColor;
                    shade.className = 'shade-swatch w-6 h-6 rounded-full border border-gray-400 hover:scale-110';
                    shade.dataset.color = rgbaColor;
                    if(opacity === 1 && color.hex === '#FFFFFF') shade.classList.add('selected');
                    shadePalette.appendChild(shade);
                });
                group.appendChild(shadePalette);
                paletteContainer.appendChild(group);
            });
            paletteContainer.addEventListener('click', (e) => {
                const button = e.target.closest('button[data-color]');
                if (button) {
                    state.currentColor = button.dataset.color;
                    document.querySelectorAll('.color-swatch, .shade-swatch').forEach(s => s.classList.remove('selected', 'parent-selected'));
                    button.classList.add('selected');
                    const parentGroup = button.closest('.color-group');
                    if (parentGroup) {
                        parentGroup.querySelector('.color-swatch').classList.add('parent-selected');
                    }
                    const selectedObject = state.allDrawings.get(state.selectedObjectId);
                    if(selectedObject) {
                        updateObjectInFirestore(state.selectedObjectId, {...selectedObject, color: state.currentColor});
                    }
                }
            });
            document.getElementById('clear-button').addEventListener('click', clearAllDrawings);
            document.getElementById('delete-btn').addEventListener('click', deleteSelectedObject);
            document.getElementById('front-btn').addEventListener('click', bringToFront);
            document.getElementById('duplicate-btn').addEventListener('click', duplicateSelectedObject);
            document.getElementById('save-btn').addEventListener('click', () => { const tempCanvas = document.createElement('canvas'); const tempCtx = tempCanvas.getContext('2d'); const dpr = window.devicePixelRatio || 1; tempCanvas.width = canvas.width; tempCanvas.height = canvas.height; tempCtx.fillStyle = '#111827'; tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height); tempCtx.drawImage(canvas, 0, 0); const link = document.createElement('a'); link.download = 'whiteboard.png'; link.href = tempCanvas.toDataURL('image/png'); link.click(); });
            whiteboardTitleEl.addEventListener('blur', handleHeaderEdit);
            whiteboardDescEl.addEventListener('blur', handleHeaderEdit);
            whiteboardTitleEl.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); whiteboardTitleEl.blur(); } });
            whiteboardDescEl.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); whiteboardDescEl.blur(); } });
        });
    </script>
</body>
</html>
